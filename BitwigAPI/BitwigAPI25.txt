package com.bitwig.extension;

import com.bitwig.extension.api.Host;

public abstract class Extension<HostType extends Host, DefinitionType extends ExtensionDefinition>
{
   protected Extension(final DefinitionType extensionDefinition, final HostType host)
   {
      super();
      mExtensionDefinition = extensionDefinition;
      mHost = host;
   }

   public HostType getHost()
   {
      return mHost;
   }

   public DefinitionType getExtensionDefinition()
   {
      return mExtensionDefinition;
   }

   private final DefinitionType mExtensionDefinition;

   private final HostType mHost;
}
-e 


package com.bitwig.extension;

import java.util.UUID;

/** Base class for defining any kind of extension for Bitwig Studio. */
public abstract class ExtensionDefinition
{
   /** The name of the extension. */
   public abstract String getName();

   /** The author of the extension. */
   public abstract String getAuthor();

   /** The version of the extension. */
   public abstract String getVersion();

   /** A unique id that identifies this extension. */
   public abstract UUID getId();

   /** The minimum API version number that this extensions requires. */
   public abstract int getRequiredAPIVersion();

   /**
    * Is this extension is using Beta APIs?
    *
    * Beta APIs are still on development and might not be available in a future version of Bitwig Studio.
    *
    * Turning this flag to true, will flag your extension as being a beta extension which might not work after
    * updating Bitwig Studio.
    *
    * @return true if the extension wants to use Beta APIs.
    */
   public boolean isUsingBetaAPI()
   {
      return false;
   }

   /**
    * Gets a remote URI or a path within the extension's jar file where documentation for this extension can
    * be found or null if there is none. If the path is not a URI then it is assumed to be a path below the directory
    * "Documentation" within the extension's jar file.
    */
   public String getHelpFilePath()
   {
      return null;
   }

   /**
    * Gets a remote URI or a path within the extension's jar file where support files for this extension can
    * be found or null if there is none. If the path is not a URI then it is assumed to be a path below the directory
    * "Documentation" within the extension's jar file.
    *
    * Support files are for example a configuration file that one has use with a configuration software.
    *
    * @since API version 13
    */
   public String getSupportFolderPath()
   {
      return null;
   }

   /**
    * If true then this extension should fail when it calls a deprecated method in the API. This is useful
    * during development.
    */
   public boolean shouldFailOnDeprecatedUse()
   {
      return true;
   }

   /**
    * An e-mail address that can be used to contact the author of this extension if a problem is detected with
    * it or null if none.
    */
   public String getErrorReportingEMail()
   {
      return null;
   }

   @Override
   public String toString()
   {
      return "Extension[name=" + getName() + ", author=" + getAuthor() + ", version=" + getVersion() + ", id="
         + getId() + "]";
   }
}
-e 


package com.bitwig.extension.controller;

/** Matcher that can match a particular hardware device that is connected to the user's machine.
 * Subclasses of this define how the hardware is connected.
 * Currently only USB devices are supported.
 * @see UsbDeviceMatcher
 * @see ControllerExtensionDefinition#listHardwareDevices(HardwareDeviceMatcherList) */
public abstract class HardwareDeviceMatcher
{
   protected HardwareDeviceMatcher(final String name)
   {
      super();
      mName = name;
   }

   /** Human friendly name for the kinds of hardware devices this matcher matches. */
   public String getName()
   {
      return mName;
   }

   private final String mName;
}
-e 


package com.bitwig.extension.controller;

public abstract class UsbMatcher
{
   UsbMatcher(final String expression, final int matchOccurrence)
   {
      super();
      assert matchOccurrence >= 1;

      mExpression = expression;
      mMatchOccurrence = matchOccurrence;
   }

   public final String getExpression()
   {
      return mExpression;
   }

   public final int getMatchOccurrence()
   {
      return mMatchOccurrence;
   }

   private final String mExpression;

   private final int mMatchOccurrence;
}
-e 


package com.bitwig.extension.controller;

import com.bitwig.extension.controller.api.UsbTransferDirection;
import com.bitwig.extension.controller.api.UsbTransferType;

public class UsbEndpointMatcher extends UsbMatcher
{
   public UsbEndpointMatcher(
      final UsbTransferDirection direction,
      final UsbTransferType transferType,
      final String expression,
      final int matchOccurrenceIndex)
   {
      super(expression, matchOccurrenceIndex);

      mDirection = direction;
      mTransferType = transferType;
   }

   public UsbEndpointMatcher(
      final UsbTransferDirection direction,
      final UsbTransferType transferType,
      final String expression)
   {
      this(direction, transferType, expression, 1);
   }

   public UsbEndpointMatcher(final UsbTransferType transferType, final byte bEndpointAddress)
   {
      this(UsbTransferDirection.getForEndpointAddress(bEndpointAddress), transferType, "bEndpointAddress == " + (bEndpointAddress & 0xff));
   }

   public UsbTransferDirection getDirection()
   {
      return mDirection;
   }

   public UsbTransferType getTransferType()
   {
      return mTransferType;
   }

   private final UsbTransferDirection mDirection;

   private final UsbTransferType mTransferType;
}
-e 


package com.bitwig.extension.controller;

import com.bitwig.extension.Extension;
import com.bitwig.extension.controller.api.ControllerHost;
import com.bitwig.extension.controller.api.MidiIn;
import com.bitwig.extension.controller.api.MidiOut;

/**
 * Defines an extension that enabled a controller to work with Bitwig Studio.
 */
public abstract class ControllerExtension extends Extension<ControllerHost, ControllerExtensionDefinition>
{
   protected ControllerExtension(final ControllerExtensionDefinition definition, final ControllerHost host)
   {
      super(definition, host);
   }

   public final MidiIn getMidiInPort(final int index)
   {
      return getHost().getMidiInPort(index);
   }

   public final MidiOut getMidiOutPort(final int index)
   {
      return getHost().getMidiOutPort(index);
   }

   /**
    * Initializes this controller extension. This will be called once when the extension is started. During initialization the
    * extension should call the various create methods available via the {@link ControllerHost} interface in order to
    * create objects used to communicate with various parts of the Bitwig Studio application (e.g
    * {@link ControllerHost#createCursorTrack(int, int)}.
    */
   public abstract void init();

   /**
    * Called once when this controller extension is stopped.
    */
   public abstract void exit();

   /**
    * Called when this controller extension should flush any pending updates to the controller.
    */
   public abstract void flush();
}
-e 


package com.bitwig.extension.controller;

import com.bitwig.extension.ExtensionDefinition;
import com.bitwig.extension.api.PlatformType;
import com.bitwig.extension.controller.api.ControllerHost;

/**
 * Defines an extension that enabled a controller to work with Bitwig Studio.
 */
public abstract class ControllerExtensionDefinition extends ExtensionDefinition
{
   @Override
   public String toString()
   {
      return "ControllerExtension[name=" + getName() + ", author=" + getAuthor() + ", version=" + getVersion()
         + ", hardwareVendor=" + getHardwareVendor() + ", hardwareModel=" + getHardwareModel() + ", id="
         + getId() + "]";
   }

   /** The vendor of the controller that this extension is for. */
   public abstract String getHardwareVendor();

   /** The model name of the controller that this extension is for. */
   public abstract String getHardwareModel();

   /** The number of MIDI in ports that this controller extension has. */
   public abstract int getNumMidiInPorts();

   /** The number of MIDI out ports that this controller extension has. */
   public abstract int getNumMidiOutPorts();

   /**
    * Obtains a {@link AutoDetectionMidiPortNamesList} that defines the names of the MIDI in and out ports
    * that can be used for auto detection of the controller for the supplied platform type.
    */
   public final AutoDetectionMidiPortNamesList getAutoDetectionMidiPortNamesList(
      final PlatformType platformType)
   {
      final AutoDetectionMidiPortNamesList list = new AutoDetectionMidiPortNamesList();
      listAutoDetectionMidiPortNames(list, platformType);

      return list;
   }

   /**
    * Lists the {@link AutoDetectionMidiPortNames} that defines the names of the MIDI in and out ports that
    * can be used for auto detection of the controller for the supplied platform type.
    */
   public abstract void listAutoDetectionMidiPortNames(
      AutoDetectionMidiPortNamesList list,
      PlatformType platformType);

   public final HardwareDeviceMatcherList getHardwareDeviceMatcherList()
   {
      final HardwareDeviceMatcherList list = new HardwareDeviceMatcherList();
      listHardwareDevices(list);

      return list;
   }

   /**
    * Lists the hardware devices that this controller needs to function. For each device that is listed the
    * user will see a chooser in the preferences for this extension that allows them to choose a connected
    * device. The {@link HardwareDeviceMatcher} will also be used during auto detection to automatically add
    * and select the device if possible.
    *
    * @since API version 7
    */
   public void listHardwareDevices(final HardwareDeviceMatcherList list)
   {
   }

   /** Creates an instance of this extension. */
   public abstract ControllerExtension createInstance(ControllerHost host);

   /**
    * Checks if this controller should be subscribed to objects by default.
    *
    * Prior to API version 10 all objects were subscribed by default. If this is overriden to return false
    * then it is the controller's job to call {@link ObjectProxy#subscribe()} for the objects that the
    * controller is interested in.
    *
    * @since API version 10
    */
//   public boolean shouldBeSubscribedByDefault()
//   {
//      return true;
//   }
}
-e 


package com.bitwig.extension.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class AutoDetectionMidiPortNamesList
{
   public void add(final String[] inputNames, final String[] outputNames)
   {
      mList.add(new AutoDetectionMidiPortNames(inputNames, outputNames));
   }

   public List<AutoDetectionMidiPortNames> getPortNames()
   {
      return Collections.unmodifiableList(mList);
   }

   public int getCount()
   {
      return mList.size();
   }

   public AutoDetectionMidiPortNames getPortNamesAt(final int index)
   {
      return mList.get(index);
   }

   private final List<AutoDetectionMidiPortNames> mList = new ArrayList<>(5);
}
-e 


package com.bitwig.extension.controller;

public class AutoDetectionMidiPortNames
{
   public AutoDetectionMidiPortNames(final String[] inputNames, final String[] outputNames)
   {
      super();
      mInputNames = inputNames;
      mOutputNames = outputNames;
   }

   public String[] getInputNames()
   {
      return mInputNames;
   }

   public String[] getOutputNames()
   {
      return mOutputNames;
   }

   private final String[] mInputNames, mOutputNames;
}
-e 


package com.bitwig.extension.controller;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Defines a list of all the hardware devices that a controller needs.
 *
 * @since API version 7
 */
public class HardwareDeviceMatcherList
{
   /**
    * Adds information about a hardware device that is needed and how it can be matched. The hardware device
    * will need to match at least one of the supplied matchers.
    *
    * For each entry added to this list the user will see a device chooser that lets them select an
    * appropriate device. The information added here is also used for auto detection purposes.
    */
   public void add(final HardwareDeviceMatcher... deviceMatchers)
   {
      mList.add(deviceMatchers);
   }

   /** The number of hardware devices in the list. */
   public int getCount()
   {
      return mList.size();
   }

   public HardwareDeviceMatcher[] getHardwareDeviceMatchersAt(final int index)
   {
      return mList.get(index);
   }

   public List<HardwareDeviceMatcher[]> getList()
   {
      return Collections.unmodifiableList(mList);
   }

   private final List<HardwareDeviceMatcher[]> mList = new ArrayList<>(2);
}
-e 


package com.bitwig.extension.controller;

public class UsbConfigurationMatcher extends UsbMatcher
{
   public UsbConfigurationMatcher(final String expression, final int matchOccurrenceIndex, final UsbInterfaceMatcher... interfaceMatchers)
   {
      super(expression, matchOccurrenceIndex);
      mInterfaceMatchers = interfaceMatchers;
   }

   public UsbConfigurationMatcher(final String expression, final UsbInterfaceMatcher... interfaceMatchers)
   {
      this(expression, 1, interfaceMatchers);
   }

   public UsbConfigurationMatcher(final int matchOccurrenceIndex, final UsbInterfaceMatcher... interfaceMatchers)
   {
      this("", matchOccurrenceIndex, interfaceMatchers);
   }

   public UsbConfigurationMatcher(final UsbInterfaceMatcher... interfaceMatchers)
   {
      this(1, interfaceMatchers);
   }

   public UsbInterfaceMatcher[] getInterfaceMatchers()
   {
      return mInterfaceMatchers;
   }

   private final UsbInterfaceMatcher[] mInterfaceMatchers;
}
-e 


package com.bitwig.extension.controller;

public class UsbInterfaceMatcher extends UsbMatcher
{
   public UsbInterfaceMatcher(final String expression, final int matchOccurrence, final UsbEndpointMatcher... endpointMatchers)
   {
      super(expression, matchOccurrence);

      mEndpointMatchers = endpointMatchers;
   }

   public UsbInterfaceMatcher(final String expression, final UsbEndpointMatcher... endpointMatchers)
   {
      this(expression, 1, endpointMatchers);
   }

   public UsbEndpointMatcher[] getEndpointMatchers()
   {
      return mEndpointMatchers;
   }

   private final UsbEndpointMatcher[] mEndpointMatchers;
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Defines an enumeration.
 *
 * @since API version 11
 */
public interface EnumDefinition
{
   /**
    * Gets the number of entries in the enum, must be greater than 0.
    * @since API version 11
    */
   @OscMethod
   int getValueCount();

   /**
    * Gets the {@link EnumValueDefinition} for the given index.
    * @param valueIndex must be in the range 0 .. {@link #getValueCount()} - 1.
    * @return null if not found
    * @since API version 11
    */
   @OscNode
   EnumValueDefinition valueDefinitionAt(int valueIndex);

   /**
    * Gets the {@link EnumValueDefinition} for the given enum id.
    * @return null if not found
    * @since API version 11
    */
   @OscNode
   EnumValueDefinition valueDefinitionFor(String id);
}
-e 


package com.bitwig.extension.controller.api;

/**
 *
 */

public enum HardwareControlType
{
   KNOB, // Absolute control
   SLIDER, // Absolute control
   ENCODER, // Relative control (never shows takeover-indication)
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to navigate the results column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserResultsItemBank extends BrowserItemBank<BrowserResultsItem>
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * An action that can happen on a hardware control. For example, the user touching it, pressing it, releasing
 * it etc.
 *
 * @since API version 10
 */
public interface HardwareAction extends HardwareBindingSource<HardwareActionBinding>
{
   /** Sets the {@link HardwareActionMatcher} that is used to recognize when this action happens. */
   void setActionMatcher(HardwareActionMatcher actionMatcher);

   /**
    * Sets the {@link AbsoluteHardwareValueMatcher} that is used to recognize when this action happens and
    * with what pressure.
    *
    * This is useful for a button press that is pressure sensitive. The pressure can be obtained by creating a
    * custom action with
    * {@link ControllerHost#createAction(java.util.function.DoubleConsumer, java.util.function.Supplier)} and
    * then binding the created action to this {@link HardwareAction}.
    */
   void setPressureActionMatcher(AbsoluteHardwareValueMatcher actionMatcher);

   /**
    * Checks if this action is supported (that is, it has a {@link HardwareActionMatcher} that can detect it).
    */
   boolean isSupported();

   /**
    * Decides if this action should fire even if the hardware input that matched it was also used as note
    * input. Note input is defined as input that matches a {@link NoteInput} mask and its event translations.
    * Usually events should only be note input or actions but not both at the same time (this is the default
    * state). However, occasionally it is useful for a note event to be played as both note input and also
    * trigger some action. For example, a drum pad may play a note but in a special mode on the controller it
    * should also select the pad somehow. In this case it would be both note input and the action that fires
    * to select the pad.
    *
    * @since API version 11
    */
   void setShouldFireEvenWhenUsedAsNoteInput(boolean value);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Mode that defines how a {@link CursorDevice} follows a device within the {@link CursorTrack} it is created
 * for by default. The user can still override this on a track by track basis but this defines a default
 * follow mode when the user has not done this.
 */
public enum CursorDeviceFollowMode
{
   /** Follows the device selection made by the user in the track. */
   FOLLOW_SELECTION,

   /** Selects the first device in the track if there is one. */
   FIRST_DEVICE,

   /** Selects the first instrument in the track if there is one. */
   FIRST_INSTRUMENT,

   /** Selects the first audio effect in the track if there is one. */
   FIRST_AUDIO_EFFECT,

   /**
    * Selects the first instrument or if there is no instrument the first device.
    *
    * @since API version 3
    */
   FIRST_INSTRUMENT_OR_DEVICE,

   /**
    * Selects the last device in the track if there is one.
    * @since API version 7
    */
   LAST_DEVICE,
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface that can be used to directly access a specific device (Bitwig native device or plug-in).
 *
 * @since API version 12
 * */
public interface SpecificDevice extends ObjectProxy
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * This interface represents a chain selector device which can be:
 * - instrument selector
 * - effect selector
 *
 * @since API version 6
 */
public interface ChainSelector extends ObjectProxy, Cursor
{
   /**
    * The index of the active chain in the chain selector.
    * In case the chain selector has no chains or the value is not connected to the chain selector,
    * then the value will be 0.
    *
    * @since API version 6
    */
   @OscNode
   SettableIntegerValue activeChainIndex();

   /**
    * The number of chains in the chain selector.
    *
    * @since API version 6
    */
   IntegerValue chainCount();

   /**
    * The active device layer.
    *
    * @since API version 6
    */
   @OscNode
   DeviceLayer activeChain();

   /**
    * Cycle to the next chain.
    * If the current active chain is the last one, then moves to the first one.
    *
    * @since API version 6
    */
   void cycleNext();

   /**
    * Cycle to the previous chain.
    * If the current active chain the first one, then moves to the last one.
    *
    * @since API version 6
    */
   void cyclePrevious();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

public interface ClipLauncherSlotOrScene extends ObjectProxy, DeleteableObject, DuplicableObject
{
   /**
    * Returns an object that provides access to the name of the scene.
    *
    * @return a string value object that represents the scene name.
    * @since API version 2
    */
   @OscNode
   StringValue name();

   /**
    * Launches the clip or scene.
    *
    * @since API version 1
    */
   @OscMethod
   void launch();

   HardwareActionBindable launchAction();

   /**
    * Launches with alternative settings.
    *
    * @since API version 18
    */
   @OscMethod
   void launchAlt();

   /**
    * @since API version 18
    */
   HardwareActionBindable launchAltAction();

   /**
    * Call it when the pad is released.
    *
    * @since API version 18
    */
   @OscMethod
   void launchRelease();

   /**
    * @since API version 18
    */
   HardwareActionBindable launchReleaseAction();

   /**
    * Call it when the pad is released with alternative settings.
    *
    * @since API version 18
    */
   @OscMethod
   void launchReleaseAlt();

   /**
    * @since API version 18
    */
   HardwareActionBindable launchReleaseAltAction();

   /**
    * Launches with the given options:
    *
    * @param quantization
    *           possible values are "default", "none", "8", "4", "2", "1", "1/2", "1/4", "1/8", "1/16"
    * @param launchMode
    *           possible values are: "default", "from_start", "continue_or_from_start",
    *           "continue_or_synced", "synced"
    *
    * @since API version 16
    */
   @OscMethod
   void launchWithOptions(final String quantization, final String launchMode);

   HardwareActionBindable launchWithOptionsAction(final String quantization, final String launchMode);

   /**
    * Launches the last clip with the given options:
    *
    * @param quantization
    *           possible values are "default", "none", "8", "4", "2", "1", "1/2", "1/4", "1/8", "1/16"
    * @param launchMode
    *           possible values are: "default", "from_start", "continue_or_from_start",
    *           "continue_or_synced", "synced"
    *
    * @since API version 16
    */
   @OscMethod
   void launchLastClipWithOptions(final String quantization, final String launchMode);

   HardwareActionBindable launchLastClipWithOptionsAction(final String quantization, final String launchMode);

   /**
    * Value that reports the position of the scene within the list of Bitwig Studio scenes.
    *
    * @since API version 2
    */
   @OscNode
   IntegerValue sceneIndex();

   /**
    * Copies the current slot or scene into the dest slot or scene.
    *
    * @since API version 4
    * @deprecated Use {@link #replaceInsertionPoint()} instead.
    */
   @Deprecated
   void copyFrom(ClipLauncherSlotOrScene source);

   /**
    * Moves the current slot or scene into the destination slot or scene.
    *
    * @since API version 4
    * @deprecated Use {@link #replaceInsertionPoint()} instead.
    */
   @Deprecated
   void moveTo(ClipLauncherSlotOrScene dest);

   /**
    * Value that reports the color of this slot.
    *
    * @since API version 7
    */
   @OscNode
   SettableColorValue color();

   /**
    * Specifies if the Bitwig Studio clip launcher should indicate which slots and scenes are part of the
    * window. By default indications are disabled.
    *
    * @param shouldIndicate
    *           `true` if visual indications should be enabled, `false` otherwise
    * @since API version 10
    * @deprecated Clip launcher indication is now not per slot or scene but instead as a framed rectangle in
    *             the user interface. Use {@link SceneBank#setIndication(boolean)} or
    *             {@link TrackBank#setShouldShowClipLauncherFeedback(boolean)}
    */
   @Deprecated
   @OscMethod
   void setIndication(boolean shouldIndicate);

   /**
    * An {@link InsertionPoint} that is used to replace the contents of this slot or scene.
    *
    * @since API version 7
    */
   InsertionPoint replaceInsertionPoint();

   /**
    * An {@link InsertionPoint} that can be used to insert content in the next scene.
    *
    * @since API version 7
    */
   InsertionPoint nextSceneInsertionPoint();

   /**
    * An {@link InsertionPoint} that can be used to insert content after this slot or scene.
    *
    * @since API version 7
    */
   InsertionPoint previousSceneInsertionPoint();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a means of recognizing when some kind of hardware input happens.
 *
 * For example, when a certain MIDI CC message happens.
 *
 * @see MidiIn#createActionMatcher(String)
 *
 * @since API version 10
 *
 */
public interface HardwareInputMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from a hardware action (such as user pressing a button) to some target action.
 *
 * @since API version 10
 * */
public interface HardwareActionBinding extends HardwareBinding
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent entries in a browser filter column.
 *
 * @since API version 1
 */
public interface CursorBrowserFilterItem extends BrowserFilterItem, CursorBrowserItem
{
   /**
    * Select the parent item.
    *
    * @since API version 1
    */
   void selectParent();

   /**
    * Select the first child item.
    *
    * @since API version 1
    */
   void selectFirstChild();

   /**
    * Select the last child item.
    *
    * @since API version 1
    */
   void selectLastChild();

   /**
    * Select the previous item.
    *
    * @since API version 1
    */
   void moveToPrevious();

   /**
    * Select the next item.
    *
    * @since API version 1
    */
   void moveToNext();

   /**
    * Select the first item.
    *
    * @since API version 1
    */
   void moveToFirst();

   /**
    * Select the last item.
    *
    * @since API version 1
    */
   void moveToLast();

   /**
    * Select the parent item.
    *
    * @since API version 1
    */
   void moveToParent();

   /**
    * Move the cursor to the first child item.
    *
    * @since API version 1
    */
   void moveToFirstChild();

   /**
    * Move the cursor to the last child item.
    *
    * @since API version 1
    */
   void moveToLastChild();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface for an object that acts as a proxy for the actual object in Bitwig Studio (for example a track, a
 * device etc).
 *
 * @since API version 2
 */
public interface ObjectProxy extends Subscribable
{
   /**
    * Returns a value object that indicates if the object being proxied exists, or if it has content.
    */
   BooleanValue exists();

   /**
    * Creates a {@link BooleanValue} that determines this proxy is considered equal to another proxy. For this
    * to be the case both proxies need to be proxying the same target object.
    *
    * @since API version 3
    */
   BooleanValue createEqualsValue(ObjectProxy other);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Represents a cursor that looks at a {@link RemoteControlsPage}.
 *
 * @since API version 2
 */
public interface CursorRemoteControlsPage extends Cursor, RemoteControlsPage
{
   /**
    * Value that reports the names of the devices parameter pages.
    */
   StringArrayValue pageNames();

   /**
    * Selects the next page.
    *
    * @param shouldCycle
    *           If true then when the end is reached and there is no next page it selects the first page
    *
    * @since API version 2
    */
   void selectNextPage(boolean shouldCycle);

   /**
    * Selects the previous page.
    *
    * @param shouldCycle
    *           If true then when the end is reached and there is no next page it selects the first page
    *
    * @since API version 2
    */
   void selectPreviousPage(boolean shouldCycle);

   /**
    * Selects the next page that matches the given expression.
    *
    * @param expression
    *           An expression that can match a page based on how it has been tagged. For now this can only be
    *           the name of a single tag that you would like to match.
    *
    * @param shouldCycle
    *           If true then when the end is reached and there is no next page it selects the first page
    *
    * @since API version 2
    */
   void selectNextPageMatching(String expression, boolean shouldCycle);

   /**
    * Selects the previous page that matches the given expression.
    *
    * @param expression
    *           An expression that can match a page based on how it has been tagged. For now this can only be
    *           the name of a single tag that you would like to match.
    *
    * @param shouldCycle
    *           If true then when the end is reached and there is no next page it selects the first page
    *
    * @since API version 2
    */
   void selectPreviousPageMatching(String expression, boolean shouldCycle);

   /**
    * Value that reports the currently selected parameter page index.
    *
    * @since API version 2
    */
   SettableIntegerValue selectedPageIndex();

   /**
    * Value that represents the number of pages.
    *
    * @since API version 7
    */
   IntegerValue pageCount();

   /**
    * Creates a new preset page.
    *
    * @since API version 16
    */
   @OscMethod
   void createPresetPage();

   /**
    * @see #createPresetPage()
    */
   HardwareActionBindable createPresetPageAction();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Instance of this class represent sources selectors in Bitwig Studio, which are shown as choosers in the
 * user interface and contain entries for either note inputs or audio inputs or both.
 *
 * The most prominent source selector in Bitwig Studio is the one shown in the track IO section, which can be
 * accessed via the API by calling {@link Track#getSourceSelector()}.
 *
 * @since API version 1
 */
public interface SourceSelector extends ObjectProxy
{
   /**
    * Returns an object that indicates if the source selector has note inputs enabled.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #hasNoteInputSelected()} instead.
    */
   @Deprecated
   BooleanValue getHasNoteInputSelected();

   /**
    * Returns an object that indicates if the source selector has note inputs enabled.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   BooleanValue hasNoteInputSelected();

   /**
    * Returns an object that indicates if the source selector has audio inputs enabled.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #hasAudioInputSelected()} instead.
    */
   @Deprecated
   BooleanValue getHasAudioInputSelected();

   /**
    * Returns an object that indicates if the source selector has audio inputs enabled.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   BooleanValue hasAudioInputSelected();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Something that can be bound to a hardware action (such as user pressing a button).
 *
 * @since API version 10
 */
public interface HardwareActionBindable extends HardwareBindable
{
   /**
    * Binds this target to the supplied {@link HardwareAction} so that when the hardware action occurs this
    * target is invoked.
    *
    * When the binding is no longer needed the {@link HardwareBinding#removeBinding()} method can be called on
    * it.
    */
   HardwareActionBinding addBinding(HardwareAction action);

   /**
    * Invokes the action.
    *
    * @since API version 1
    */
   void invoke();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * This interface is used to store custom controller settings into the Bitwig Studio preferences. The settings
 * are shown to the user in the controller preferences dialog of Bitwig Studio.
 *
 * @since API version 1
 */
public interface Preferences extends Settings
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * A scene bank provides access to a range of scenes in Bitwig Studio. Instances of scene bank are configured
 * with a fixed number of scenes and represent an excerpt of a larger list of scenes. Various methods are
 * provided for scrolling to different sections of the scene list. It basically acts like a window moving over
 * the list of underlying scenes.
 *
 * To receive an instance of scene bank call
 * {@link com.bitwig.extension.controller.api.ControllerHost#createSceneBank}.
 *
 * @see com.bitwig.extension.controller.api.ControllerHost#createSceneBank(int)
 * @since API version 1
 */
public interface SceneBank extends ClipLauncherSlotOrSceneBank<Scene>
{
   /**
    * Returns the scene at the given index within the bank.
    *
    * @param indexInBank
    *           the scene index within this bank, not the index within the list of all Bitwig Studio scenes.
    *           Must be in the range [0..sizeOfBank-1].
    * @return the requested scene object
    * @since API version 1
    */
   Scene getScene(int indexInBank);

   /**
    * Scrolls the scenes one page up.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageBackwards()} instead.
    */
   @Deprecated
   void scrollPageUp();

   /**
    * Scrolls the scenes one page down.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageForwards()} instead.
    */
   @Deprecated
   void scrollPageDown();

   /**
    * Scrolls the scenes one scene up.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollBackwards()} instead.
    */
   @Deprecated
   void scrollUp();

   /**
    * Scrolls the scenes one scene down.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollForwards()} instead.
    */
   @Deprecated
   void scrollDown();

   /**
    * Makes the scene with the given position visible in the track bank.
    *
    * @param position
    *           the position of the scene within the underlying full list of scenes
    * @since API version 1
    * @deprecated Use {@link #scrollIntoView(int)} instead.
    */
   @Deprecated
   void scrollTo(int position);

   /**
    * Registers an observer that reports the current scene scroll position.
    *
    * @param callback
    *           a callback function that takes a single integer parameter
    * @param valueWhenUnassigned
    *           the default value that gets reports when the track bank is not yet connected to a Bitwig
    *           Studio document
    * @since API version 1
    * @deprecated Use {@link #scrollPosition()} instead
    */
   @Deprecated
   void addScrollPositionObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);

   /**
    * Registers an observer that reports if the scene window can be scrolled further up.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollBackwards()} instead.
    */
   @Deprecated
   void addCanScrollUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the scene window can be scrolled further down.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollForwards()} instead.
    */
   @Deprecated
   void addCanScrollDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the underlying total scene count (not the number of scenes available
    * in the bank window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #itemCount()} instead.
    */
   @Deprecated
   void addSceneCountObserver(IntegerValueChangedCallback callback);

   /**
    * Launches the scene with the given bank index.
    *
    * @param indexInWindow
    *           the scene index within the bank, not the position of the scene withing the underlying full
    *           list of scenes.
    * @since API version 1
    */
   void launchScene(int indexInWindow);

   /**
    * Specifies if the Bitwig Studio clip launcher should indicate which scenes are part of the window. By
    * default indications are disabled.
    *
    * @param shouldIndicate
    *           `true` if visual indications should be enabled, `false` otherwise
    * @since API version 10
    */
   @OscMethod
   void setIndication(boolean shouldIndicate);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical hardware knob that inputs an absolute value.
 *
 * @see HardwareSurface#createAbsoluteHardwareKnob(String)
 *
 * @since API version 10
 */
public interface AbsoluteHardwareKnob extends AbsoluteHardwareControl
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Controls the project's master recording.
 *
 * @since API version 20
 */
public interface MasterRecorder
{
   /**
    * Value that indicates if the master recording is active.
    *
    * @since API version 20
    */
   @OscNode
   BooleanValue isActive();

   /**
    * Starts the master recording.
    *
    * @since API version 20
    */
   @OscMethod
   void start();

   /**
    * Stops the master recording.
    *
    * @since API version 20
    */
   @OscMethod
   void stop();

   /**
    * Toggles the master recording.
    *
    * @since API version 20
    */
   @OscMethod
   void toggle();

   /**
    * Get the master recording duration in milliseconds.
    * Only relevant when master recording is active.
    *
    * @since API version 20
    */
   @OscNode
   IntegerValue duration();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from an {@link AbsoluteHardwareControl} to some target.
 *
 * @since API version 10
 *  */
public interface AbsoluteHardwareControlBinding extends HardwareBinding, HardwareBindingWithRange
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Something that can be bound to an {@link RelativeHardwareControl} and can respond to the user input (such
 * as user turning an encoder left or right) in a meaningful way.
 *
 * @since API version 10
 */
public interface RelativeHardwarControlBindable extends HardwareBindable
{
   /**
    * Binds this target to the supplied hardware control so that when the user moves the hardware control this
    * target will respond in a meaningful way.
    *
    * When the binding is no longer needed the {@link HardwareBinding#removeBinding()} method can be called on
    * it.
    */
   default RelativeHardwareControlBinding addBinding(RelativeHardwareControl hardwareControl)
   {
      return addBindingWithSensitivity(hardwareControl, 1);
   }

   /**
    * Binds this target to the supplied hardware control so that when the user moves the hardware control this
    * target will respond in a meaningful way.
    *
    * When the binding is no longer needed the {@link HardwareBinding#removeBinding()} method can be called on
    * it.
    */
   RelativeHardwareControlBinding addBindingWithSensitivity(RelativeHardwareControl hardwareControl, double sensitivity);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;

/**
 * Instances of this interface represent a contextual browser in Bitwig Studio.
 *
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface Browser extends ObjectProxy
{
   /**
    * Registers an observer that reports if a browsing session was started.
    *
    * @param callback
    *           a callback function that receivers a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #exists()} instead.
    */
   @Deprecated
   void addIsBrowsingObserver(BooleanValueChangedCallback callback);

   /**
    * Starts a new browser session.
    *
    * @since API version 1
    */
   void startBrowsing();

   /**
    * Cancels the current browser session.
    *
    * @since API version 1
    */
   void cancelBrowsing();

   /**
    * Finished the browser session by loading the selected item.
    *
    * @since API version 1
    */
   void commitSelectedResult();

   /**
    * Activates the given search session. Please note that only one search session can be active at a time.
    *
    * @param session
    *           the session that should be activated.
    * @since API version 1
    */
   void activateSession(BrowsingSession session);

   /**
    * Return an object allows to observe and control if the browser window should be small or full-sized.
    *
    * @return a boolean value object
    * @since API version 1
    */
   SettableBooleanValue isWindowMinimized();

   /**
    * Return an object allows to observe and control if the selected result should be auditioned.
    *
    * @return a boolean value object
    * @since API version 1
    */
   SettableBooleanValue shouldAudition();

   /**
    * Returns an object that provided bank-wise navigation of the available search sessions. Each search
    * session is dedicated to a certain material type, as shown in the tabs of Bitwig Studio's contextual
    * browser.
    *
    * @param size
    *           the size of the windows used to navigate the available browsing sessions.
    * @return the requested file column bank object
    * @since API version 1
    */
   BrowsingSessionBank createSessionBank(int size);

   /**
    * Returns an object that represents the selected tab as shown in Bitwig Studio's contextual browser
    * window.
    *
    * @return the requested browsing session cursor
    * @since API version 1
    */
   CursorBrowsingSession createCursorSession();

   /**
    * Returns an object that provides access to the contents of the device tab as shown in Bitwig Studio's
    * contextual browser window.
    *
    * @return the requested device browsing session instance
    * @since API version 1
    */
   DeviceBrowsingSession getDeviceSession();

   /**
    * Returns an object that provides access to the contents of the preset tab as shown in Bitwig Studio's
    * contextual browser window.
    *
    * @return the requested preset browsing session instance
    * @since API version 1
    */
   PresetBrowsingSession getPresetSession();

   /**
    * Returns an object that provides access to the contents of the samples tab as shown in Bitwig Studio's
    * contextual browser window.
    *
    * @return the requested sample browsing session instance
    * @since API version 1
    */
   SampleBrowsingSession getSampleSession();

   /**
    * Returns an object that provides access to the contents of the multi-samples tab as shown in Bitwig
    * Studio's contextual browser window.
    *
    * @return the requested multi-sample browsing session instance
    * @since API version 1
    */
   MultiSampleBrowsingSession getMultiSampleSession();

   /**
    * Returns an object that provides access to the contents of the clips tab as shown in Bitwig Studio's
    * contextual browser window.
    *
    * @return the requested clip browsing session instance
    * @since API version 1
    */
   ClipBrowsingSession getClipSession();

   /**
    * Returns an object that provides access to the contents of the music tab as shown in Bitwig Studio's
    * contextual browser window.
    *
    * @return the requested music browsing session instance
    * @since API version 1
    */
   MusicBrowsingSession getMusicSession();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing clips, including access to all filter columns and the
 * result column as shown in the 'Clips' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface ClipBrowsingSession extends BrowsingSession
{
   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a hardware control that can input a relative or absolute value (for example, a slider, knob,
 * relative encoder...).
 *
 * @since API version 10
 */
public interface ContinuousHardwareControl<HardwareBindingType extends HardwareBinding>
   extends HardwareControl, HardwareBindingSource<HardwareBindingType>
{
   /**
    * An optional button that can be associated with this control when this control can also act as a button
    * (e.g by pressing down on it).
    */
   HardwareButton hardwareButton();

   /**
    * Sets an optional button that can be associated with this control when this control can also act as a
    * button (e.g by pressing down on it).
    */
   void setHardwareButton(HardwareButton button);

   /**
    * The name of the target that this hardware control has been bound to.
    *
    * @since API version 11
    */
   StringValue targetName();

   /** The value of the target that this hardware control has been bound to (0..1). */
   DoubleValue targetValue();

   /**
    * Value that represents a formatted text representation of the target value whenever the value changes.
    *
    * @since API version 11
    */
   StringValue targetDisplayedValue();


   /**
    * The value of the target that this hardware control has been bound to (0..1).
    *
    * @since API version 11
    */
   DoubleValue modulatedTargetValue();

   /**
    * Value that represents a formatted text representation of the target's modulated value whenever the value
    * changes.
    *
    * @since API version 11
    */
   StringValue modulatedTargetDisplayedValue();

   /**
    * Can be called from the {@link #targetValue()} changed callback to check if this control is responsible
    * for changing the target value or not.
    */
   BooleanValue isUpdatingTargetValue();

   /** Value that indicates if this hardware control has a target value that it changes or not. */
   BooleanValue hasTargetValue();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * A special kind of selection cursor used for devices.
 *
 * @since API version 1
 */
public interface CursorDevice extends Cursor, Device
{
   /**
    * Returns the channel that this cursor device was created on. Currently this will always be a track or
    * cursor track instance.
    *
    * @return the track or cursor track object that was used for creation of this cursor device.
    * @since API version 1
    * @deprecated Use {@link #channel()} instead.
    */
   @Deprecated
   Channel getChannel();

   /**
    * Returns the channel that this cursor device was created on. Currently this will always be a track or
    * cursor track instance.
    *
    * @return the track or cursor track object that was used for creation of this cursor device.
    * @since API version 5
    */
   @OscNode
   Channel channel();

   /**
    * Selects the parent device if there is any.
    *
    * @since API version 1
    */
   @OscMethod
   void selectParent();

   /**
    * Moves this cursor to the given device.
    *
    * @param device
    *           the device that this cursor should point to
    * @since API version 1
    */
   void selectDevice(Device device);

   /**
    * Selects the first device in the given channel.
    *
    * @param channel
    *           the channel in which the device should be selected
    * @since API version 1
    */
   void selectFirstInChannel(Channel channel);

   /**
    * Selects the last device in the given channel.
    *
    * @param channel
    *           the channel in which the device should be selected
    * @since API version 1
    */
   void selectLastInChannel(Channel channel);

   /**
    * Selects the first device in the nested FX slot with the given name.
    *
    * @param chain
    *           the name of the FX slot in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectFirstInSlot(String chain);

   /**
    * Selects the last device in the nested FX slot with the given name.
    *
    * @param chain
    *           the name of the FX slot in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectLastInSlot(String chain);

   /**
    * Selects the first device in the drum pad associated with the given key.
    *
    * @param key
    *           the key associated with the drum pad in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectFirstInKeyPad(int key);

   /**
    * Selects the last device in the drum pad associated with the given key.
    *
    * @param key
    *           the key associated with the drum pad in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectLastInKeyPad(int key);

   /**
    * Selects the first device in the nested layer with the given index.
    *
    * @param index
    *           the index of the nested layer in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectFirstInLayer(int index);

   /**
    * Selects the last device in the nested layer with the given index.
    *
    * @param index
    *           the index of the nested layer in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectLastInLayer(int index);

   /**
    * Selects the first device in the nested layer with the given name.
    *
    * @param name
    *           the name of the nested layer in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectFirstInLayer(String name);

   /**
    * Selects the last device in the nested layer with the given name.
    *
    * @param name
    *           the name of the nested layer in which the device should be selected
    * @since API version 1
    */
   @OscMethod
   void selectLastInLayer(String name);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface represent entries in a browser filter column.
 *
 * @since API version 1
 */
public interface BrowserItem extends ObjectProxy
{
   /**
    * Registers an observer that reports if the item exists.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #exists()} instead.
    */
   @Deprecated
   void addExistsObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the name of the browser item.
    *
    * @since API version 2
    */
   StringValue name();

   /**
    * Registers an observer that reports the string value of the browser item.
    *
    * @param maxCharacters
    * @param textWhenUnassigned
    * @param callback
    *           a callback function that receives a single string argument
    * @since API version 1
    * @deprecated Use {@link #name()} instead.
    */
   @Deprecated
   void addValueObserver(int maxCharacters, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Returns an object that provides access to the selected state of the browser item.
    *
    * @return an boolean value object
    * @since API version 1
    */
   SettableBooleanValue isSelected();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a formatter for a beat time that can convert a beat time to a string for display to the user.
 *
 * @since API version 2
 */
public interface BeatTimeFormatter
{
   /**
    * Formats the supplied beat time as a string in the supplied time signature.
    *
    * @param beatTime
    *           The beat time to be formatted
    * @param isAbsolute
    *           If true the beat time represents an absolute time (such as a time on the arranger) otherwise
    *           it represents a beat time duration (such as the length of a clip).
    *
    * @since API version 2
    */
   String formatBeatTime(
      double beatTime,
      boolean isAbsolute,
      int timeSignatureNumerator,
      int timeSignatureDenominator,
      int timeSignatureTicks);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.IndexedStringValueChangedCallback;

/**
 * An abstract interface that represents the clip launcher scenes or slots of a single track.
 *
 * @since API version 1
 */
public interface ClipLauncherSlotOrSceneBank<ItemType extends ClipLauncherSlotOrScene> extends Bank<ItemType>
{
   /**
    * Launches the scene/slot with the given index.
    *
    * @param slot
    *           the index of the slot that should be launched
    * @since API version 1
    */
   void launch(int slot);

   /**
    * Launches the scene/slot with the given index.
    *
    * @param slot
    *           the index of the slot that should be launched
    * @since API version 18
    */
   void launchAlt(int slot);

   /**
    * Stops clip launcher playback for the associated track.
    *
    * @since API version 1
    */
   void stop();

   /**
    * Stops clip launcher playback for the associated track.
    *
    * @since API version 18
    */
   void stopAlt();

   /**
    * Action to call {@link #stop()}.
    * @since API version 10
    */
   HardwareActionBindable stopAction();

   /**
    * Action to call {@link #stopAlt()}.
    * @since API version 18
    */
   HardwareActionBindable stopAltAction();

   /**
    * Performs a return-to-arrangement operation on the related track, which caused playback to be taken over
    * by the arrangement sequencer.
    *
    * @since API version 1
    */
   void returnToArrangement();

   /**
    * Registers an observer that reports the names of the scenes and slots. The slot names reflect the names
    * of containing clips.
    *
    * @param callback
    *           a callback function receiving two parameters: 1. the slot index (integer) within the
    *           configured window, and 2. the name of the scene/slot (string)
    * @since API version 1
    */
   void addNameObserver(IndexedStringValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.MemoryBlock;

/**
 * A pipe that can be used to write data.
 *
 * @since API version 7
 * */
public interface OutputPipe extends Pipe
{
   /**
    * Requests to write some data to this pipe in an asynchronous way (the caller is not blocked). Once some
    * data has been written the callback will be notified on the controller's thread.
    *
    * @param data
    *           A {@link MemoryBlock} containing the data to be written.
    * @param callback
    *           A callback that is notified on the controller's thread when the write has completed.
    * @param timeoutInMs
    *           A timeout in milliseconds that will result in an error and termination of the controller if
    *           the write does not happen in this time. For infinite timeout use 0.
    */
   void writeAsync(MemoryBlock data, AsyncTransferCompledCallback callback, int timeoutInMs);

   int write(MemoryBlock data, int timeoutInMs);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.ClipLauncherSlotBankPlaybackStateChangedCallback;
import com.bitwig.extension.callback.IndexedBooleanValueChangedCallback;
import com.bitwig.extension.callback.IndexedColorValueChangedCallback;

/**
 * Instances of this interface represent a scrollable fixed-size window that is connected to a section of the
 * clip launcher slots for a specific track.
 *
 * @since API version 1
 */
public interface ClipLauncherSlotBank extends ClipLauncherSlotOrSceneBank<ClipLauncherSlot>
{
   /**
    * Selects the slot with the given index.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    */
   @OscMethod
   void select(int slot);

   /**
    * Starts recording into the slot with the given index.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    */
   @OscMethod
   void record(int slot);

   /**
    * Makes the clip content of the slot with the given index visible in the note or audio editor.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    */
   @OscMethod
   void showInEditor(int slot);

   /**
    * Creates an new clip in the slot with the given index.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    */
   @OscMethod
   void createEmptyClip(int slot, int lengthInBeats);

   /**
    * Deletes the clip in the slot with the given index.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    * @deprecated Use {@link #getItemAt(int)}.deleteObject() instead.
    */
   @Deprecated
   void deleteClip(int slot);

   /**
    * Duplicates the clip in the slot with the given index.
    *
    * @param slot
    *           the index of the slot within the slot window.
    * @since API version 1
    */
   @OscMethod
   void duplicateClip(int slot);

   /**
    * Registers an observer that reports selection changes for the slots inside the window.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index is selected (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsSelectedObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports which slots contain clips.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index contains a clip (`true`) or not
    *           (`false`)
    * @since API version 1
    */
   void addHasContentObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the playback state of clips / slots. The reported states include
    * `stopped`, `playing`, `recording`, but also `queued for stop`, `queued for playback`, `queued for
    * recording`.
    *
    * @param callback
    *           a callback function that receives three parameters: 1. the slot index (integer), 2. the queued
    *           or playback state: `0` when stopped, `1` when playing, or `2` when recording, and 3. a boolean
    *           parameter indicating if the second argument is referring to the queued state (`true`) or the
    *           actual playback state (`false`)
    * @since API version 1
    */
   void addPlaybackStateObserver(ClipLauncherSlotBankPlaybackStateChangedCallback callback);

   /**
    * Registers an observer that reports which slots have clips that are currently playing.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index has a clip that is currently playing
    *           (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsPlayingObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports which slots have clips that are currently recording.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index has a clip that is currently recording
    *           (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsRecordingObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Add an observer if clip playback is queued on the slot.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index has a clip that is currently queued for
    *           playback (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsPlaybackQueuedObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Add an observer if clip recording is queued on the slot.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index has a clip that is currently queued for
    *           recording (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsRecordingQueuedObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Add an observer if clip playback is queued to stop on the slot.
    *
    * @param callback
    *           a callback function that receives two parameters: 1. the slot index (integer), and 2. a
    *           boolean parameter indicating if the slot at that index has a clip that is currently queued for
    *           stop (`true`) or not (`false`)
    * @since API version 1
    */
   void addIsStopQueuedObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * @deprecated Use {@link #addIsPlaybackQueuedObserver} instead.
    * @since API version 1
    */
   @Deprecated
   void addIsQueuedObserver(IndexedBooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the colors of clip in the current slot window.
    *
    * @param callback
    *           a callback function that receives four parameters: 1. the slot index (integer), 2. the red
    *           coordinate of the RBG color value, 3. the green coordinate of the RBG color value, and 4. the
    *           blue coordinate of the RBG color value
    * @since API version 1
    */
   void addColorObserver(IndexedColorValueChangedCallback callback);

   /**
    * Specifies if the Bitwig Studio clip launcher should indicate which slots are part of the window. By
    * default indications are disabled.
    *
    * @param shouldIndicate
    *           `true` if visual indications should be enabled, `false` otherwise
    * @since API version 1
    * @deprecated
    */
   @Deprecated
   @OscMethod
   void setIndication(boolean shouldIndicate);

   /**
    * Returns an object that can be used to observe and toggle if the slots on a connected track group show
    * either scenes launch buttons (for launching the content of the track group) or the clips of the group
    * master track.
    *
    * @return a boolean value object.
    */
   @OscNode
   SettableBooleanValue isMasterTrackContentShownOnTrackGroups();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

public interface SettableDoubleValue extends DoubleValue
{
   /**
    * Sets the internal value.
    *
    * @param value
    *           the new integer value.
    * @since API version 1
    */
   @OscMethod
   void set(double value);

   /**
    * Increases/decrease the internal value by the given amount.
    *
    * @param amount
    *           the integer amount to increase
    * @since API version 1
    */
   @OscMethod
   void inc(double amount);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Drum pads are features of special Bitwig Studio devices (currently only the Bitwig Drum Machine
 * instrument), and are also shown as sub-channels in the mixer panel.
 *
 * Instances of drum pad bank are configured with a fixed number of pads/channels and represent an excerpt of
 * underlying complete list of channels. Various methods are provided for scrolling to different sections of
 * the underlying list. It basically acts like a one-dimensional window moving over the drum pad channels.
 *
 * To receive an instance of drum pad bank call {@link Device#createDrumPadBank(int numChannels)}.
 *
 * @see Device#createDrumPadBank(int)
 * @since API version 1
 */
public interface DrumPadBank extends ChannelBank<DrumPad>
{
   /**
    * Specifies if the Drum Machine should visualize which pads are part of the window. By default indications
    * are enabled.
    *
    * @param shouldIndicate
    *           `true` if visual indications should be enabled, `false` otherwise
    * @since API version 1
    */
   @OscMethod
   void setIndication(boolean shouldIndicate);

   /**
    * Clears mute on all drum pads.
    *
    * @since API version 10
    */
   @OscMethod
   void clearMutedPads();

   /**
    * Clears solo on all drum pads.
    *
    * @since API version 10
    */
   @OscMethod
   void clearSoloedPads();

   /**
    * True if there is one or many muted pads.
    * @since API version 10
    */
   @OscNode
   BooleanValue hasMutedPads();

   /**
    * True if there is one or many soloed pads.
    * @since API version 10
    */
   @OscNode
   BooleanValue hasSoloedPads();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * An interface that provides methods for accessing the most common global application commands.
 *
 * In addition, functions are provided for accessing any application action in a generic and categorized way,
 * pretty much as displayed in the Bitwig Studio commander dialog (see {@link #getActions()},
 * {@link #getAction(String)}, {@link #getActionCategories()}), {@link #getActionCategory(String)}).
 *
 * To receive an instance of the application interface call {@link ControllerHost#createApplication()}.
 */
public interface Application
{
   /**
    * This identifier can be used as parameter for {@link #setPanelLayout(String)} in order to switch to the
    * `ARRANGE` panel layout that is available in various display profiles.
    */
   String PANEL_LAYOUT_ARRANGE = "ARRANGE";

   /**
    * This identifier can be used as parameter for {@link #setPanelLayout(String)} in order to switch to the
    * `EDIT` panel layout that is available in various display profiles.
    */
   String PANEL_LAYOUT_MIX = "MIX";

   /**
    * This identifier can be used as parameter for {@link #setPanelLayout(String)} in order to switch to the
    * `MIX` panel layout that is available in various display profiles.
    */
   String PANEL_LAYOUT_EDIT = "EDIT";

   /**
    * Creates a new audio track at the given position.
    *
    * @param position
    *           the index within the list of main tracks where the new track should be inserted, or `-1` in
    *           case the track should be inserted at the end of the list. Values outside the valid range will
    *           get pinned to the valid range, so the actual position might be different from the provided
    *           parameter value.
    * @since API version 1
    */
   void createAudioTrack(int position);

   /**
    * Creates a new instrument track at the given position.
    *
    * @param position
    *           the index within the list of main tracks where the new track should be inserted, or `-1` in
    *           case the track should be inserted at the end of the list. Values outside the valid range will
    *           get pinned to the valid range, so the actual position might be different from the provided
    *           parameter value.
    * @since API version 1
    */
   void createInstrumentTrack(int position);

   /**
    * Creates a new effect track at the given position.
    *
    * @param position
    *           the index within the list of effect tracks where the new track should be inserted, or `-1` in
    *           case the track should be inserted at the end of the list. Values outside the valid range will
    *           get pinned to the valid range, so the actual position might be different from the provided
    *           parameter value.
    * @since API version 1
    */
   void createEffectTrack(int position);

   /**
    * Returns a list of actions that the application supports. Actions are commands in Bitwig Studio that are
    * typically accessible through menus or keyboard shortcuts.
    *
    * Please note that many of the commands encapsulated by the reported actions are also accessible through
    * other (probably more convenient) interfaces methods of the API. In contrast to that, this method
    * provides a more generic way to find available application functionality.
    *
    * @return the list of actions
    * @since API version 1
    */
   Action[] getActions();

   /**
    * Returns the action for the given action identifier. For a list of available actions, see
    * {@link #getActions()}.
    *
    * @param id
    *           the action identifier string, must not be `null`
    * @return the action associated with the given id, or null in case there is no action with the given
    *         identifier.
    * @since API version 1
    */
   Action getAction(String id);

   /**
    * Returns a list of action categories that is used by Bitwig Studio to group actions into categories.
    *
    * @return the list of action categories
    * @since API version 1
    */
   ActionCategory[] getActionCategories();

   /**
    * Returns the action category associated with the given identifier. For a list of available action
    * categories, see {@link #getActionCategories()}.
    *
    * @param id
    *           the category identifier string, must not be `null`
    * @return the action associated with the given id, or null in case there is no category with the given
    *         identifier
    * @since API version 1
    */
   ActionCategory getActionCategory(String id);

   /**
    * Activates the audio engine in Bitwig Studio.
    *
    * @since API version 1
    */
   void activateEngine();

   /**
    * Deactivates the audio engine in Bitwig Studio.
    *
    * @since API version 1
    */
   void deactivateEngine();

   /**
    * Value that reports whether an audio engine is active or not.
    *
    * @since API version 2
    */
   BooleanValue hasActiveEngine();

   /**
    * Registers an observer that gets called when the audio engine becomes active or inactive.
    *
    * @param callable
    *           a callback function that accepts a single boolean parameter. The callback parameter indicates
    *           whether the audio engine became active (true) or inactive (false).
    * @since API version 1
    * @deprecated Use {@link #hasActiveEngine()} instead.
    */
   @Deprecated
   void addHasActiveEngineObserver(BooleanValueChangedCallback callable);

   /**
    * Value that reports the name of the current project.
    *
    * @since API version 2
    */
   StringValue projectName();

   /**
    * Registers an observer that reports the name of the current project.
    *
    * @param callback
    *           a callback function that accepts a single string parameter.
    * @param maxChars
    *           the maximum length of the reported name. Longer names will get truncated.
    * @since API version 1
    * @deprecated Use {@link #projectName()} instead.
    */
   @Deprecated
   void addProjectNameObserver(StringValueChangedCallback callback, int maxChars);

   /**
    * Switches to the next project tab in Bitwig Studio.
    *
    * @since API version 1
    */
   void nextProject();

   /**
    * Switches to the previous project tab in Bitwig Studio.
    *
    * @since API version 1
    */
   void previousProject();

   /**
    * Set BitwigStudio to navigate into the group.
    *
    * @since API version 2
    */
   void navigateIntoTrackGroup(Track track);

   /**
    * Set BitwigStudio to navigate into the parent group.
    *
    * @since API version 2
    */
   void navigateToParentTrackGroup();

   /**
    * Sends an undo command to Bitwig Studio.
    *
    * @since API version 1
    */
   void undo();

   HardwareActionBindable undoAction();

   /**
    * Value that reports if there is an action to undo.
    *
    * @since API version 15
    */
   @OscNode
   BooleanValue canUndo();

   /**
    * Sends a redo command to Bitwig Studio.
    *
    * @since API version 1
    */
   void redo();

   HardwareActionBindable redoAction();

   /**
    * Value that reports if there is an action to redo.
    *
    * @since API version 15
    */
   @OscNode
   BooleanValue canRedo();

   /**
    * Switches the Bitwig Studio user interface to the panel layout with the given name. The list of available
    * panel layouts depends on the active display profile.
    *
    * @param panelLayout
    *           the name of the new panel layout
    * @since API version 1
    */
   void setPanelLayout(String panelLayout);

   /**
    * Switches to the next panel layout of the active display profile in Bitwig Studio.
    *
    * @since API version 1
    */
   void nextPanelLayout();

   /**
    * Switches to the previous panel layout of the active display profile in Bitwig Studio.
    *
    * @since API version 1
    */
   void previousPanelLayout();

   /**
    * Value that reports the name of the active panel layout.
    *
    * @since API version 2
    */
   StringValue panelLayout();

   /**
    * Registers an observer that reports the name of the active panel layout.
    *
    * @param callable
    *           a callback function object that accepts a single string parameter
    * @param maxChars
    *           the maximum length of the panel layout name
    * @since API version 1
    * @deprecated Use {@link #panelLayout()} instead.
    */
   @Deprecated
   void addPanelLayoutObserver(StringValueChangedCallback callable, int maxChars);

   /**
    * Value that reports the name of the active display profile.
    *
    * @since API version 2
    */
   StringValue displayProfile();

   /**
    * Registers an observer that reports the name of the active display profile.
    *
    * @param callable
    *           a callback function object that accepts a single string parameter
    * @param maxChars
    *           the maximum length of the display profile name
    * @since API version 1
    * @deprecated Use {@link #displayProfile()} instead.
    */
   @Deprecated
   void addDisplayProfileObserver(StringValueChangedCallback callable, int maxChars);

   /**
    * Toggles the visibility of the inspector panel.
    *
    * @since API version 1
    */
   void toggleInspector();

   /**
    * Toggles the visibility of the device chain panel.
    *
    * @since API version 1
    */
   void toggleDevices();

   /**
    * Toggles the visibility of the mixer panel.
    *
    * @since API version 1
    */
   void toggleMixer();

   /**
    * Toggles the visibility of the note editor panel.
    *
    * @since API version 1
    */
   void toggleNoteEditor();

   /**
    * Toggles the visibility of the automation editor panel.
    *
    * @since API version 1
    */
   void toggleAutomationEditor();

   /**
    * Toggles the visibility of the browser panel.
    *
    * @since API version 1
    */
   void toggleBrowserVisibility();

   /**
    * Shows the previous detail panel (note editor, device, automation).
    *
    * @since API version 1
    */
   void previousSubPanel();

   /**
    * Shows the next detail panel (note editor, device, automation).
    *
    * @since API version 1
    */
   void nextSubPanel();

   /**
    * Equivalent to an Arrow-Left key stroke on the computer keyboard. The concrete functionality depends on
    * the current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void arrowKeyLeft();

   /**
    * Equivalent to an Arrow-Right key stroke on the computer keyboard. The concrete functionality depends on
    * the current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void arrowKeyRight();

   /**
    * Equivalent to an Arrow-Up key stroke on the computer keyboard. The concrete functionality depends on the
    * current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void arrowKeyUp();

   /**
    * Equivalent to an Arrow-Down key stroke on the computer keyboard. The concrete functionality depends on
    * the current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void arrowKeyDown();

   /**
    * Equivalent to an Enter key stroke on the computer keyboard. The concrete functionality depends on the
    * current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void enter();

   /**
    * Equivalent to an Escape key stroke on the computer keyboard. The concrete functionality depends on the
    * current keyboard focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void escape();

   /**
    * Selects all items according the current selection focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void selectAll();
   HardwareActionBindable selectAllAction();

   /**
    * Deselects any items according the current selection focus in Bitwig Studio.
    *
    * @since API version 1
    */
   void selectNone();
   HardwareActionBindable selectNoneAction();

   /**
    * Selects the previous item in the current selection.
    *
    * @since API version 10
    */
   void selectPrevious();
   HardwareActionBindable selectPreviousAction();

   /**
    * Selects the next item in the current selection.
    *
    * @since API version 10
    */
   void selectNext();
   HardwareActionBindable selectNextAction();

   /**
    * Selects the first item in the current selection.
    *
    * @since API version 10
    */
   void selectFirst();
   HardwareActionBindable selectFirstAction();

   /**
    * Selects the last item in the current selection.
    *
    * @since API version 10
    */
   void selectLast();
   HardwareActionBindable selectLastAction();

   /**
    * Cuts the selected items in Bitwig Studio if applicable.
    *
    * @since API version 1
    */
   void cut();
   HardwareActionBindable cutAction();

   /**
    * Copies the selected items in Bitwig Studio to the clipboard if applicable.
    *
    * @since API version 1
    */
   void copy();
   HardwareActionBindable copyAction();

   /**
    * Pastes the clipboard contents into the current selection focus in Bitwig Studio if applicable.
    *
    * @since API version 1
    */
   void paste();
   HardwareActionBindable pasteAction();

   /**
    * Duplicates the active selection in Bitwig Studio if applicable.
    *
    * @since API version 1
    */
   void duplicate();

   /**
    * @since API version 10
    */
   HardwareActionBindable duplicateAction();

   /**
    * Deletes the selected items in Bitwig Studio if applicable. Originally this function was called `delete`
    * (Bitwig Studio 1.0). But as `delete` is reserved in JavaScript this function got renamed to `remove` in
    * Bitwig Studio 1.0.9.
    *
    * @since API version 1
    */
   void remove();
   HardwareActionBindable removeAction();

   /**
    * Opens a text input field in Bitwig Studio for renaming the selected item.
    *
    * @since API version 1
    */
   void rename();

   /**
    * Zooms in one step into the currently focused editor of the Bitwig Studio user interface.
    *
    * @since API version 1
    */
   void zoomIn();

   HardwareActionBindable zoomInAction();

   /**
    * Zooms out one step in the currently focused editor of the Bitwig Studio user interface.
    *
    * @since API version 1
    */
   void zoomOut();

   HardwareActionBindable zoomOutAction();


   /**
    * Same as zoomIn/zoomOut, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomLevel();

   /**
    * Adjusts the zoom level of the currently focused editor so that it matches the active selection.
    *
    * @since API version 1
    */
   void zoomToSelection();

   HardwareActionBindable zoomToSelectionAction();

   /**
    * Toggles between zoomToSelection and zoomToFit.
    *
    * @since API version 10
    */
   void zoomToSelectionOrAll();

   HardwareActionBindable zoomToSelectionOrAllAction();

   /**
    * Toggles between zoomToSelection and the last et zoom level.
    *
    * @since API version 10
    */
   void zoomToSelectionOrPrevious();

   HardwareActionBindable zoomToSelectionOrPreviousAction();

   /**
    * Adjusts the zoom level of the currently focused editor so that all content becomes visible.
    *
    * @since API version 1
    */
   void zoomToFit();

   HardwareActionBindable zoomToFitAction();

   /**
    * Moves the panel focus to the panel on the left of the currently focused panel.
    *
    * @since API version 1
    */
   void focusPanelToLeft();

   /**
    * Moves the panel focus to the panel right to the currently focused panel.
    *
    * @since API version 1
    */
   void focusPanelToRight();

   /**
    * Moves the panel focus to the panel above the currently focused panel.
    *
    * @since API version 1
    */
   void focusPanelAbove();

   /**
    * Moves the panel focus to the panel below the currently focused panel.
    *
    * @since API version 1
    */
   void focusPanelBelow();

   /**
    * Toggles between full screen and windowed user interface.
    *
    * @since API version 1
    */
   void toggleFullScreen();

   /**
    * @deprecated Use {@link #setPanelLayout(java.lang.String)} instead.
    * @since API version 1
    */
   @Deprecated
   void setPerspective(String perspective);

   /**
    * @deprecated Use {@link #nextPanelLayout()} instead.
    * @since API version 1
    */
   @Deprecated
   void nextPerspective();

   /**
    * @deprecated Use {@link #previousPanelLayout()} instead.
    * @since API version 1
    */
   @Deprecated
   void previousPerspective();

   /**
    * @deprecated Use {@link #addPanelLayoutObserver(org.mozilla.javascript.Callable, int)} instead.
    * @since API version 1
    */
   @Deprecated
   void addSelectedModeObserver(StringValueChangedCallback callable, int maxChars, String fallbackText);

   /**
    * Returns the record quantization grid setting from the preferences.
    * Possible values are "OFF", "1/32", "1/16", "1/8", "1/4".
    *
    * @since API version 10
    */
   @OscNode
   SettableEnumValue recordQuantizationGrid();

   /**
    * Returns a settable value to choose if the record quantization should quantize note length.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue recordQuantizeNoteLength();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.controller.UsbEndpointMatcher;

/**
 * Defines a pipe for talking to an endpoint on a USB device.
 *
 * @since API version 7
 */
public interface UsbPipe extends Pipe
{
   /**
    * The device this endpoint is on.
    *
    * @since API version 7
    */
   UsbDevice device();

   /**
    * The {@link UsbEndpointMatcher} that was provided by the controller for identifying the endpoint to use
    * for communication.
    */
   UsbEndpointMatcher endpointMatcher();

   /**
    * The endpoint address on the device that this endpoint is for.
    *
    * @since API version 7
    */
   byte endpointAddress();

   /** {@link UsbTransferDirection} for this pipe. */
   UsbTransferDirection direction();

   /** The {@link UsbTransferType} type that this pipe uses for communicating with the USB device. */
   UsbTransferType transferType();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a means of recognizing when an absolute value is input by the user (for example, when moving a
 * slider or turning a knob based on some MIDI message). This matcher can then be set on an
 * {@link AbsoluteHardwareControl} using
 * {@link AbsoluteHardwareControl#setAdjustValueMatcher(AbsoluteHardwareValueMatcher)}.
 *
 * @see MidiIn#createAbsoluteValueMatcher(String, String, int)
 * @see MidiIn#createAbsoluteCCValueMatcher(int, int)
 * @see MidiIn#createAbsolutePitchBendValueMatcher(int)
 *
 * @since API version 10
 *
 */
public interface AbsoluteHardwareValueMatcher extends ContinuousHardwareValueMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to navigate the filter columns of a Bitwig Studio browsing session.
 *
 * @since API version 1
 */
public interface CursorBrowserFilterColumn extends BrowserFilterColumn, Cursor
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IndexedStringValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface represent tracks in Bitwig Studio.
 *
 * @since API version 1
 */
public interface Track extends Channel
{
   /**
    * Value that reports the position of the track within the list of Bitwig Studio tracks.
    *
    * @since API version 2
    */
   @OscNode
   IntegerValue position();

   /**
    * Registers an observer that reports the position of the track within the list of Bitwig Studio tracks.
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #position()} instead.
    */
   @Deprecated
   void addPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Returns an object that can be used to access the clip launcher slots of the track.
    *
    * @return an object that represents the clip launcher slots of the track
    * @since API version 1
    * @deprecated Use {@link #clipLauncherSlotBank()} instead.
    */
   @Deprecated
   ClipLauncherSlotBank getClipLauncherSlots();

   /**
    * Returns an object that can be used to access the clip launcher slots of the track.
    *
    * @return an object that represents the clip launcher slots of the track
    * @since API version 2
    */
   ClipLauncherSlotBank clipLauncherSlotBank();

   /**
    * @deprecated Use {@link #getClipLauncherSlots()} instead.
    * @since API version 1
    */
   @Deprecated
   ClipLauncherSlotBank getClipLauncher();

   /**
    * Registers an observer that reports if the clip launcher slots are queued for stop.
    *
    * @param callback
    *           a callback function that receives a single boolean argument.
    * @since API version 1
    * @deprecated Use {@link #isQueuedForStop()} instead.
    */
   @Deprecated
   void addIsQueuedForStopObserver(BooleanValueChangedCallback callback);

   /**
    * Returns an object that provides access to the arm state of the track.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #arm()} instead.
    */
   @Deprecated
   SettableBooleanValue getArm();

   /**
    * Returns an object that provides access to the arm state of the track.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   SettableBooleanValue arm();

   /**
    * Returns an object that provides access to the monitoring state of the track.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #monitor()} instead.
    */
   @Deprecated
   SettableBooleanValue getMonitor();

   /**
    * Returns an object that provides access to the monitoring state of the track.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   @Deprecated
   SettableBooleanValue monitor();

   /**
    * Returns an object that provides a readout of the monitoring state of the track.
    *
    * @return a read-only boolean value object
    * @since API version 14
    */
   @OscNode
   BooleanValue isMonitoring();

   /**
    * Returns an object that provides access to the auto-monitoring state of the track.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #autoMonitor()} instead.
    */
   @Deprecated
   SettableBooleanValue getAutoMonitor();

   /**
    * Returns an object that provides access to the auto-monitoring state of the track.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   @Deprecated
   SettableBooleanValue autoMonitor();

   /**
    * Returns an object that provides access to the auto-monitoring mode of the track.
    *
    * @return a boolean value object
    * @since API version 14
    */

   SettableEnumValue monitorMode();

   /**
    * Returns an object that provides access to the cross-fade mode of the track.
    *
    * @return an enum value object that has three possible states: "A", "B", or "AB"
    * @since API version 1
    * @deprecated Use {@link #crossFadeMode()} instead.
    */
   @Deprecated
   SettableEnumValue getCrossFadeMode();

   /**
    * Returns an object that provides access to the cross-fade mode of the track.
    *
    * @return an enum value object that has three possible states: "A", "B", or "AB"
    * @since API version 5
    */
   @OscNode
   SettableEnumValue crossFadeMode();

   /**
    * Value that reports if this track is currently stopped. When a track is stopped it is not playing content
    * from the arranger or clip launcher.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isStopped();

   /**
    * Returns a value object that provides access to the clip launcher playback state of the track.
    *
    * @return a boolean value object that indicates if the clip launcher is stopped for this track
    * @see #getIsMatrixQueuedForStop()
    * @since API version 1
    * @deprecated Use {@link #isStopped()} instead.
    */
   @Deprecated
   BooleanValue getIsMatrixStopped();

   /**
    * Returns a value object that provides access to the clip launcher's queue-for-stop state on this track. A
    * clip is considered to be queued for stop when playback has been requested to be stopped on that clip,
    * but the playback has not stopped yet due to the current launch quantization settings.
    *
    * @return a boolean value object that indicates if the clip launcher slots have been queued for stop
    * @see #getIsMatrixStopped()
    * @since API version 1
    * @deprecated Use {@link #isQueuedForStop()} instead.
    */
   @Deprecated
   BooleanValue getIsMatrixQueuedForStop();

   /**
    * Value that reports if the clip launcher slots are queued for stop.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isQueuedForStop();

   /**
    * Returns the source selector for the track, which is shown in the IO section of the track in Bitwig
    * Studio and lists either note or audio sources or both depending on the track type.
    *
    * @return a source selector object
    * @since API version 1
    * @deprecated Use {@link #sourceSelector()} instead.
    */
   @Deprecated
   SourceSelector getSourceSelector();

   /**
    * Returns the source selector for the track, which is shown in the IO section of the track in Bitwig
    * Studio and lists either note or audio sources or both depending on the track type.
    *
    * @return a source selector object
    * @since API version 5
    */
   @OscNode
   SourceSelector sourceSelector();

   /**
    * Stops playback of the track.
    *
    * @since API version 1
    */
   @OscMethod
   void stop();

   /**
    * Action to call {@link #stop()}.
    * @since API version 10
    */
   HardwareActionBindable stopAction();

   /**
    * Stops playback of the track using alternative quantization.
    *
    * @since API version 18
    */
   @OscMethod
   void stopAlt();

   /**
    * Action to call {@link #stopAlt()}.
    * @since API version 18
    */
   HardwareActionBindable stopAltAction();

   /**
    * Calling this method causes the arrangement sequencer to take over playback.
    *
    * @since API version 1
    */
   @OscMethod
   void returnToArrangement();

   /**
    * Updates the name of the track.
    *
    * @param name
    *           the new track name
    * @since API version 1
    */
   @OscMethod
   void setName(String name);

   /**
    * Registers an observer that reports names for note key values on this track. The track might provide
    * special names for certain keys if it contains instruments that support that features, such as the Bitwig
    * Drum Machine.
    *
    * @param callback
    *           a callback function that receives two arguments: 1. the key value in the range [0..127], and
    *           2. the name string
    * @since API version 1
    */
   void addPitchNamesObserver(IndexedStringValueChangedCallback callback);

   /**
    * Plays a note on the track with a default duration and the given key and velocity.
    *
    * @param key
    *           the key value of the played note
    * @param velocity
    *           the velocity of the played note
    * @since API version 1
    */
   @OscMethod
   void playNote(int key, int velocity);

   /**
    * Starts playing a note on the track with the given key and velocity.
    *
    * @param key
    *           the key value of the played note
    * @param velocity
    *           the velocity of the played note
    * @since API version 1
    */
   @OscMethod
   void startNote(int key, int velocity);

   /**
    * Stops playing a currently played note.
    *
    * @param key
    *           the key value of the playing note
    * @param velocity
    *           the note-off velocity
    * @since API version 1
    */
   @OscMethod
   void stopNote(int key, int velocity);

   /**
    * Sends a MIDI message to the hardware device.
    *
    * @param status
    *           the status byte of the MIDI message
    * @param data1
    *           the data1 part of the MIDI message
    * @param data2
    *           the data2 part of the MIDI message
    * @since API version 2
    */
   @OscMethod
   void sendMidi(int status, int data1, int data2);

   /**
    * Value that reports the track type. Possible reported track types are `Group`, `Instrument`, `Audio`,
    * `Hybrid`, `Effect` or `Master`.
    *
    * @since API version 2
    */
   @OscNode
   StringValue trackType();

   /**
    * Registers an observer that reports the track type. Possible reported track types are `Group`,
    * `Instrument`, `Audio`, `Hybrid`, `Effect` or `Master`.
    *
    * @param numChars
    *           the maximum number of characters used for the reported track type
    * @param textWhenUnassigned
    *           the default text that gets reported when the track is not yet associated with a Bitwig Studio
    *           track.
    * @param callback
    *           a callback function that receives a single track type parameter (string).
    * @since API version 1
    * @deprecated Use {@link #trackType()} instead.
    */
   @Deprecated
   void addTrackTypeObserver(int numChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Value that reports if the track may contain child tracks, which is the case for group tracks.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isGroup();

   /**
    * Value that indicates if the group's child tracks are visible.
    *
    * @since API version 15
    */
   @OscNode
   SettableBooleanValue isGroupExpanded();

   /**
    * If the track is an effect track, returns an object that indicates if the effect track is configured
    * as pre-fader.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue getIsPreFader();

   /**
    * Registers an observer that reports if the track may contain child tracks, which is the case for group
    * tracks.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #isGroup()} instead.
    */
   @Deprecated
   void addIsGroupObserver(BooleanValueChangedCallback callback);

   /**
    * Returns an object that indicates if the track may contain notes.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #canHoldNoteData()} instead.
    */
   @Deprecated
   SettableBooleanValue getCanHoldNoteData();

   /**
    * Returns an object that indicates if the track may contain notes.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   SettableBooleanValue canHoldNoteData();

   /**
    * Returns an object that indicates if the track may contain audio events.
    *
    * @return a boolean value object
    * @since API version 1
    * @deprecated Use {@link #canHoldAudioData()} instead.
    */
   @Deprecated
   SettableBooleanValue getCanHoldAudioData();

   /**
    * Returns an object that indicates if the track may contain audio events.
    *
    * @return a boolean value object
    * @since API version 5
    */
   @OscNode
   SettableBooleanValue canHoldAudioData();

   /**
    * Returns an object that provides access to the cursor item of the track's device selection as shown in
    * the Bitwig Studio user interface.
    *
    * @return the requested device selection cursor object
    * @since API version 1
    */
   CursorDevice createCursorDevice();

   /**
    * Creates a named device selection cursor that is independent from the device selection in the Bitwig
    * Studio user interface, assuming the name parameter is not null. When `name` is `null` the result is
    * equal to calling {@link Track#createCursorDevice}.
    *
    * @param name
    *           the name of the custom device selection cursor, for example "Primary", or `null` to refer to
    *           the device selection cursor in the arranger cursor track as shown in the Bitwig Studio user
    *           interface.
    * @return the requested device selection cursor object
    * @see Track#createCursorDevice
    * @see #createCursorDevice(String name, int numSends)
    * @since API version 1
    */
   CursorDevice createCursorDevice(String name);

   /**
    * Creates a named device selection cursor that is independent from the device selection in the Bitwig
    * Studio user interface, assuming the name parameter is not null. When `name` is `null` the result is
    * equal to calling {@link Track#createCursorDevice}.
    *
    * @param name
    *           the name of the custom device selection cursor, for example "Primary", or `null` to refer to
    *           the device selection cursor in the arranger cursor track as shown in the Bitwig Studio user
    *           interface.
    * @param numSends
    *           the number of sends that are simultaneously accessible in nested channels.
    * @return the requested device selection cursor object
    * @see Track#createCursorDevice
    * @since API version 1
    */
   CursorDevice createCursorDevice(String name, int numSends);

   /**
    * Gets the channels primary device.
    *
    * @return an object that provides access to the channels primary device.
    * @deprecated Use {@link #createCursorDevice(String) createCursorDevice("Primary")} instead.
    * @since API version 1
    */
   @Deprecated
   Device getPrimaryDevice();

   /**
    * @deprecated Use {@link #createCursorDevice(String) createCursorDevice("Primary")} instead.
    * @since API version 1
    */
   @Deprecated
   Device getPrimaryInstrument();

   /**
    * Returns a track bank with the given number of child tracks, sends and scenes. The track bank will only
    * have content if the connected track is a group track.<br/>
    *
    * A track bank can be seen as a fixed-size window onto the list of tracks in the connected track group
    * including their sends and scenes, that can be scrolled in order to access different parts of the track
    * list. For example a track bank configured for 8 tracks can show track 1-8, 2-9, 3-10 and so on.<br/>
    *
    * The idea behind the `bank pattern` is that hardware typically is equipped with a fixed amount of channel
    * strips or controls, for example consider a mixing console with 8 channels, but Bitwig Studio documents
    * contain a dynamic list of tracks, most likely more tracks than the hardware can control simultaneously.
    * The track bank returned by this function provides a convenient interface for controlling which tracks
    * are currently shown on the hardware.<br/>
    *
    * Creating a track bank using this method will consider all tracks in the document, including effect
    * tracks and the master track. Use {@link #createMainTrackBank} or {@link #createEffectTrackBank} in case
    * you are only interested in tracks of a certain kind.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param hasFlatTrackList
    *           specifies whether the track bank should operate on a flat list of all nested child tracks or
    *           only on the direct child tracks of the connected group track.
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see #createMainTrackBank
    * @see #createEffectTrackBank
    * @since API version 1
    */
   TrackBank createTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final boolean hasFlatTrackList);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * @see #createTrackBank(int, int, int, boolean)
    * @param flatteningMode see comments in TrackBankFlatteningMode
    * @since API version 25
    */
   TrackBank createTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final TrackBankFlatteningMode flatteningMode);

   /**
    * Returns a track bank with the given number of child tracks, sends and scenes. Only audio tracks,
    * instrument tracks and hybrid tracks are considered. The track bank will only have content if the
    * connected track is a group track. For more information about track banks and the `bank pattern` in
    * general, see the documentation for {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param hasFlatTrackList
    *           specifies whether the track bank should operate on a flat list of all nested child tracks or
    *           only on the direct child tracks of the connected group track.
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see #createTrackBank
    * @see #createEffectTrackBank
    * @since API version 1
    */
   TrackBank createMainTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final boolean hasFlatTrackList);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * @see #createMainTrackBank(int, int, int, boolean)
    * @param flatteningMode see comments in TrackBankFlatteningMode
    * @since API version 25
    */
   TrackBank createMainTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final TrackBankFlatteningMode flatteningMode);

   /**
    * Returns a track bank with the given number of child effect tracks and scenes. Only effect tracks are
    * considered. The track bank will only have content if the connected track is a group track. For more
    * information about track banks and the `bank pattern` in general, see the documentation for
    * {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param hasFlatTrackList
    *           specifies whether the track bank should operate on a flat list of all nested child tracks or
    *           only on the direct child tracks of the connected group track.
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see #createTrackBank
    * @see #createMainTrackBank
    * @since API version 1
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numScenes, final boolean hasFlatTrackList);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * @see #createEffectTrackBank(int, int, int, boolean)
    * @param flatteningMode see comments in TrackBankFlatteningMode
    * @since API version 25
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numScenes, final TrackBankFlatteningMode flatteningMode);

   /**
    * Returns a track bank with the given number of child effect tracks and scenes. Only effect tracks are
    * considered. The track bank will only have content if the connected track is a group track. For more
    * information about track banks and the `bank pattern` in general, see the documentation for
    * {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param hasFlatTrackList
    *           specifies whether the track bank should operate on a flat list of all nested child tracks or
    *           only on the direct child tracks of the connected group track.
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see #createTrackBank
    * @see #createMainTrackBank
    * @since API version 18
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numSends, final int numScenes, final boolean hasFlatTrackList);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * @see #createEffectTrackBank(int, int, int, boolean)
    * @param flatteningMode see comments in TrackBankFlatteningMode
    * @since API version 25
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numSends, final int numScenes, final TrackBankFlatteningMode flatteningMode);

   /**
    * Returns an object that represents the master track of the connected track group. The returned object
    * will only have content if the connected track is a group track.
    *
    * @param numScenes
    *           the number of scenes for bank-wise navigation of the master tracks clip launcher slots.
    * @return an object representing the master track of the connected track group.
    * @since API version 1
    */
   MasterTrack createMasterTrack(final int numScenes);

   /**
    * Returns a bank of sibling tracks with the given number of tracks, sends and scenes. For more information
    * about track banks and the `bank pattern` in general, see the documentation for {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param shouldIncludeEffectTracks
    *           specifies whether effect tracks should be included
    * @param shouldIncludeMasterTrack
    *           specifies whether the master should be included
    * @return an object for bank-wise navigation of sibling tracks
    * @see #createTrackBank
    * @since API version 1
    */
   TrackBank createSiblingsTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final boolean shouldIncludeEffectTracks,
      final boolean shouldIncludeMasterTrack);

   /**
    * {@link InsertionPoint} that can be used to insert after this track.
    *
    * @since API version 7
    */
   InsertionPoint afterTrackInsertionPoint();

   /**
    * {@link InsertionPoint} that can be used to insert after this track.
    *
    * @since API version 7
    */
   InsertionPoint beforeTrackInsertionPoint();

   /**
    * Creates an object that represent the parent track.
    *
    * @since API version 10
    */
   Track createParentTrack(int numSends, int numScenes);

   /**
    * Routes the given noteInput directly to the track regardless of monitoring.
    * @since API version 10
    */
   void addNoteSource(NoteInput noteInput);

   /**
    * Removes a routing operated by {@link #addNoteSource(NoteInput)}
    * @since API version 10
    */
   void removeNoteSource(NoteInput noteInput);

   /**
    * Will create a new empty clip at or after slot index.
    * If necessary, a new scene will be created.
    * The new clip will be selected.
    * @param slotIndex absolute slot index in the track (unrelated to banks)
    * @since API version 10
    */
   @OscMethod
   void createNewLauncherClip(int slotIndex, int lengthInBeats);

   /**
    * Will create a new empty clip at or after slot index.
    * It will use the default clip length.
    * If necessary, a new scene will be created.
    * The new clip will be selected.
    * @param slotIndex absolute slot index in the track (unrelated to banks)
    * @since API version 10
    */
   @OscMethod
   void createNewLauncherClip(int slotIndex);

   /**
    * Will start recording a new clip at or after slot index.
    * If necessary, a new scene will be created.
    * The new clip will be selected.
    * @param slotIndex absolute slot index in the track (unrelated to banks)
    * @since API version 10
    */
   @OscMethod
   void recordNewLauncherClip(int slotIndex);

   /**
    * Selects the slot at the given index.
    * @param slotIndex absolute slot index in the track (unrelated to banks)
    * @since API version 10
    */
   @OscMethod
   void selectSlot(int slotIndex);

   /**
    * Launches the last clip with the given options:
    *
    * @param quantization possible values are "default", "none", "8", "4", "2", "1", "1/2", "1/4", "1/8", "1/16"
    * @param launchMode possible values are: "default", "from_start", "continue_or_from_start",
    *                   "continue_or_synced", "synced"
    *
    * @since API version 16
    */
   @OscMethod
   void launchLastClipWithOptions(final String quantization, final String launchMode);

   HardwareActionBindable launchLastClipWithOptionsAction(final String quantization, final String launchMode);

   /**
    * Creates a cursor for the selected remote controls page in the device with the supplied number of
    * parameters. This section will follow the current page selection made by the user in the application.
    *
    * @param parameterCount
    *           The number of parameters the remote controls should contain
    *
    * @since API version 18
    */
   CursorRemoteControlsPage createCursorRemoteControlsPage(int parameterCount);

   /**
    * Creates a cursor for a remote controls page in the device with the supplied number of parameters. This
    * section will be independent from the current page selected by the user in Bitwig Studio's user
    * interface. The supplied filter is an expression that can be used to match pages this section is
    * interested in. The expression is matched by looking at the tags added to the pages. If the expression is
    * empty then no filtering will occur.
    *
    * @param name
    *           A name to associate with this section. This will be used to remember manual mappings made by
    *           the user within this section.
    *
    *
    * @param parameterCount
    *           The number of parameters the remote controls should contain
    *
    * @param filterExpression
    *           An expression used to match pages that the user can navigate through. For now this can only be
    *           the name of a single tag the pages should contain (e.g "drawbars", "dyn", "env", "eq",
    *           "filter", "fx", "lfo", "mixer", "osc", "overview", "perf").
    *
    * @since API version 18
    */
   CursorRemoteControlsPage createCursorRemoteControlsPage(
      String name,
      int parameterCount,
      String filterExpression);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Function;

import com.bitwig.extension.api.Color;

/**
 * Defines a simple hardware light that only has an on and off state.
 *
 * @since API version 10
 */
public interface OnOffHardwareLight extends HardwareLight
{
   /** Property that determines if this light is on or not. */
   BooleanHardwareProperty isOn();

   default void setOnColor(final Color color)
   {
      setOnVisualState(HardwareLightVisualState.createForColor(color));
   }

   default void setOffColor(final Color color)
   {
      setOffVisualState(HardwareLightVisualState.createForColor(color));
   }

   void setOnVisualState(HardwareLightVisualState state);

   void setOffVisualState(HardwareLightVisualState state);


   /**
    *
    * @deprecated Typo in method name use {@link #setStateToVisualStateFunction(Function)} instead
    */
   @Deprecated
   void setStateToVisualStateFuncation(Function<Boolean, HardwareLightVisualState> function);

   void setStateToVisualStateFunction(Function<Boolean, HardwareLightVisualState> function);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface are used to navigate the available sessions in Bitwig Studio's contextual
 * browser. The sessions are shown as tabs in the graphical user interface of the browser.
 *
 * @since API version 1
 */
public interface BrowsingSessionBank extends Bank<GenericBrowsingSession>
{
   /**
    * Returns the window size that was used to configure the session bank during creation.
    *
    * @return the size of the session bank.
    * @since API version 1
    */
   int getSize();

   /**
    * Returns the browser session for the given index.
    *
    * @param index
    *           the session index, must be in the range `[0..getSize-1]`
    * @return the requested browser session object
    * @since API version 1
    */
   GenericBrowsingSession getSession(int index);

   /**
    * Scrolls the browser sessions one item up.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollBackwards()} instead.
    */
   @Deprecated
   void scrollUp();

   /**
    * Scrolls the browser sessions one item down.
    *
    * @since API version 1
    * @deprecated Use {@link #canScrollForwards()} instead.
    */
   @Deprecated
   void scrollDown();

   /**
    * Scrolls the browser sessions one page up. For example if the bank is configured with a window size of 8
    * entries and is currently showing items [1..8], calling this method would scroll the window to show items
    * [9..16].
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageBackwards()} instead.
    */
   @Deprecated
   void scrollPageUp();

   /**
    * Scrolls the filter columns one page up. For example if the bank is configured with a window size of 8
    * entries and is currently showing items [9..16], calling this method would scroll the window to show
    * items [1..8].
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageForwards()} instead.
    */
   @Deprecated
   void scrollPageDown();

   /**
    * Registers an observer that reports the current scroll position, more specifically the position of the
    * first item within the underlying list of browser sessions, that is shown as the first session within the
    * window.
    *
    * @param callback
    *           a callback function that receives a single integer number parameter. The parameter reflects
    *           the scroll position, or `-1` in case the column has no content.
    * @since API version 1
    * @deprecated Use {@link #scrollPosition()} instead.
    */
   @Deprecated
   void addScrollPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports if the browser sessions can be scrolled further up.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollBackwards()} instead.
    */
   @Deprecated
   void addCanScrollUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the browser sessions can be scrolled further down.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollForwards()} instead.
    */
   @Deprecated
   void addCanScrollDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the underlying total count of browser sessions (not the size of the
    * window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #itemCount()} instead.
    */
   @Deprecated
   void addEntryCountObserver(IntegerValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

public interface SettableBeatTimeValue
   extends BeatTimeValue, SettableDoubleValue, RelativeHardwarControlBindable
{
   /**
    * The same as the set method.
    *
    * @deprecated This is included only for backwards compatibility with API version 1 where this inherited
    *             from {@link RangedValue} instead of {@link DoubleValue}.
    */
   @Deprecated
   default void setRaw(final double value)
   {
      set(value);
   }

   /**
    * The same as the inc method.
    *
    * @deprecated This is included only for backwards compatibility with API version 1 where this inherited
    *             from {@link RangedValue} instead of {@link DoubleValue}.
    */
   @Deprecated
   default void incRaw(final double amount)
   {
      inc(amount);
   }

   /**
    * Stepper that steps through beat values. This can be used as a target for a
    * {@link RelativeHardwareControl}.
    *
    * @since API version 10
    */
   RelativeHardwarControlBindable beatStepper();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * A special kind of channel that follows a channel selection cursor in Bitwig Studio. The selection can
 * either be a custom selection cursor that gets created by the controller script, or represent the user
 * selection cursor as shown in the Bitwig Studio editors, such as the Arranger track selection cursor.
 *
 * @since API version 1
 */
public interface CursorChannel extends Cursor, Channel
{
   /**
    * Points the cursor to the given channel.
    *
    * @param channel
    *           the channel that this channel cursor should point to
    * @since API version 1
    */
   void selectChannel(Channel channel);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface represent ranged parameters that can be controlled with automation in Bitwig
 * Studio.
 *
 * @since API version 1
 */
public interface Parameter extends SettableRangedValue, ObjectProxy
{
   /**
    * Gets the current value of this parameter.
    *
    * @since API version 2
    */
   @OscNode
   SettableRangedValue value();

   /**
    * Gets the modulated value of this parameter.
    *
    * @since API version 2
    */
   @OscNode
   RangedValue modulatedValue();

   /**
    * The name of the parameter.
    *
    * @since API version 2
    */
   @OscNode
   StringValue name();

   /**
    * Adds an observer which reports changes to the name of the automated parameter. The callback will get
    * called at least once immediately after calling this method for reporting the current name.
    *
    * @param maxChars
    *           maximum length of the string sent to the observer
    * @param textWhenUnassigned
    *           the default text to use
    * @param callback
    *           a callback function that receives a single string parameter
    * @since API version 1
    * @deprecated
    */
   @Deprecated
   void addNameObserver(int maxChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Adds an observer which sends a formatted text representation of the value whenever the value changes.
    * The callback will get called at least once immediately after calling this method for reporting the
    * current state.
    *
    * @param maxChars
    *           maximum length of the string sent to the observer
    * @param textWhenUnassigned
    *           the default text to use
    * @param callback
    *           a callback function that receives a single string parameter
    * @since API version 1
    * @deprecated Use {@link #value()#displayedValue()} instead
    */
   @Deprecated
   void addValueDisplayObserver(int maxChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Resets the value to its default.
    *
    * @since API version 1
    */
   @OscMethod
   void reset();

   /**
    * Touch (or un-touch) the value for automation recording.
    *
    * @param isBeingTouched
    *           `true` for touching, `false` for un-touching
    * @since API version 1
    */
   @OscMethod
   void touch(boolean isBeingTouched);

   /**
    * Specifies if this value should be indicated as mapped in Bitwig Studio, which is visually shown as
    * colored dots or tinting on the parameter controls.
    *
    * @param shouldIndicate
    *           `true` in case visual indications should be shown in Bitwig Studio, `false` otherwise
    * @since API version 1
    */
   @OscMethod
   void setIndication(boolean shouldIndicate);

   /**
    * Specifies a label for the mapped hardware parameter as shown in Bitwig Studio, for example in menu items
    * for learning controls.
    *
    * @param label
    *           the label to be shown in Bitwig Studio
    * @since API version 1
    */
   @OscMethod
   void setLabel(String label);

   /**
    * Restores control of this parameter to automation playback.
    *
    * @since API version 1
    */
   @OscMethod
   void restoreAutomationControl();

   /**
    * Boolean value that is true if the parameter has automation data.
    *
    * @since API version 19
    */
   @OscNode
   BooleanValue hasAutomation();

   /**
    * Deletes all automation for this parameter.
    *
    * @since API version 19
    */
   @OscMethod
   void deleteAllAutomation();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Consumer;
import java.util.function.Supplier;

import com.bitwig.extension.api.Color;

/**
 * Represents an output value shown on some hardware (for example, the color of a light).
 *
 * @since API version 10
 */
public interface ColorHardwareProperty extends HardwareProperty
{
   /** Gets the current value. This is the value that should be sent to the hardware to be displayed. */
   Color currentValue();

   /** The value that was last sent to the hardware. */
   Color lastSentValue();

   /**
    * Specifies a callback that should be called with the value that needs to be sent to the hardware. This
    * callback is called as a result of calling the {@link HardwareSurface#updateHardware()} method (typically
    * from the flush method).
    */
   void onUpdateHardware(Consumer<Color> sendValueConsumer);

   /** Sets the current value. */
   void setValue(Color value);

   /** Sets the current value from a {@link Supplier} that supplies the latest value. */
   void setValueSupplier(Supplier<Color> supplier);
}-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a line of text on a {@link HardwareTextDisplay}.
 *
 * @since API version 10
 */
public interface HardwareTextDisplayLine
{
   /** Property that defines the current text shown. */
   StringHardwareProperty text();

   /** Property that defines the background color of this line. */
   ColorHardwareProperty backgroundColor();

   /** Property that defines the text color of this line. */
   ColorHardwareProperty textColor();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent entries in a browser filter column.
 *
 * @since API version 1
 */
public interface CursorBrowserItem extends BrowserItem, Cursor
{
   /**
    * Returns a bank object that provides access to the siblings of the cursor item. The bank will
    * automatically scroll so that the cursor item is always visible.
    *
    * @param numSiblings
    *           the number of simultaneously accessible siblings
    * @return the requested item bank object
    */
   BrowserItemBank createSiblingsBank(int numSiblings);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from a {@link RelativeHardwareControl} to some target.
 *
 * @since API version 10
 */
public interface RelativeHardwareControlBinding extends HardwareBindingWithSensitivity
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Something that can be bound to an {@link AbsoluteHardwareControl} and can respond to the user input (such
 * as user moving a slider up or down) in a meaningful way.
 *
 * @since API version 10
 */
public interface AbsoluteHardwarControlBindable extends HardwareBindable
{
   /**
    * Binds this target to the supplied hardware control so that when the user moves the hardware control this
    * target will respond in a meaningful way.
    *
    * When the binding is no longer needed the {@link HardwareBinding#removeBinding()} method can be called on
    * it.
    *
    * @return The newly created binding
    */
   default AbsoluteHardwareControlBinding addBinding(final AbsoluteHardwareControl hardwareControl)
   {
      return addBindingWithRange(hardwareControl, 0, 1);
   }

   /**
    * Binds this target to the supplied hardware control so that when the user moves the hardware control this
    * target will respond in a meaningful way. This target will be adjusted within the supplied normalized
    * range.
    *
    * When the binding is no longer needed the {@link HardwareBinding#removeBinding()} method can be called on
    * it.
    *
    * @return The newly created binding
    */
   AbsoluteHardwareControlBinding addBindingWithRange(
      AbsoluteHardwareControl hardwareControl,
      double minNormalizedValue,
      double maxNormalizedValue);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents the source of a {@link HardwareBinding}.
 *
 * @since API version 10
 */
public interface HardwareBindingSource<HardwareBindingType extends HardwareBinding>
{
   /** Checks if it is possible to make a binding from this source to the supplied target object. */
   boolean canBindTo(Object target);

   /**
    * Binds this source to the supplied target and returns the created binding. This can only be called if the
    * {@link #canBindTo(Object)} returns true.
    */
   HardwareBindingType addBinding(HardwareBindable target);

   /** Clears all bindings from this source to its targets. */
   void clearBindings();

   /**
    * Ensures there is a single binding to the supplied target.
    *
    * This is a convenience method that is equivalent to calling {@link #clearBindings()} and the
    * {@link #addBinding(HardwareBindable)}
    */
   HardwareBindingType setBinding(HardwareBindable target);

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent entries in a browser results column.
 *
 * @since API version 1
 */
public interface BrowserResultsItem extends BrowserItem
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Some kind of physical control on a piece of hardware (such as a knob, button, slider etc).
 *
 * @since API version 10
 */
public interface HardwareControl extends HardwareElement
{
   /**
    * The name of this hardware control. This will be shown in the mapping browser, for example. It should
    * provide enough information for the user to understand which control is being referred to. If the name is
    * not provided then the label will be used, and if that is not provided then the id will be used.
    *
    * @since API version 11
    */
   String getName();

   /**
    * The name of this hardware control. This will be shown in the mapping browser, for example. It should
    * provide enough information for the user to understand which control is being referred to. If the name is
    * not provided then the label will be used, and if that is not provided then the id will be used.
    *
    * @since API version 11
    */
   void setName(String name);

   /**
    * If this control is part of group of related controls then this specifies the index in that group.
    * This index is used to automatically indicate a mapping color on a parameter that this hardware
    * control gets bound to.
    *
    * @since API version 11
    */
   void setIndexInGroup(int index);

   /** Action that happens when the user touches this control. */
   HardwareAction beginTouchAction();

   /** Action that happens when the user stops touching this control. */
   HardwareAction endTouchAction();

   /** Value that indicates if this control is being touched or not. */
   BooleanValue isBeingTouched();

   /** Optional light that is in the background of this control. */
   HardwareLight backgroundLight();

   /** Sets the optional light that is in the background of this control. */
   void setBackgroundLight(HardwareLight light);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface are used to navigate the columns of a Bitwig Studio browser session.
 *
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface BrowserFilterColumnBank extends Bank<BrowserFilterColumn>
{
   /**
    * Returns the window size that was used to configure the filter column during creation.
    *
    * @return the size of the filter column.
    */
   int getSize();

   /**
    * Returns the filter column for the given index.
    *
    * @param index
    *           the item index, must be in the range `[0..getSize-1]`
    * @return the requested filter column object
    */
   BrowserFilterColumn getItem(int index);

   /**
    * Scrolls the filter columns one item up.
    *
    * @since API version 1
    */
   void scrollUp();

   /**
    * Scrolls the filter columns one item down.
    *
    * @since API version 1
    */
   void scrollDown();

   /**
    * Scrolls the filter columns one page up. For example if the bank is configured with a window size of 8
    * entries and is currently showing items [1..8], calling this method would scroll the window to show
    * columns [9..16].
    *
    * @since API version 1
    */
   void scrollPageUp();

   /**
    * Scrolls the filter columns one page up. For example if the bank is configured with a window size of 8
    * entries and is currently showing items [9..16], calling this method would scroll the window to show
    * columns [1..8].
    *
    * @since API version 1
    */
   void scrollPageDown();

   /**
    * Registers an observer that reports the current scroll position, more specifically the position of the
    * first item within the underlying list of columns, that is shown as the first column within the window.
    *
    * @param callback
    *           a callback function that receives a single integer number parameter. The parameter reflects
    *           the scroll position, or `-1` in case the column has no content.
    * @since API version 1
    */
   void addScrollPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports if the columns can be scrolled further up.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    */
   void addCanScrollUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the columns can be scrolled further down.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    */
   void addCanScrollDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the underlying total count of columns (not the size of the window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    */
   void addEntryCountObserver(IntegerValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to send MIDI messages to a specific MIDI hardware.
 *
 * @since API version 1
 */
public interface MidiOut
{
   /**
    * Sends a MIDI message to the hardware device.
    *
    * @param status
    *           the status byte of the MIDI message, system messages are not permitted.
    * @param data1
    *           the data1 part of the MIDI message
    * @param data2
    *           the data2 part of the MIDI message
    * @since API version 1
    */
   void sendMidi(int status, int data1, int data2);

   /**
    * Sends a MIDI SysEx message to the hardware device.
    *
    * Starting from API version 19, sending invalid sysex will crash the ControllerExtension.
    *
    * @param hexString
    *           the sysex message formatted as hexadecimal value string
    * @since API version 1
    */
   void sendSysex(String hexString);

   /**
    * Sends a MIDI SysEx message to the hardware device.
    *
    * Starting from API version 19, sending invalid sysex will crash the ControllerExtension.
    *
    * @param data
    *           the array of bytes to send
    *
    * @since API version 2
    */
   void sendSysex(byte[] data);

   /**
    * Sends a MIDI SysEx message to the hardware device. This method is identical to {@link #sendSysex(byte[])}
    * but exists so that Javascript controllers can explicitly call this method instead of relying on some
    * intelligent overload resolution of the Javascript engine based on its loose type system.
    *
    * Starting from API version 19, sending invalid sysex will crash the ControllerExtension.
    *
    * @param data
    *           the array of bytes to send
    * @since API version 2
    */
   void sendSysexBytes(byte[] data);

   /**
    * Enables or disables sending MIDI beat clock messages to the hardware depending on the given parameter.
    * Typically MIDI devices that run an internal sequencer such as hardware step sequencers would be
    * interested in MIDI clock messages.
    *
    * @param shouldSendClock
    *           `true` in case the hardware should receive MIDI clock messages, `false` otherwise
    * @deprecated Users should enable the clock from the settings.
    * @since API version 1
    */
   @Deprecated
   void setShouldSendMidiBeatClock(boolean shouldSendClock);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.List;

import com.bitwig.extension.controller.UsbDeviceMatcher;
import com.bitwig.extension.controller.UsbInterfaceMatcher;

/**
 * Defines a USB device that is available for communication.
 *
 * @since API version 7
 */
public interface UsbDevice extends HardwareDevice
{
   /**
    * The {@link UsbDeviceMatcher} that was provided by the controller for identifying this device.
    *
    */
   @Override
   UsbDeviceMatcher deviceMatcher();

   /** The list of {@link UsbInterface}s that have been opened for this device. */
   List<UsbInterface> ifaces();

   /**
    * The {@link UsbInterface} that was claimed using the {@link UsbInterfaceMatcher} defined at the
    * corresponding index in the {@link UsbDeviceMatcher}.
    */
   UsbInterface iface(int index);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface that can be used to access the parameter and output value of a specific Bitwig native device.
 *
 * Specific interfaces can be created by calling {@link Device#createSpecificBitwigDevice(java.util.UUID)}.
 *
 * @since API version 12
 */
public interface SpecificBitwigDevice
{
   /**
    * Creates a {@link Parameter} that will refer to the parameter of the device with the specified parameter
    * id.
    */
   Parameter createParameter(String id);

   /**
    * Creates an {@link IntegerValue} that can be used to read a certain output value of the device.
    */
   IntegerValue createIntegerOutputValue(String id);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * This interface is used to configure observation of pretty-printed device parameter values.
 *
 * @since API version 1
 */
public interface DirectParameterValueDisplayObserver
{
   /**
    * Starts observing the parameters according to the given parameter ID array, or stops observing in case
    * `null` is passed in for the parameter ID array.
    *
    * @param parameterIds
    *           the array of parameter IDs or `null` to stop observing parameter display values.
    * @since API version 1
    */
   void setObservedParameterIds(String[] parameterIds);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Beta API - this type might not be available in a future version of Bitwig Studio
 */
public enum TrackBankFlatteningMode
{
   NOT_FLATTENED, // only include tracks in current level (in other words, skip child tracks of groups)
   FLATTEN, // include all tracks (current level and nested), but skip tracks that are not visible in the mixer
   FLATTEN_AND_IGNORE_VISIBILITY, // include all tracks, even the ones that are not visible in the mixer
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Supplier;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.EnumValueChangedCallback;

public interface EnumValue extends Value<EnumValueChangedCallback>, Supplier<String>
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   @Override
   @OscMethod
   String get();

   /**
    * Gets the enum definition.
    *
    * @since API version 11
    */
   @OscNode
   EnumDefinition enumDefinition();
}
-e 


package com.bitwig.extension.controller.api;

public enum UsbTransferDirection
{
   IN, OUT;

   public static UsbTransferDirection getForEndpointAddress(final byte bEndpointAddress)
   {
      return ((bEndpointAddress & 0x80) == 0) ? OUT : IN;
   }
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;

/**
 * An interface used to access various commands that can be performed on the Bitwig Studio mixer panel.<br/>
 *
 * To get an instance of the mixer interface call {@link ControllerHost#createMixer}.
 *
 * @since API version 1
 */
public interface Mixer
{
   /**
    * Gets an object that allows to show/hide the meter section of the mixer panel. Observers can be
    * registered on the returned object for receiving notifications when the meter section switches between
    * shown and hidden state.
    *
    * @return a boolean value object that represents the meter section visibility
    * @since API version 1
    */
   SettableBooleanValue isMeterSectionVisible();

   /**
    * Gets an object that allows to show/hide the io section of the mixer panel. Observers can be registered
    * on the returned object for receiving notifications when the io section switches between shown and hidden
    * state.
    *
    * @return a boolean value object that represents the io section visibility
    * @since API version 1
    */
   SettableBooleanValue isIoSectionVisible();

   /**
    * Gets an object that allows to show/hide the sends section of the mixer panel. Observers can be
    * registered on the returned object for receiving notifications when the sends section switches between
    * shown and hidden state.
    *
    * @return a boolean value object that represents the sends section visibility
    * @since API version 1
    */
   SettableBooleanValue isSendSectionVisible();

   /**
    * Gets an object that allows to show/hide the clip launcher section of the mixer panel. Observers can be
    * registered on the returned object for receiving notifications when the clip launcher section switches
    * between shown and hidden state.
    *
    * @return a boolean value object that represents the clip launcher section visibility
    * @since API version 1
    */
   SettableBooleanValue isClipLauncherSectionVisible();

   /**
    * Gets an object that allows to show/hide the devices section of the mixer panel. Observers can be
    * registered on the returned object for receiving notifications when the devices section switches between
    * shown and hidden state.
    *
    * @return a boolean value object that represents the devices section visibility
    * @since API version 1
    */
   SettableBooleanValue isDeviceSectionVisible();

   /**
    * Gets an object that allows to show/hide the cross-fade section of the mixer panel. Observers can be
    * registered on the returned object for receiving notifications when the cross-fade section switches
    * between shown and hidden state.
    *
    * @return a boolean value object that represents the cross-fade section visibility
    * @since API version 1
    */
   SettableBooleanValue isCrossFadeSectionVisible();

   /**
    * Zooms in all mixer tracks, if it the mixer is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInTrackWidthsAllAction();

   void zoomInTrackWidthsAll();

   /**
    * Zooms out all mixer tracks, if it the mixer is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutTrackWidthsAllAction();

   void zoomOutTrackWidthsAll();

   /**
    * Same as zoomInTrackWidthsAllAction/zoomOutTrackWidthsAllAction, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomTrackWidthsAllStepper();

   /**
    * Zooms in selected mixer tracks, if it the mixer is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInTrackWidthsSelectedAction();

   void zoomInTrackWidthsSelected();

   /**
    * Zooms out selected mixer tracks, if it the mixer is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutTrackWidthsSelectedAction();

   void zoomOutTrackWidthsSelected();

   /**
    * Same as zoomInTrackWidthsSelectedAction/zoomOutTrackWidthsSelectedAction, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomTrackWidthsSelectedStepper();

   /**
    * Registers an observer that reports if the meter section is visible (callback argument is `true`) in the
    * mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isMeterSectionVisible()
    * @deprecated call `isMeterSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addMeterSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the IO section is visible (callback argument is `true`) in the
    * mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isIoSectionVisible()
    * @deprecated call `isIoSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addIoSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the send control section is visible (callback argument is `true`)
    * in the mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isSendSectionVisible()
    * @deprecated call `isSendSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addSendsSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the clip launcher section is visible (callback argument is `true`)
    * in the mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isClipLauncherSectionVisible()
    * @deprecated call `isClipLauncherSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addClipLauncherSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the device section is visible (callback argument is `true`) in the
    * mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isDeviceSectionVisible()
    * @deprecated call `isDeviceSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addDeviceSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the cross-fade section is visible (callback argument is `true`) in
    * the mixer panel or not (callback argument is `false`).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @see #isCrossFadeSectionVisible()
    * @deprecated call `isCrossFadeSectionVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addCrossFadeSectionVisibilityObserver(final BooleanValueChangedCallback callback);

   /**
    * Toggles the visibility of the meter section in the mixer panel.
    *
    * @see #isMeterSectionVisible()
    * @deprecated call `isMeterSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleMeterSectionVisibility();

   /**
    * Toggles the visibility of the IO section in the mixer panel.
    *
    * @see #isIoSectionVisible()
    * @deprecated call `isIoSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleIoSectionVisibility();

   /**
    * Toggles the visibility of the send control section in the mixer panel.
    *
    * @see #isSendSectionVisible()
    * @deprecated call `isSendSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleSendsSectionVisibility();

   /**
    * Toggles the visibility of the clip launcher section in the mixer panel.
    *
    * @see #isClipLauncherSectionVisible()
    * @deprecated call `isClipLauncherSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleClipLauncherSectionVisibility();

   /**
    * Toggles the visibility of the device section in the mixer panel.
    *
    * @see #isDeviceSectionVisible()
    * @deprecated call `isDeviceSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleDeviceSectionVisibility();

   /**
    * Toggles the visibility of the cross-fade section in the mixer panel.
    *
    * @see #isCrossFadeSectionVisible()
    * @deprecated call `isCrossFadeSectionVisible().toggle()` instead
    * @since API version 1
    */
   @Deprecated
   void toggleCrossFadeSectionVisibility();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a value that needs to be displayed somehow on the hardware.
 *
 * A {@link HardwareProperty} is part of a {@link HardwareOutputElement}.
 *
 * @since API version 10
 * */
public interface HardwareProperty
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface for something that can be scrolled.
 *
 * @since API version 2
 */
public interface Scrollable extends RelativeHardwarControlBindable
{
   /**
    * Value that reports the current scroll position.
    *
    * @since API version 2
    */
   SettableIntegerValue scrollPosition();

   /**
    * Scrolls the supplied position into view if it isn't already.
    *
    * @since API version 7
    */
   void scrollIntoView(int position);

   /**
    * Scrolls by a number of steps.
    *
    * @param amount
    *           The number of steps to scroll by (positive is forwards and negative is backwards).
    */
   void scrollBy(int amount);

   /**
    * Scrolls forwards by one step. This is the same as calling {@link #scrollBy(int)} with 1
    *
    * @since API version 2
    */
   default void scrollForwards()
   {
      scrollBy(1);
   }

   HardwareActionBindable scrollForwardsAction();

   /**
    * Scrolls forwards by one step. This is the same as calling {@link #scrollBy(int)} with -1
    *
    * @since API version 2
    */
   default void scrollBackwards()
   {
      scrollBy(-1);
   }

   HardwareActionBindable scrollBackwardsAction();

   /**
    * Scrolls by a number of pages.
    *
    * @param amount
    *           The number of pages to scroll by (positive is forwards and negative is backwards).
    */
   void scrollByPages(int amount);

   /**
    * Scrolls forwards by one page.
    *
    * @since API version 2
    */
   default void scrollPageForwards()
   {
      scrollByPages(1);
   }

   HardwareActionBindable scrollPageForwardsAction();

   /**
    * Scrolls backwards by one page.
    *
    * @since API version 2
    */
   default void scrollPageBackwards()
   {
      scrollByPages(-1);
   }

   HardwareActionBindable scrollPageBackwardsAction();

   /**
    * Value that reports if it is possible to scroll the bank backwards or not.
    *
    * @since API version 2
    */
   BooleanValue canScrollBackwards();

   /**
    * Value that reports if it is possible to scroll the bank forwards or not.
    *
    * @since API version 2
    */
   BooleanValue canScrollForwards();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.ShortMidiDataReceivedCallback;
import com.bitwig.extension.callback.SysexMidiDataReceivedCallback;

/**
 * Instances of this interface are used to setup handler functions for incoming MIDI messages from a specific
 * MIDI hardware.
 *
 * <p>
 * Expressions can be used to generate matchers for various MIDI events that can then be used to update
 * hardware control states (see {@link MidiIn#createActionMatcher(String)} and {@link HardwareControl}).
 * </p>
 *
 * <p>
 * The expression language supports these operators in the same way that C, Java, C++ do:
 * {@literal +, -, *, /, %, <<, >>, &&, ||, &, |, ^, <, <=, >, >=, ==, !=}
 * </p>
 *
 * The following variables are also defined for matching parts of the event:
 * <ul>
 * <li>status - Value of the status byte
 * <li>data1 - Value of the first data byte
 * <li>data2 - Value of the second data byte
 * <li>event - Integer value of the whole MIDI event with data2 byte in the least significant bits
 * </ul>
 *
 * <p>
 * Integers can be represented in hex using same syntax as C. 'true' and 'false' keywords are also defined.
 * </p>
 *
 * @since API version 1
 */
public interface MidiIn
{
   /**
    * Registers a callback for receiving short (normal) MIDI messages on this MIDI input port.
    *
    * @param callback
    *           a callback function that receives three integer parameters: 1. the status byte 2. the data1
    *           value 2. the data2 value
    * @since API version 1
    */
   void setMidiCallback(ShortMidiDataReceivedCallback callback);

   /**
    * Registers a callback for receiving sysex MIDI messages on this MIDI input port.
    *
    * @param callback
    *           a callback function that takes a single string argument
    * @since API version 1
    */
   void setSysexCallback(SysexMidiDataReceivedCallback callback);

   /**
    * Creates a note input that appears in the track input choosers in Bitwig Studio. This method must be
    * called within the `init()` function of the script. The messages matching the given mask parameter will
    * be fed directly to the application, and are not processed by the script.
    *
    * @param name
    *           the name of the note input as it appears in the track input choosers in Bitwig Studio
    * @param masks
    *           a filter string formatted as hexadecimal value with `?` as wildcard. For example `80????`
    *           would match note-off on channel 1 (0). When this parameter is null, a standard filter will
    *           be used to forward note-related messages on channel 1 (0).
    *
    *           If multiple note input match the same MIDI event then they'll all receive the MIDI event, and
    *           if one of them does not consume events then the events won't be consumed.
    * @return the object representing the requested note input
    * @since API version 1
    */
   NoteInput createNoteInput(String name, String... masks);

   /**
    * Creates a matcher that matches the absolute value of a MIDI CC message.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createAbsoluteCCValueMatcher(int channel, int controlNumber);

   /**
    * Creates a matcher that matches the absolute value of a MIDI CC message regardless of its channel.
    *
    * @since API version 11
    */
   AbsoluteHardwareValueMatcher createAbsoluteCCValueMatcher(int controlNumber);

   /**
    * Creates a matcher that matches the absolute value of a Poly AT message.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createPolyAftertouchValueMatcher(int channel, int note);

   /**
    * Creates a matcher that matches the relative value of a MIDI CC message encoded using signed bit.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBitCCValueMatcher(
      int channel,
      int controlNumber,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value of a MIDI CC message encoded using signed bit 2.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBit2CCValueMatcher(
      int channel,
      int controlNumber,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value of a MIDI CC message encoded using bin offset.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeBinOffsetCCValueMatcher(
      int channel,
      int controlNumber,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value of a MIDI CC message encoded using 2s complement.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelative2sComplementCCValueMatcher(
      int channel,
      int controlNumber,
      int valueAmountForOneFullRotation);

   /**
    * Create a matcher that matches the absolute value of a MIDI pitch bend message.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createAbsolutePitchBendValueMatcher(int channel);

   /**
    * Creates an absolute value matcher that is defined by 2 separate MIDI events that have to occur in
    * sequence.
    *
    * This can be used to get a much higher precision value that a single MIDI event would allow. Some
    * controllers for example will send 2 CC events for a single value.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createSequencedValueMatcher(
      AbsoluteHardwareValueMatcher firstValueMatcher,
      AbsoluteHardwareValueMatcher secondValueMatcher,
      boolean areMostSignificantBitsInSecondEvent);

   /**
    * Creates a matcher that matches the absolute value of a MIDI CC message by using expressions to filter
    * and extract a value out of the MIDI event.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param valueExpression
    *           Expression that determines the value once an event has been matched.
    * @param valueBitCount
    *           The number of bits that are relevant from the value extracted by the valueExpression.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createAbsoluteValueMatcher(
      String eventExpression,
      String valueExpression,
      int valueBitCount);

   /**
    * Creates a matcher that applies a relative adjustment when a MIDI event occurs matching an expression.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param relativeAdjustment
    *           The amount of relative adjustment that should be applied
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeValueMatcher(String eventExpression, double relativeAdjustment);

   /**
    * Creates a matcher that matches the relative value (encoded as signed bit) of a MIDI CC message by using
    * expressions to filter and extract a value out of the MIDI event.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param valueExpression
    *           Expression that determines the value once an event has been matched.
    * @param valueBitCount
    *           The number of bits that are relevant from the value extracted by the valueExpression.
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBitValueMatcher(
      String eventExpression,
      String valueExpression,
      int valueBitCount,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that converts a value matched by an {@link AbsoluteHardwareValueMatcher} to a relative
    * value using signed bit.
    *
    * @param valueMatcher
    *           Value matcher that matches the value that needs to be converted to a relative value
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBitValueMatcher(
      AbsoluteHardwareValueMatcher valueMatcher,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value (encoded as signed bit 2) of a MIDI CC message by
    * using expressions to filter and extract a value out of the MIDI event.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param valueExpression
    *           Expression that determines the value once an event has been matched.
    * @param valueBitCount
    *           The number of bits that are relevant from the value extracted by the valueExpression.
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBit2ValueMatcher(
      String eventExpression,
      String valueExpression,
      int valueBitCount,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that converts a value matched by an {@link AbsoluteHardwareValueMatcher} to a relative
    * value using signed bit 2.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeSignedBit2ValueMatcher(
      AbsoluteHardwareValueMatcher valueMatcher,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value (encoded as bin offset) of a MIDI CC message by using
    * expressions to filter and extract a value out of the MIDI event.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param valueExpression
    *           Expression that determines the value once an event has been matched.
    * @param valueBitCount
    *           The number of bits that are relevant from the value extracted by the valueExpression.
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeBinOffsetValueMatcher(
      String eventExpression,
      String valueExpression,
      int valueBitCount,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that converts a value matched by an {@link AbsoluteHardwareValueMatcher} to a relative
    * value using bin offset.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelativeBinOffsetValueMatcher(
      AbsoluteHardwareValueMatcher valueMatcher,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that matches the relative value (encoded as 2s complement) of a MIDI CC message by
    * using expressions to filter and extract a value out of the MIDI event.
    *
    * @param eventExpression
    *           Expression that must be true in order to extract the value.
    * @param valueExpression
    *           Expression that determines the value once an event has been matched.
    * @param valueBitCount
    *           The number of bits that are relevant from the value extracted by the valueExpression.
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelative2sComplementValueMatcher(
      String eventExpression,
      String valueExpression,
      int valueBitCount,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that converts a value matched by an {@link AbsoluteHardwareValueMatcher} to a relative
    * value using 2s complement.
    *
    * @param valueAmountForOneFullRotation
    *           The value that would represent one full rotation to the right (should be very similar to the
    *           amount of rotation needed to take an absolute knob from 0 to 1). For example, if a value of
    *           127 meant it had been rotated to the right by a full rotation then you would pass 127 here.
    *           This ensures that {@link RelativeHardwareControl}s have similar sensitivity to each other and
    *           can be mapped and behave in a very similar way to {@link AbsoluteHardwareControl}s.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createRelative2sComplementValueMatcher(
      AbsoluteHardwareValueMatcher valueMatcher,
      int valueAmountForOneFullRotation);

   /**
    * Creates a matcher that recognizes an action when getting a MIDI CC event with a specific value.
    *
    * @since API version 10
    */
   HardwareActionMatcher createCCActionMatcher(int channel, int controlNumber, int value);

   /**
    * Creates a matcher that recognizes an action when getting a MIDI CC event regardless of the value.
    *
    * @since API version 10
    */
   HardwareActionMatcher createCCActionMatcher(int channel, int controlNumber);

   /**
    * Creates a matcher that recognizes an action when a MIDI note on event occurs.
    *
    * @since API version 10
    */
   HardwareActionMatcher createNoteOnActionMatcher(int channel, int note);

   /**
    * Creates a matcher that recognizes a note's on velocity when a MIDI note on event occurs.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createNoteOnVelocityValueMatcher(int channel, int note);

   /**
    * Creates a matcher that recognizes a note's off velocity when a MIDI note off event occurs.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createNoteOffVelocityValueMatcher(int channel, int note);

   /**
    * Creates a matcher that recognizes an action when a MIDI note off event occurs.
    *
    * @since API version 10
    */
   HardwareActionMatcher createNoteOffActionMatcher(int channel, int note);

   /**
    * Creates a matcher that can match an action from a MIDI event. For example, pressing a button based on
    * input of a MIDI CC event.
    *
    * @param expression
    *           Expression returns true if the event matches
    */
   HardwareActionMatcher createActionMatcher(String expression);

   /**
    *
    * @return The address of the hardware device this port belongs to. If two ports belong to the same physical device,
    * they have the same address.
    *
    * @since API version 21
    */
   String hardwareAddress();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * This interface is used to save custom script settings inside Bitwig Studio documents. The settings are
 * shown to the user in the `Studio IO` panel of Bitwig Studio.
 *
 * @since API version 1
 */
public interface DocumentState extends Settings
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from some hardware input to a ranged value.
 *
 * @since API version 10
 */
public interface HardwareBindingWithRange extends HardwareBinding
{
   /** Sets the minimum normalized value (0...1) that should be used for this binding. */
   void setMinNormalizedValue(double min);

   /** Sets the maximum normalized value (0...1) that should be used for this binding. */
   void setMaxNormalizedValue(double max);

   /** Sets the normalized range (0...1) that should be used for this binding. */
   void setNormalizedRange(double min, double max);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * A {@link HardwareBinding} that has some sensitivity setting.
 *
 * @since API version 10
 */
public interface HardwareBindingWithSensitivity extends HardwareBinding
{
   /** Sets the sensitivity of this binding. */
   void setSensitivity(double sensitivity);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.BooleanSupplier;
import java.util.function.Consumer;

/**
 *  Represents an output value shown on some hardware (for example, if an LED is on or off).
 *
 * @since API version 10
 * */
public interface BooleanHardwareProperty extends HardwareProperty
{
   /** Gets the current value. This is the value that should be sent to the hardware to be displayed. */
   boolean currentValue();

   /** The value that was last sent to the hardware. */
   boolean lastSentValue();

   /**
    * Specifies a callback that should be called with the value that needs to be sent to the hardware. This
    * callback is called as a result of calling the {@link HardwareSurface#updateHardware()} method (typically
    * from the flush method).
    */
   void onUpdateHardware(Consumer<Boolean> sendValueConsumer);

   /** Sets the current value. */
   void setValue(boolean value);

   /** Sets the current value from a {@link BooleanSupplier} that supplies the latest value. */
   void setValueSupplier(BooleanSupplier supplier);
}
-e 


package com.bitwig.extension.controller.api;

public interface UsbInputPipe extends UsbPipe, InputPipe
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Proxy to an arpeggiator component.
 *
 * @since API version 10
 */
public interface Arpeggiator extends ObjectProxy
{
   /**
    * Returns an object to configure the arpeggiator mode.
    * Possible values:
    *  - all
    *  - up
    *  - up-down
    *  - up-then-down
    *  - down
    *  - down-up
    *  - down-then-up
    *  - flow
    *  - random
    *  - converge-up
    *  - converge-down
    *  - diverge-up
    *  - diverge-down
    *  - thumb-up
    *  - thumb-down
    *  - pinky-up
    *  - pinky-down
    *
    * @since API version 10
    */
   @OscNode
   SettableEnumValue mode();

   /**
    * Returns an object to configure the range in octaves.
    * The range is between 0 and 8.
    *
    * @since API version 10
    */
   @OscNode
   SettableIntegerValue octaves();

   /**
    * Returns an object to enable or disable the note repeat component.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue isEnabled();

   /**
    * If true the arpeggiator will not try to sync to the transport.
    * @since API version  10
    */
   @OscNode
   SettableBooleanValue isFreeRunning();

   /**
    * Return an object to configure the note repeat to use shuffle or not.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue shuffle();

   /**
    * Returns an object to configure the note repeat rate in beats.
    *
    * @since API version 10
    */
   @OscNode
   SettableDoubleValue rate();

   /**
    * Returns an object to configure the note length, expressed as a ratio of the period.
    * Must be between 1/32 and 8.
    *
    * @since API version 10
    */
   @OscNode
   SettableDoubleValue gateLength();

   /**
    * Let the arpeggiator play overlapping notes.
    *
    * @since API version 11
    */
   @OscNode
   SettableBooleanValue enableOverlappingNotes();

   /**
    * Will use the note pressure to determine the velocity of arpeggiated notes.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue usePressureToVelocity();

   /**
    * Release all notes being played.
    * @since API version 10
    */
   @OscMethod
   void releaseNotes();

   /**
    * Will introduce human-like errors.
    * Between 0 and 1.
    *
    * @since API version 11
    */
   @OscNode
   SettableDoubleValue humanize();

   /**
    * If set to true, it will terminate the playing note as soon as it is released, otherwise it will
    * be held until its computed note-off time.
    *
    * @since API version 11
    */
   @OscNode
   SettableBooleanValue terminateNotesImmediately();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface are used to navigate a column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserItemBank<ItemType extends BrowserItem> extends Bank<ItemType>
{
   /**
    * Returns the window size that was used to configure the filter column during creation.
    *
    * @return the size of the filter column.
    * @since API version 1
    * @deprecated Use {@link #getSizeOfBank()} instead.
    */
   @Deprecated
   int getSize();

   /**
    * Returns the item for the given index.
    *
    * @param index
    *           the item index, must be in the range `[0..getSize-1]`
    * @return the requested item object
    * @since API version 1
    * @deprecated Use {@link #getItemAt(int)} instead.
    */
   @Deprecated
   BrowserItem getItem(int index);

   /**
    * Scrolls the filter column entries one item up.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollBackwards()} instead.
    */
   @Deprecated
   void scrollUp();

   /**
    * Scrolls the filter column entries one item down.
    *
    * @since API version 1
    * @deprecated Use {@link #scrollForwards()} instead.
    */
   @Deprecated
   void scrollDown();

   /**
    * Scrolls the filter column entries one page up. For example if the column is configured with a window
    * size of 8 entries and is currently showing items [1..8], calling this method would scroll the column to
    * show items [9..16].
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageBackwards()} instead.
    */
   @Deprecated
   void scrollPageUp();

   /**
    * Scrolls the filter column entries one page up. For example if the column is configured with a window
    * size of 8 entries and is currently showing items [9..16], calling this method would scroll the column to
    * show items [1..8].
    *
    * @since API version 1
    * @deprecated Use {@link #scrollPageForwards()} instead.
    */
   @Deprecated
   void scrollPageDown();

   /**
    * Registers an observer that reports the current scroll position, more specifically the position of the
    * first item within the underlying list of entries, that is shown as the first entry within the window.
    *
    * @param callback
    *           a callback function that receives a single integer number parameter. The parameter reflects
    *           the scroll position, or `-1` in case the column has no content.
    * @since API version 1
    * @deprecated Use {@link #scrollPosition()} instead.
    */
   @Deprecated
   void addScrollPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports if the column entries can be scrolled further up.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollBackwards()} instead.
    */
   @Deprecated
   void addCanScrollUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the column entries can be scrolled further down.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollForwards()} instead.
    */
   @Deprecated
   void addCanScrollDownObserver(BooleanValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Interface for an object that can be 'subscribed' or not. A subscribed object will notify any observers when
 * changes occur to it. When it is unsubscribed the observers will no longer be notified. A driver can use
 * this to say which objects it is interested in and which ones it is not (for example in one mode the driver
 * may not be interested in track meters) at runtime. This allows the driver to improve efficiency by only
 * getting notified about changes that are really relevant to it. By default a driver is subscribed to
 * everything.
 *
 * Subscription is counter based.
 *
 * @since API version 2
 */
public interface Subscribable
{
   /**
    * Determines if this object is currently 'subscribed'. In the subscribed state it will notify any
    * observers registered on it.
    */
   boolean isSubscribed();

   /**
    * Sets whether the driver currently considers this object 'active' or not.
    * @deprecated subscribe/unsubscribe is now counter based.
    */
   @OscMethod
   @Deprecated
   void setIsSubscribed(boolean value);

   /**
    * Subscribes the driver to this object.
    */
   @OscMethod
   void subscribe();

   /**
    * Unsubscribes the driver from this object.
    */
   @OscMethod
   void unsubscribe();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Supplier;

import com.bitwig.extension.api.Color;

/**
 * Represents a physical hardware light on a controller. The light has an on/off state and may also be
 * optionally colored.
 *
 * @since API version 10
 */
public interface MultiStateHardwareLight extends HardwareLight
{
   /**
    * Object that represents the current state of this light. The interpretation of this value is entirely up
    * to the implementation.
    */
   ObjectHardwareProperty<InternalHardwareLightState> state();

   /**
    * Sets a function that can be used to convert a color to the closest possible state representing that
    * color. Once this function has been provided it is possible to then use the convenient
    * {@link #setColor(Color)} and {@link #setColorSupplier(Supplier)} methods.
    */
   void setColorToStateFunction(Function<Color, InternalHardwareLightState> function);

   /**
    * Tries to set this light's state to be the best state to represent the supplied {@link Color}. For this
    * to be used you must first call {@link #setColorToStateFunction(IntFunction)}.
    */
   void setColor(Color color);

   /**
    * Tries to set this light's state to be the best state to represent the value supplied by the
    * {@link Supplier}. For this to be used you must first call {@link #setColorToStateFunction(IntFunction)}.
    */
   void setColorSupplier(Supplier<Color> colorSupplier);

   /**
    * Determines the best light state for the supplied color. For this to be used you must first call
    * {@link #setColorToStateFunction(IntFunction)}.
    */
   InternalHardwareLightState getBestLightStateForColor(Color color);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to navigate a results column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserResultsColumn extends BrowserColumn
{
   /**
    * Returns the cursor result item, which can be used to navigate over the list of entries.
    *
    * @return the requested filter item object
    * @since API version 1
    */
   @Override
   BrowserResultsItem createCursorItem();

   /**
    * Returns an object that provides access to a bank of successive entries using a window configured with
    * the given size, that can be scrolled over the list of entries.
    *
    * @param size
    *           the number of simultaneously accessible items
    * @return the requested item bank object
    */
   @Override
   BrowserResultsItemBank createItemBank(int size);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

public interface ClipLauncherSlot extends ClipLauncherSlotOrScene
{
   /**
    * Value that reports whether this slot is selected or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isSelected();

   /**
    * Value that reports whether this slot has content or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue hasContent();

   /**
    * Value that reports whether this slot is playing or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isPlaying();

   /**
    * Value that reports whether this slot is queued for playback or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isPlaybackQueued();

   /**
    * Value that reports whether this slot is recording or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isRecording();

   /**
    * Value that reports whether this slot is queued for recording or not.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isRecordingQueued();

   /**
    * Value that reports true if the slot has a clip playing and the track is queued for stop.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue isStopQueued();

   /**
    * Starts browsing for content that can be inserted in this slot in Bitwig Studio's popup browser.
    *
    * @since API version 2
    */
   void browseToInsertClip();

   /**
    * Value that reports the color of this slot.
    *
    * @since API version 2
    */
   @OscNode
   SettableColorValue color();

   /**
    * Selects the slot.
    *
    * @since API version 10
    */
   @OscMethod
   void select();

   /**
    * @since API version 10
    */
   HardwareActionBindable selectAction();

   /**
    * Start recording a clip.
    *
    * @since API version 10
    */
   @OscMethod
   void record();

   /**
    * @since API version 10
    */
   HardwareActionBindable recordAction();

   /**
    * Makes the clip content of the slot visible in the note or audio editor.
    *
    * @since API version 10
    */
   @OscMethod
   void showInEditor();

   /**
    * Creates an new clip.
    *
    * @since API version 10
    */
   @OscMethod
   void createEmptyClip(int lengthInBeats);

   /**
    * Duplicates the clip.
    *
    * @since API version 10
    */
   @OscMethod
   void duplicateClip();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing multi-samples, including access to all filter columns and
 * the result column as shown in the 'Multi-Samples' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface MultiSampleBrowsingSession extends BrowsingSession
{
   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.controller.ControllerExtensionDefinition;
import com.bitwig.extension.controller.HardwareDeviceMatcher;
import com.bitwig.extension.controller.HardwareDeviceMatcherList;

/**
 * Represents a hardware device that the user has chosen to communicate with. The hardware devices that the
 * user needs to choose are defined by the
 * {@link ControllerExtensionDefinition#listHardwareDevices(HardwareDeviceMatcherList)} method.
 *
 * @since API version 7
 */
public interface HardwareDevice
{
   /**
    * The {@link HardwareDeviceMatcher} that was provided by the controller for identifying this hardware
    * device in {@link ControllerExtensionDefinition#listHardwareDevices(HardwareDeviceMatcherList)}.
    *
    */
   HardwareDeviceMatcher deviceMatcher();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent the cursor item in device layer selections.
 *
 * @since API version 1
 */
public interface CursorDeviceLayer extends CursorChannel, DeviceLayer
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.DoubleValueChangedCallback;
import com.bitwig.extension.callback.EnumValueChangedCallback;

/**
 * An interface representing the transport section in Bitwig Studio.
 *
 * @since API version 1
 */
public interface Transport extends ObjectProxy
{
   /**
    * Starts playback in the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void play();

   /**
    * Continues the playback in the Bitwig Studio transport.
    *
    * @since API version 10
    */
   void continuePlayback();

   /**
    * Action that can be used to play the transport.
    *
    * @see #play()
    *
    * @since API version 10
    * */
   HardwareActionBindable playAction();

   /**
    * Action that can be used to continue the transport.
    *
    * @see #continuePlayback()
    *
    * @since API version 10
    * */
   HardwareActionBindable continuePlaybackAction();

   /**
    * Stops playback in the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void stop();

   /**
    * Action that can be used to stop the transport.
    *
    * @see #stop()
    *
    * @since API version 10
    * */
   HardwareActionBindable stopAction();

   /**
    * Toggles the transport playback state between playing and stopped.
    *
    * @since API version 1
    */
   @OscMethod
   void togglePlay();

   /**
    * When the transport is stopped, calling this function starts transport playback, otherwise the transport
    * is first stopped and the playback is restarted from the last play-start position.
    *
    * @since API version 1
    */
   @OscMethod
   void restart();

   /**
    * Action that can be used to restart the transport.
    *
    * @see #restart()
    *
    * @since API version 10
    * */
   HardwareActionBindable restartAction();

   /**
    * Starts recording in the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void record();

   /**
    * Action that can be used to start recording
    *
    * @see #record()
    *
    * @since API version 10
    * */
   HardwareActionBindable recordAction();

   /**
    * Rewinds the Bitwig Studio transport to the beginning of the arrangement.
    *
    * @since API version 1
    */
   @OscMethod
   void rewind();

   /**
    * Action that can be used to rewind the transport.
    *
    * @see #rewind()
    *
    * @since API version 10
    * */
   HardwareActionBindable rewindAction();

   /**
    * Calling this function is equivalent to pressing the fast forward button in the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void fastForward();

   /**
    * Action that can be used to fast forward the transport.
    *
    * @see #fastForward()
    *
    * @since API version 10
    * */
   HardwareActionBindable fastForwardAction();

   /**
    * When calling this function multiple times, the timing of those calls gets evaluated and causes
    * adjustments to the project tempo.
    *
    * @since API version 1
    */
   @OscMethod
   void tapTempo();

   /**
    * Action that can be used to tap the tempo.
    *
    * @see #tapTempo()
    *
    * @since API version 10
    * */
   HardwareActionBindable tapTempoAction();

   /**
    * Value that reports if the Bitwig Studio transport is playing.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isPlaying();

   /**
    * Registers an observer that reports if the Bitwig Studio transport is playing.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if playing, `false`
    *           otherwise).
    * @since API version 1
    * @deprecated Use {@link #isPlaying()} instead.
    */
   @Deprecated
   void addIsPlayingObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the Bitwig Studio transport is recording.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isArrangerRecordEnabled();

   /**
    * Registers an observer that reports if the Bitwig Studio transport is recording.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if recording, `false`
    *           otherwise).
    * @since API version 1
    * @deprecated Use {@link #isArrangerRecordEnabled()} instead.
    */
   @Deprecated
   void addIsRecordingObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if overdubbing is enabled in Bitwig Studio.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isArrangerOverdubEnabled();

   /**
    * Registers an observer that reports if over-dubbing is enabled in Bitwig Studio.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if over-dubbing is
    *           enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isArrangerOverdubEnabled()} instead.
    */
   @Deprecated
   void addOverdubObserver(BooleanValueChangedCallback callback);

   /**
    * Value reports if clip launcher overdubbing is enabled in Bitwig Studio.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isClipLauncherOverdubEnabled();

   /**
    * Registers an observer that reports if clip launcher over-dubbing is enabled in Bitwig Studio.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if clip launcher
    *           over-dubbing is enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isClipLauncherOverdubEnabled()} instead.
    */
   @Deprecated
   void addLauncherOverdubObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the current automation write mode. Possible values are `"latch"`, `"touch"` or
    * `"write"`.
    *
    * @since API version 2
    */
   @OscNode
   SettableEnumValue automationWriteMode();

   /**
    * Registers an observer that reports the current automation write mode.
    *
    * @param callback
    *           a callback function that receives a single string argument. Possible values are `"latch"`,
    *           `"touch"` or `"write"`.
    * @since API version 1
    * @deprecated Use {@link #automationWriteMode()} instead.
    */
   @Deprecated
   void addAutomationWriteModeObserver(EnumValueChangedCallback callback);

   /**
    * Value that reports if automation write is currently enabled for the arranger.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isArrangerAutomationWriteEnabled();

   /**
    * Registers an observer that reports if Bitwig Studio is currently writing arranger automation.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when arranger automation
    *           write is enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isArrangerAutomationWriteEnabled()} instead.
    */
   @Deprecated
   void addIsWritingArrangerAutomationObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if automation write is currently enabled on the clip launcher.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isClipLauncherAutomationWriteEnabled();

   /**
    * Registers an observer that reports if Bitwig Studio is currently writing clip launcher automation.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when clip launcher
    *           automation write is enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isClipLauncherAutomationWriteEnabled()} instead.
    */
   @Deprecated
   void addIsWritingClipLauncherAutomationObserver(BooleanValueChangedCallback callback);

   /**
    * Value that indicates if automation override is currently on.
    *
    * @since API version 2
    */
   BooleanValue isAutomationOverrideActive();

   /**
    * Registers an observer that reports if automation is overridden in Bitwig Studio.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if overridden, `false`
    *           otherwise).
    * @since API version 1
    * @deprecated Use {@link #isAutomationOverrideActive()}.addValueObserver(callback)
    */
   @Deprecated
   void addAutomationOverrideObserver(BooleanValueChangedCallback callback);

   /**
    * Value that indicates if the loop is currently active or not.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isArrangerLoopEnabled();

   /**
    * Value that corresponds to the start time of the arranger loop
    *
    * @since API version 15
    */
   @OscNode
   SettableBeatTimeValue arrangerLoopStart();

   /**
    * Value that corresponds to the duration of the arranger loop
    *
    * @since API version 15
    */
   @OscNode
   SettableBeatTimeValue arrangerLoopDuration();

   /**
    * Registers an observer that reports if arranger looping is enabled in Bitwig Studio.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when enabled, `false`
    *           otherwise).
    * @since API version 1
    * @deprecated Use {@link #isArrangerLoopEnabled()}.addValueObserver(callback)
    */
   @Deprecated
   void addIsLoopActiveObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if punch-in is enabled in the Bitwig Studio transport.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isPunchInEnabled();

   /**
    * Registers an observer that reports if punch-in is enabled in the Bitwig Studio transport.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when punch-in is enabled,
    *           `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isPunchInEnabled()} instead.
    */
   @Deprecated
   void addPunchInObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if punch-in is enabled in the Bitwig Studio transport.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isPunchOutEnabled();

   /**
    * Registers an observer that reports if punch-out is enabled in the Bitwig Studio transport.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when punch-out is enabled,
    *           `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isPunchOutEnabled()} instead.
    */
   @Deprecated
   void addPunchOutObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the metronome is enabled in Bitwig Studio.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isMetronomeEnabled();

   /**
    * Registers an observer that reports if the metronome is enabled in Bitwig Studio.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` when the metronome is
    *           enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isMetronomeEnabled()} instead.
    */
   @Deprecated
   void addClickObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the metronome has tick playback enabled.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isMetronomeTickPlaybackEnabled();

   /**
    * Registers an observer that reports if the metronome has tick playback enabled.
    *
    * @param callback
    *           a callback function that receives a single boolean argument (`true` if metronome ticks, are
    *           enabled, `false` otherwise).
    * @since API version 1
    * @deprecated Use {@link #isMetronomeTickPlaybackEnabled()} instead.
    */
   @Deprecated
   void addMetronomeTicksObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the metronome volume.
    *
    * @since API version 2
    */
   @OscNode
   SettableRangedValue metronomeVolume();

   /**
    * Registers an observer that reports the metronome volume.
    *
    * @param callback
    *           a callback function that receives a single numeric argument.
    * @since API version 1
    * @deprecated Use {@link #metronomeVolume()} instead.
    */
   @Deprecated
   void addMetronomeVolumeObserver(DoubleValueChangedCallback callback);

   /**
    * Value that reports if the metronome is audible during pre-roll.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isMetronomeAudibleDuringPreRoll();

   /**
    * Registers an observer that reports if the metronome is audible during pre-roll.
    *
    * @param callback
    *           a callback function that receives a single boolean argument.
    * @since API version 1
    * @deprecated Use {@link #isMetronomeAudibleDuringPreRoll()} instead.
    */
   @Deprecated
   void addPreRollClickObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the current pre-roll setting. Possible values are `"none"`, `"one_bar"`,
    * `"two_bars"`, or `"four_bars"`.
    *
    * @since API version 2
    */
   @OscNode
   SettableEnumValue preRoll();

   /**
    * Registers an observer that reports the current pre-roll setting.
    *
    * @param callback
    *           a callback function that receives a single string argument. Possible values are `"none"`,
    *           `"one_bar"`, `"two_bars"`, or `"four_bars"`.
    * @since API version 1
    * @deprecated Use {@link #preRoll()} instead.
    */
   @Deprecated
   void addPreRollObserver(EnumValueChangedCallback callback);

   /**
    * Toggles the enabled state of the arranger loop in Bitwig Studio.
    *
    * @since API version 1
    * @deprecated Use {@link #isArrangerLoopEnabled()} instead.
    */
   @Deprecated
   void toggleLoop();

   /**
    * Enables of disables the arranger loop according to the given parameter.
    *
    * @param isEnabled
    *           `true` to enable the arranger loop, `false` otherwise
    * @since API version 1
    * @deprecated Use {@link #isArrangerLoopEnabled()} instead.
    */
   @Deprecated
   void setLoop(boolean isEnabled);

   /**
    * Toggles the punch-in enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    * @deprecated Use {@link #isPunchInEnabled()} instead.
    */
   @Deprecated
   void togglePunchIn();

   /**
    * Toggles the punch-out enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    * @deprecated Use {@link #isPunchOutEnabled()} instead.
    */
   @Deprecated
   void togglePunchOut();

   /**
    * Toggles the metronome enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    * @deprecated Use {@link #isMetronomeEnabled()} instead.
    */
   @Deprecated
   void toggleClick();

   /**
    * Enables of disables the metronome according to the given parameter.
    *
    * @param isEnabled
    *           `true` to enable the metronome, `false` otherwise
    * @since API version 1
    * @deprecated Use {@link #isMetronomeEnabled()} instead.
    */
   @Deprecated
   void setClick(boolean isEnabled);

   /**
    * Toggles the enabled state of the metronome ticks.
    *
    * @since API version 1
    * @deprecated Use {@link #isMetronomeTickPlaybackEnabled()} instead.
    */
   @Deprecated
   void toggleMetronomeTicks();

   /**
    * Toggles the enabled state of the metronome during pre-roll.
    *
    * @since API version 1
    * @deprecated Use {@link #isMetronomeAudibleDuringPreRoll()} instead.
    */
   @Deprecated
   void toggleMetronomeDuringPreRoll();

   /**
    * Updates the transport pre-roll setting according to the given parameter.
    *
    * @param value
    *           the new pre-roll setting, either `"none"`, `"one_bar"`, `"two_bars"`, or `"four_bars"`.
    * @since API version 1
    * @deprecated Use {@link #preRoll()} instead.
    */
   @Deprecated
   void setPreRoll(String value);

   /**
    * Sets the metronome volume.
    *
    * @param amount
    *           the new metronome volume relative to the specified range. Values should be in the range
    *           [0..range-1].
    * @param range
    *           the range of the provided amount value
    * @since API version 1
    * @deprecated Use {@link #metronomeVolume()} instead.
    */
   @Deprecated
   void setMetronomeValue(Number amount, Number range);

   /**
    * Toggles the over-dubbing enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    * @deprecated Use {@link #isArrangerOverdubEnabled()} instead.
    */
   @Deprecated
   void toggleOverdub();

   /**
    * Enables of disables arranger over-dubbing according to the given parameter.
    *
    * @param isEnabled
    *           `true` to enable over-dubbing, `false` otherwise
    * @since API version 1
    * @deprecated Use {@link #isArrangerOverdubEnabled()} instead.
    */
   @Deprecated
   void setOverdub(boolean isEnabled);

   /**
    * Toggles clip launcher overdubbing in Bitwig Studio.
    *
    * @since API version 1
    * @deprecated Use {@link #isClipLauncherOverdubEnabled()} instead.
    */
   @Deprecated
   void toggleLauncherOverdub();

   /**
    * Enables of disables clip launcher over-dubbing according to the given parameter.
    *
    * @param isEnabled
    *           `true` to enable the over-dubbing, `false` otherwise
    * @since API version 1
    * @deprecated Use {@link #isClipLauncherOverdubEnabled()} instead.
    */
   @Deprecated
   void setLauncherOverdub(boolean isEnabled);

   /**
    * Sets the automation write mode.
    *
    * @param mode
    *           the string that identifies the new automation write mode. Possible values are `"latch"`,
    *           `"touch"` or `"write"`.
    * @since API version 1
    * @deprecated Use {@link #automationWriteMode()} instead.
    */
   @Deprecated
   void setAutomationWriteMode(String mode);

   /**
    * Toggles the latch automation write mode in the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void toggleLatchAutomationWriteMode();

   /**
    * Toggles the arranger automation write enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void toggleWriteArrangerAutomation();

   /**
    * Toggles the clip launcher automation write enabled state of the Bitwig Studio transport.
    *
    * @since API version 1
    */
   @OscMethod
   void toggleWriteClipLauncherAutomation();

   /**
    * Resets any automation overrides in Bitwig Studio.
    *
    * @since API version 1
    */
   @OscMethod
   void resetAutomationOverrides();

   /**
    * Switches playback to the arrangement sequencer on all tracks.
    *
    * @since API version 1
    */
   @OscMethod
   void returnToArrangement();

   /**
    * Returns an object that provides access to the project tempo.
    *
    * @return the requested tempo value object
    * @since API version 1
    * @deprecated Use {@link #tempo()} instead.
    */
   @Deprecated
   Parameter getTempo();

   /**
    * Returns an object that provides access to the project tempo.
    *
    * @return the requested tempo value object
    * @since API version 1
    */
   @OscNode
   Parameter tempo();

   /**
    * Increases the project tempo value by the given amount, which is specified relative to the given range.
    *
    * @param amount
    *           the new tempo value relative to the specified range. Values should be in the range
    *           [0..range-1].
    * @param range
    *           the range of the provided amount value
    * @since API version 1
    */
   void increaseTempo(Number amount, Number range);

   /**
    * Returns an object that provides access to the transport position in Bitwig Studio.
    *
    * @return a beat time object that represents the transport position
    * @since API version 1
    */
   @OscNode()
   SettableBeatTimeValue getPosition();

   /**
    * Returns an object that provides access to the current transport position.
    *
    * @return beat-time value
    * @since API version 10
    */
   @OscNode()
   BeatTimeValue playPosition();

   /**
    * Returns an object that provides access to the current transport position in seconds.
    *
    * @return value (seconds)
    * @since API version 10
    */
   @OscNode()
   DoubleValue playPositionInSeconds();

   /**
    * Returns an object that provides access to the transport's play-start position. (blue triangle)
    *
    * @return beat-time value
    * @since API version 10
    */
   @OscNode()
   SettableBeatTimeValue playStartPosition();

   /**
    * Returns an object that provides access to the transport's play-start position in seconds. (blue triangle)
    *
    * @return value (seconds)
    * @since API version 10
    */
   @OscNode()
   SettableDoubleValue playStartPositionInSeconds();

   /**
    * Make the transport jump to the play-start position.
    *
    * @since API version 10
    */
   void launchFromPlayStartPosition();

   HardwareActionBindable launchFromPlayStartPositionAction();

   /**
    * Make the transport jump to the play-start position.
    *
    * @since API version 10
    */
   void jumpToPlayStartPosition();

   HardwareActionBindable jumpToPlayStartPositionAction();

   /**
    * Make the transport jump to the previous cue marker.
    *
    * @since API version 10
    */
   void jumpToPreviousCueMarker();

   HardwareActionBindable jumpToPreviousCueMarkerAction();


   /**
    * Make the transport jump to the previous cue marker.
    *
    * @since API version 10
    */
   void jumpToNextCueMarker();

   HardwareActionBindable jumpToNextCueMarkerAction();

   /**
    * Sets the transport playback position to the given beat time value.
    *
    * @param beats
    *           the new playback position in beats
    * @since API version 1
    */
   @OscMethod
   void setPosition(double beats);

   /**
    * Increases the transport position value by the given number of beats, which is specified relative to the
    * given range.
    *
    * @param beats
    *           the beat time value that gets added to the current transport position. Values have double
    *           precision and can be positive or negative.
    * @param snap
    *           when `true` the actual new transport position will be quantized to the beat grid, when `false`
    *           the position will be increased exactly by the specified beat time
    * @since API version 1
    */
   @OscMethod
   void incPosition(double beats, boolean snap);

   /**
    * Returns an object that provides access to the punch-in position in the Bitwig Studio transport.
    *
    * @return a beat time object that represents the punch-in position
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getInPosition();

   /**
    * Returns an object that provides access to the punch-out position in the Bitwig Studio transport.
    *
    * @return a beat time object that represents the punch-out position
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getOutPosition();

   /**
    * Adds a cue marker at the current position
    *
    * @since API version 15
    */
   @OscMethod
   void addCueMarkerAtPlaybackPosition();

   HardwareActionBindable addCueMarkerAtPlaybackPositionAction();

   /**
    * Returns an object that provides access to the cross-fader, used for mixing between A/B-channels as
    * specified on the Bitwig Studio tracks.
    *
    * @see Track#getCrossFadeMode()
    * @since API version 1
    * @deprecated Use {@link #crossfade()} instead.
    */
   @Deprecated
   Parameter getCrossfade();

   /**
    * Returns an object that provides access to the cross-fader, used for mixing between A/B-channels as
    * specified on the Bitwig Studio tracks.
    *
    * @see Track#getCrossFadeMode()
    * @since API version 5
    */
   @OscNode
   Parameter crossfade();

   /**
    * Returns an object that provides access to the transport time signature.
    *
    * @return the time signature value object that represents the transport time signature.
    * @since API version 1
    * @deprecated Use {@link #timeSignature()} instead.
    */
   @Deprecated
   TimeSignatureValue getTimeSignature();

   /**
    * Returns an object that provides access to the transport time signature.
    *
    * @return the time signature value object that represents the transport time signature.
    * @since API version 5
    */
   @OscNode
   TimeSignatureValue timeSignature();

   /**
    * Value that reports the current clip launcher post recording action. Possible values are `"off"`,
    * `"play_recorded"`, `"record_next_free_slot"`, `"stop"`, `"return_to_arrangement"`,
    * `"return_to_previous_clip"` or `"play_random"`.
    *
    * @since API version 2
    */
   SettableEnumValue clipLauncherPostRecordingAction();

   /**
    * Registers an observer that reports the current clip launcher post recording action.
    *
    * @param callback
    *           a callback function that receives a single string argument. Possible values are `"off"`,
    *           `"play_recorded"`, `"record_next_free_slot"`, `"stop"`, `"return_to_arrangement"`,
    *           `"return_to_previous_clip"` or `"play_random"`.
    * @since API version 1
    * @deprecated Use {@link #clipLauncherPostRecordingAction()} instead.
    */
   @Deprecated
   void addClipLauncherPostRecordingActionObserver(EnumValueChangedCallback callback);

   /**
    * Sets the automation write mode.
    *
    * @param action
    *           the string that identifies the new automation write mode. Possible values are `"off"`,
    *           `"play_recorded"`, `"record_next_free_slot"`, `"stop"`, `"return_to_arrangement"`,
    *           `"return_to_previous_clip"` or `"play_random"`.
    * @since API version 1
    * @deprecated Use {@link #clipLauncherPostRecordingAction()} instead.
    */
   @Deprecated
   void setClipLauncherPostRecordingAction(String action);

   /**
    * Returns an object that provides access to the clip launcher post recording time offset.
    *
    * @return a beat time object that represents the post recording time offset
    * @since API version 1
    */
   SettableBeatTimeValue getClipLauncherPostRecordingTimeOffset();

   /**
    * Setting for the default launch quantization.
    *
    * Possible values are `"none"`, `"8"`, `"4"`, `"2"`, `"1"`, `"1/2"`, `"1/4"`, `"1/8"`, `"1/16"`.
    *
    * @since API version 8
    */
   @OscNode
   SettableEnumValue defaultLaunchQuantization();

   /**
    * Value that indicates if the project's fill mode is active or not.
    *
    * @since API version 14
    */
   @OscNode
   SettableBooleanValue isFillModeActive();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a hardware light. There are 2 kinds of lights: {@link OnOffHardwareLight} and
 * {@link MultiStateHardwareLight}.
 *
 * @since API version 10
 */
public interface HardwareLight extends HardwareOutputElement
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a display on some hardware that shows one or more lines of text.
 *
 * @since API version 10
 */
public interface HardwareTextDisplay extends HardwareOutputElement
{
   /** The line at the supplied line index. */
   HardwareTextDisplayLine line(int line);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical hardware element that displays some output to the user.
 *
 * For example, a light, some text etc
 *
 * @since API version 10
 */
public interface HardwareOutputElement extends HardwareElement
{
   /**
    * Sets an optional callback for this element whenever it's state needs to be sent to the hardware. This
    * will be called when calling {@link HardwareSurface#updateHardware()} if the state needs to be sent.
    */
   void onUpdateHardware(Runnable sendStateRunnable);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * A cue marker bank provides access to a range of cue markers in Bitwig Studio.
 * Instances are typically configured with a fixed number of markers and represent an excerpt
 * of a larger list of markers. It basically acts like a window moving over the list of markers.
 *
 * @since API version 2
 */
public interface CueMarkerBank extends Bank<CueMarker>
{
   /**
    * Scrolls the cue marker bank window so that the marker at the given position becomes visible.
    *
    * @param position
    *           the index of the marker within the underlying full list of markers (not the index within the
    *           bank). The position is typically directly related to the layout of the marker list in Bitwig
    *           Studio, starting with zero in case of the first marker.
    * @since API version 2
    */
   void scrollToMarker(int position);
}
-e 


package com.bitwig.extension.controller.api;

import java.io.IOException;

import com.bitwig.extension.callback.ConnectionEstablishedCallback;
import com.bitwig.extension.callback.DataReceivedCallback;
import com.bitwig.extension.callback.NoArgsCallback;

/**
 * Instances of this interface are reported to the supplied script callback when connecting to a remote TCP
 * socket via {@link ControllerHost#connectToRemoteHost}.
 *
 * @see ControllerHost#connectToRemoteHost(String, int, ConnectionEstablishedCallback)
 * @since API version 1
 */
public interface RemoteConnection
{
   /**
    * Disconnects from the remote host.
    *
    * @since API version 1
    */
   void disconnect();

   /**
    * Registers a callback function that gets called when the connection gets lost or disconnected.
    *
    * @param callback
    *           a callback function that doesn't receive any parameters
    * @since API version 1
    */
   void setDisconnectCallback(NoArgsCallback callback);

   /**
    * Sets the callback used for receiving data.
    *
    * The remote connection needs a header for each message sent to it containing a 32-bit big-endian integer
    * saying how big the rest of the message is. The data delivered to the script will not include this
    * header.
    *
    * @param callback
    *           a callback function with the signature `(byte[] data)`
    * @since API version 1
    */
   void setReceiveCallback(DataReceivedCallback callback);

   /**
    * Sends data to the remote host.
    *
    * @param data
    *           the byte array containing the data to be sent. When creating a numeric byte array in
    *           JavaScript, the byte values must be signed (in the range -128..127).
    * @throws IOException
    * @since API version 1
    */
   void send(byte[] data) throws IOException;
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.BooleanSupplier;
import java.util.function.IntConsumer;
import java.util.function.IntSupplier;

/**
 * Represents an output value shown on some hardware.
 *
 * @since API version 10
 * */
public interface IntegerHardwareProperty extends HardwareProperty
{
   /** Gets the current value. This is the value that should be sent to the hardware to be displayed. */
   int currentValue();

   /** The value that was last sent to the hardware. */
   int lastSentValue();

   /**
    * Specifies a callback that should be called with the value that needs to be sent to the hardware. This
    * callback is called as a result of calling the {@link HardwareSurface#updateHardware()} method (typically
    * from the flush method).
    */
   void onUpdateHardware(IntConsumer sendValueConsumer);

   /** Sets the current value. */
   void setValue(int value);

   /** Sets the current value from a {@link BooleanSupplier} that supplies the latest value. */
   void setValueSupplier(IntSupplier supplier);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.DoubleSupplier;

import com.bitwig.extension.callback.DoubleValueChangedCallback;

/**
 * Instances of this interface represent double values.
 * @since API version 2
 */
public interface DoubleValue extends Value<DoubleValueChangedCallback>, DoubleSupplier
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   double get();

   @Override
   default double getAsDouble()
   {
      return get();
   }
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Shared functions between `Arranger` and `DetailEditor`
 */
public interface TimelineEditor
{
   /**
    * Zooms in the timeline, if the timeline editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInAction();

   void zoomIn();

   /**
    * Zooms out the timeline, if the timeline editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutAction();

   void zoomOut();

   /**
    * Smoothly adjusts the zoom level
    */
   RelativeHardwarControlBindable zoomLevel();

   /**
    * Adjusts the zoom level of the timeline so that all content becomes visible, if the timeline editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomToFitAction();

   void zoomToFit();

   /**
    * Adjusts the zoom level of the timeline so that it matches the active selection, if the timeline editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomToSelectionAction();

   void zoomToSelection();

   /**
    * Toggles the timeline between zoomToSelection and zoomToFit, if it is visible.
    *
    * @since API version 18
    */
   HardwareActionBindable zoomToFitSelectionOrAllAction();

   void zoomToFitSelectionOrAll();

   /**
    * Toggles the timeline between zoomToSelection and the last et zoom level, if it is visible.
    *
    * @since API version 18
    */
   HardwareActionBindable zoomToFitSelectionOrPreviousAction();

   void zoomToFitSelectionOrPrevious();

   /**
    * Get the horizontal (time) scrollbar model.
    *
    * @since API version 21
    */
   ScrollbarModel getHorizontalScrollbarModel();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.Objects;

import com.bitwig.extension.api.Color;

/**
 * Defines the visual state of a hardware light so that it can be visualized in Bitwig Studio's user
 * interface.
 *
 * This is currently only used when simulating hardware when it is not present for debugging but it may be
 * used for other purposes in the future.
 *
 * @since API version 10
 */
public class HardwareLightVisualState
{
   private static Color defaultLabelColorForLightColor(final Color lightColor)
   {
      if (lightColor == null)
         return Color.whiteColor();

      final double total = lightColor.getRed() + lightColor.getGreen() + lightColor.getBlue();

      return total >= 1.5 ? Color.blackColor() : Color.whiteColor();
   }

   public static HardwareLightVisualState createForColor(final Color color)
   {
      return createForColor(color, defaultLabelColorForLightColor(color));
   }

   public static HardwareLightVisualState createForColor(final Color color, final Color labelColor)
   {
      return new HardwareLightVisualState(color, null, labelColor, null, 0, 0);
   }

   public static HardwareLightVisualState createBlinking(
      final Color onColor,
      final Color offColor,
      final double onBlinkTimeInSec,
      final double offBlinkTimeInSec)
   {
      return new HardwareLightVisualState(onColor, offColor, defaultLabelColorForLightColor(onColor),
         defaultLabelColorForLightColor(offColor), onBlinkTimeInSec, offBlinkTimeInSec);
   }

   public static HardwareLightVisualState createBlinking(
      final Color onColor,
      final Color offColor,
      final Color labelOnColor,
      final Color labelOffColor,
      final double onBlinkTimeInSec,
      final double offBlinkTimeInSec)
   {
      return new HardwareLightVisualState(onColor, offColor, labelOnColor, labelOffColor, onBlinkTimeInSec,
         offBlinkTimeInSec);
   }

   private HardwareLightVisualState(
      final Color color,
      final Color offColor,
      final Color labelColor,
      final Color labelBlinkOffColor,
      final double onBlinkTime,
      final double offBlinkTime)
   {
      super();
      mColor = color;
      mBlinkOffColor = offColor;
      mLabelColor = labelColor;
      mLabelBlinkOffColor = labelBlinkOffColor;
      mOnBlinkTime = onBlinkTime;
      mOffBlinkTime = offBlinkTime;
   }

   public boolean isBlinking()
   {
      return mBlinkOffColor != null;
   }

   public Color getColor()
   {
      return mColor;
   }

   public Color getBlinkOffColor()
   {
      return mBlinkOffColor;
   }

   public double getOffBlinkTime()
   {
      return mOffBlinkTime;
   }

   public double getOnBlinkTime()
   {
      return mOnBlinkTime;
   }

   public Color getLabelColor()
   {
      return mLabelColor;
   }

   public Color getLabelBlinkOffColor()
   {
      return mLabelBlinkOffColor;
   }

   @Override
   public int hashCode()
   {
      return Objects.hash(mBlinkOffColor, mColor, mLabelBlinkOffColor, mLabelColor, mOffBlinkTime,
         mOnBlinkTime);
   }

   @Override
   public boolean equals(final Object obj)
   {
      if (this == obj)
         return true;

      if (obj == null)
         return false;

      if (getClass() != obj.getClass())
         return false;

      final HardwareLightVisualState other = (HardwareLightVisualState)obj;

      return Objects.equals(mBlinkOffColor, other.mBlinkOffColor) && Objects.equals(mColor, other.mColor)
         && Objects.equals(mLabelBlinkOffColor, other.mLabelBlinkOffColor)
         && Objects.equals(mLabelColor, other.mLabelColor)
         && Double.doubleToLongBits(mOffBlinkTime) == Double.doubleToLongBits(other.mOffBlinkTime)
         && Double.doubleToLongBits(mOnBlinkTime) == Double.doubleToLongBits(other.mOnBlinkTime);
   }

   private final Color mColor, mBlinkOffColor, mLabelColor, mLabelBlinkOffColor;

   private final double mOnBlinkTime, mOffBlinkTime;
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.Color;

/**
 * Represents some physical hardware element. Hardware elements can be {@link HardwareControl}s (e.g. buttons,
 * sliders etc) or {@link HardwareOutputElement}s (e.g lights, text displays etc).
 *
 * @since API version 10
 */
public interface HardwareElement
{
   /** The unique id associated with this element. */
   String getId();

   /** An optional label associated with this element. */
   String getLabel();

   /** Sets the label for this hardware control as written on the hardware. */
   void setLabel(String label);

   /** The color of the label. */
   Color getLabelColor();

   /** Sets the color of the label. */
   void setLabelColor(Color color);

   /** {@link RelativePosition} that defines where the label is. */
   RelativePosition getLabelPosition();

   void setLabelPosition(RelativePosition position);

   /** The physical bounds of this hardware element on the controller. */
   void setBounds(double xInMM, double yInMM, double widthInMM, double heightInMM);

   double getX();

   double getY();

   double getWidth();

   double getHeight();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent device layers in Bitwig Studio.
 *
 * @since API version 1
 */
public interface DeviceLayer extends Channel
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent boolean values.
 *
 * @since API version 1
 */
public interface SettableBooleanValue extends BooleanValue, HardwareActionBindable
{
   /**
    * Sets the internal value.
    *
    * @param value
    *           the new boolean value.
    * @since API version 1
    */
   @OscMethod
   void set(boolean value);

   /**
    * Toggles the current state. In case the current value is `false`, the new value will be `true` and the
    * other way round.
    *
    * @since API version 1
    */
   @OscMethod
   void toggle();

   HardwareActionBindable toggleAction();

   HardwareActionBindable setToTrueAction();

   HardwareActionBindable setToFalseAction();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical hardware button on a controller
 *
 * @since API version 10
 */
public interface HardwareSlider extends AbsoluteHardwareControl
{
   /** Indicates if this slider is horizontal rather than vertical. */
   void setIsHorizontal(boolean isHorizontal);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.BooleanSupplier;

import com.bitwig.extension.callback.BooleanValueChangedCallback;

public interface BooleanValue extends Value<BooleanValueChangedCallback>, BooleanSupplier
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   boolean get();

   @Override
   default boolean getAsBoolean()
   {
      return get();
   }
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface represent entries in a browser filter column.
 *
 * @since API version 1
 */
public interface BrowserFilterItem extends BrowserItem
{
   /**
    * Value that reports the hit count of the filter item.
    *
    * @since API version 2
    */
   IntegerValue hitCount();

   /**
    * Registers an observer that reports the hit count of the filter item.
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #hitCount()} instead.
    */
   @Deprecated
   void addHitCountObserver(IntegerValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * This interface represents a modulation source in Bitwig Studio.
 *
 * @since API version 1
 */
public interface ModulationSource
{
   /**
    * Value which reports when the modulation source is in mapping mode.
    *
    * @since API version 2
    */
   BooleanValue isMapping();

   /**
    * Registers an observer which reports when the modulation source is in mapping mode.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #isMapping()} instead.
    */
   @Deprecated
   void addIsMappingObserver(BooleanValueChangedCallback callback);

   /**
    * Toggles the modulation source between mapping mode and normal control functionality.
    *
    * @since API version 1
    */
   void toggleIsMapping();

   /**
    * Value the reports the name of the modulation source.
    *
    * @since API version 2
    */
   StringValue name();

   /**
    * Registers an observer the reports the name of the modulation source.
    *
    * @param numChars
    *           the maximum number of character the reported name should be long
    * @param textWhenUnassigned
    *           the default text that gets reported if the modulation source is not connected to to a
    *           modulation source in Bitwig Studio yet
    * @param callback
    *           a callback function that receives a single string parameter
    * @since API version 1
    * @deprecated Use {@link #name()} instead.
    */
   @Deprecated
   void addNameObserver(int numChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Value which reports if the modulation source is mapped to any destination(s).
    *
    * @since API version 2
    */
   BooleanValue isMapped();

   /**
    * Registers an observer which reports if the modulation source is mapped to any destination(s).
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #isMapped()} instead.
    */
   @Deprecated
   void addIsMappedObserver(BooleanValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Note Operator Condition
 * @since API version 14
 */
public enum NoteOccurrence
{
   ALWAYS,
   FIRST,
   NOT_FIRST,
   PREV,
   NOT_PREV,
   PREV_CHANNEL,
   NOT_PREV_CHANNEL,
   PREV_KEY,
   NOT_PREV_KEY,
   FILL,
   NOT_FILL,
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface represent scenes in Bitwig Studio.
 *
 * @since API version 1
 */
public interface Scene extends ClipLauncherSlotOrScene
{
   /**
    * Returns an object that provides access to the name of the scene.
    *
    * @return a string value object that represents the scene name.
    * @since API version 1
    * @deprecated Use {@link #name()} instead.
    */
   @Deprecated
   SettableStringValue getName();

   /**
    * Returns an object that provides access to the name of the scene.
    *
    * @return a string value object that represents the scene name.
    * @since API version 2
    */
   @Override
   @OscNode
   SettableStringValue name();

   /**
    * Value that reports the number of clips in the scene.
    *
    * @since API version 2
    */
   @OscNode
   IntegerValue clipCount();

   /**
    * Registers an observer that reports the number of clips in the scene.
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #clipCount()}.addValueObserver(callback).
    */
   @Deprecated
   void addClipCountObserver(IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports the position of the scene within the list of Bitwig Studio scenes.
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #sceneIndex()} instead.
    */
   @Deprecated
   void addPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports if the scene is selected in Bitwig Studio.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter.
    * @since API version 1
    */
   void addIsSelectedInEditorObserver(BooleanValueChangedCallback callback);

   /**
    * Selects the scene in Bitwig Studio.
    *
    * @since API version 1
    */
   @OscMethod
   void selectInEditor();

   /**
    * Makes the scene visible in the Bitwig Studio user interface.
    *
    * @since API version 1
    */
   @OscMethod
   void showInEditor();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Instances of this interface implement note input functionality used for recording notes in Bitwig Studio
 * and for playing the instruments in tracks on hardware keyboards. In Bitwig Studio the note inputs are shown
 * in the input choosers of Bitwig Studio tracks.
 *
 * @since API version 1
 */
public interface NoteInput
{
   /**
    * Specifies if the note input should consume MIDI notes, or in other words if it should prevent forwarding
    * incoming notes to the MIDI callback registered in {@link MidiIn#setMidiCallback}. This setting is `true`
    * by default.
    *
    * @param shouldConsumeEvents
    *           `true` if note events should be consumed, `false` of the events should be additionally sent to
    *           the callback registered via {@link MidiIn#setMidiCallback}
    * @since API version 1
    */
   @OscMethod
   void setShouldConsumeEvents(boolean shouldConsumeEvents);

   /**
    * Specifies a translation table which defines the actual key value (0-127) of notes arriving in Bitwig
    * Studio for each note key potentially received from the hardware. This is used for note-on/off and
    * polyphonic aftertouch events. Specifying a value of `-1` for a key means that notes with the key value
    * will be filtered out.
    *
    * Typically this method is used to implement transposition or scale features in controller scripts. By
    * default an identity transform table is configured, which means that all incoming MIDI notes keep their
    * original key value when being sent into Bitwig Studio.
    *
    * @param table
    *           an array which should contain 128 entries. Each entry should be a note value in the range
    *           [0..127] or -1 in case of filtering.
    * @since API version 1
    */
   void setKeyTranslationTable(Object[] table);

   /**
    * Specifies a translation table which defines the actual velocity value (0-127) of notes arriving in
    * Bitwig Studio for each note velocity potentially received from the hardware. This is used for note-on
    * events only.
    *
    * Typically this method is used to implement velocity curves or fixed velocity mappings in controller
    * scripts. By default an identity transform table is configured, which means that all incoming MIDI notes
    * keep their original velocity when being sent into Bitwig Studio.
    *
    * @param table
    *           an array which should contain 128 entries. Each entry should be a note value in the range
    *           [0..127] or -1 in case of filtering.
    * @since API version 1
    */
   void setVelocityTranslationTable(Object[] table);

   /**
    * Assigns polyphonic aftertouch MIDI messages to the specified note expression. Multi-dimensional control
    * is possible by calling this method several times with different MIDI channel parameters. If a key
    * translation table is configured by calling {@link #setKeyTranslationTable}, that table is used for
    * polyphonic aftertouch as well.
    *
    * @param channel
    *           the MIDI channel to map, range [0..15]
    * @param expression
    *           the note-expression to map for the given MIDI channel
    * @param pitchRange
    *           the pitch mapping range in semitones, values must be in the range [1..24]. This parameter is
    *           ignored for non-pitch expressions.
    * @since API version 1
    */
   @OscMethod
   void assignPolyphonicAftertouchToExpression(int channel, NoteExpression expression, int pitchRange);

   /**
    * Enables use of Expressive MIDI mode. (note-per-channel)
    *
    * @param useExpressiveMidi
    *           enabled/disable the MPE mode for this note-input
    * @param baseChannel
    *           which channel (must be either 0 or 15) which is used as the base for this note-input
    * @param pitchBendRange
    *           initial pitch bend range used
    */
   @OscMethod
   void setUseExpressiveMidi(boolean useExpressiveMidi, int baseChannel, int pitchBendRange);

   /**
    * Enables use of Multidimensional Polyphonic Expression mode. (note-per-channel)
    *
    * @param useMPE
    *           enabled/disable the MPE mode for this note-input
    * @param baseChannel
    *           which channel (must be either 0 or 15) which is used as the base for this note-input
    */
   @Deprecated
   void setUseMultidimensionalPolyphonicExpression(boolean useMPE, int baseChannel);

   /**
    * Sends MIDI data directly to the note input. This will bypass both the event filter and translation
    * tables. The MIDI channel of the message will be ignored.
    *
    * @param status
    *           the status byte of the MIDI message
    * @param data0
    *           the data0 part of the MIDI message
    * @param data1
    *           the data1 part of the MIDI message
    * @since API version 1
    */
   @OscMethod
   void sendRawMidiEvent(int status, int data0, int data1);

   /**
    * Creates a proxy object to the NoteInput's NoteLatch component.
    *
    * @since API version 10
    */
   @OscNode
   NoteLatch noteLatch();

   /**
    * Creates a proxy object to the NoteInput's Arpeggiator component.
    *
    * @since API version 10
    */
   @OscNode
   Arpeggiator arpeggiator();

   /**
    * Should this note input be included in the "All Inputs" note source?
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue includeInAllInputs();

   /**
    * An enum defining the note expressions available in Bitwig Studio, used for the expression parameter of
    * {@link #assignPolyphonicAftertouchToExpression}.
    *
    * @since API version 1
    */
   enum NoteExpression
   {
      NONE, PITCH_DOWN, PITCH_UP, GAIN_DOWN, GAIN_UP, PAN_LEFT, PAN_RIGHT, TIMBRE_DOWN, TIMBRE_UP
   }
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

public interface Send extends Parameter
{
   /**
    * Value that reports the color of the channel that this send sends to.
    *
    * @since API version 2
    */
   @OscNode
   SettableColorValue sendChannelColor();

   /**
    * Value that reports if the send happens before or after the fader.
    *
    * @since API version 10
    */
   @OscNode
   BooleanValue isPreFader();

   /**
    * Define how the send will happen.
    * Possible values: AUTO, PRE, POST.
    *
    * @since API version 10
    */
   @OscNode
   SettableEnumValue sendMode();

   /**
    * Enables/Disables the send.
    * @since API version 18
    */
   @OscNode
   SettableBooleanValue isEnabled();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.controller.ControllerExtensionDefinition;
import com.bitwig.extension.controller.HardwareDeviceMatcher;

/**
 * A pipe represents a communication channel with some other hardware device or network service. Pipes are
 * opened and closed by Bitwig Studio automatically and exist for the entire lifetime of a controller. If
 * communication is lost on a specific pipe (for example the user unplugs a USB device) then the controller
 * will exit and the user will be notified.
 *
 * A controller defines which pipes it wants to establish for communication using a
 * {@link HardwareDeviceMatcher}.
 *
 * @see ControllerExtensionDefinition#listHardwareDevices(com.bitwig.extension.controller.HardwareDeviceMatcherList)
 *
 * @since API version 7
 */
public interface Pipe
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.ColorValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;
import com.bitwig.extension.callback.NotePlaybackCallback;

/**
 * This interface defines access to the common attributes and operations of channels, such as tracks or nested
 * device channels.
 *
 * @since API version 1
 */
public interface Channel extends DeviceChain, DeleteableObject, DuplicableObject
{
   /**
    * Reports the channel UUID.
    *
    * @since API version 20
    */
   @OscNode
   StringValue channelId();

   /**
    * Reports the channel index.
    *
    * @since API version 22
    */
   @OscNode
   IntegerValue channelIndex();

   /**
    * Returns an object that represents the activated state of the channel.
    *
    * @return an object that provides access to the channels activated state.
    * @since API version 1
    */
   @OscNode
   SettableBooleanValue isActivated();

   /**
    * Gets a representation of the channels volume control.
    *
    * @return an object that provides access to the channels volume control.
    * @since API version 1
    * @deprecated Use {@link #volume()} instead.
    */
   @Deprecated
   Parameter getVolume();

   /**
    * Gets a representation of the channels volume control.
    *
    * @return an object that provides access to the channels volume control.
    * @since API version 5
    */
   @OscNode
   Parameter volume();

   /**
    * Gets a representation of the channels pan control.
    *
    * @return an object that provides access to the channels pan control.
    * @since API version 1
    * @deprecated Use {@link #pan()} instead.
    */
   @Deprecated
   Parameter getPan();

   /**
    * Gets a representation of the channels pan control.
    *
    * @return an object that provides access to the channels pan control.
    * @since API version 5
    */
   @OscNode
   Parameter pan();

   /**
    * Gets a representation of the channels mute control.
    *
    * @return an object that provides access to the channels mute control.
    * @since API version 1
    * @deprecated Use {@link #mute()} instead.
    */
   @Deprecated
   SettableBooleanValue getMute();

   /**
    * Gets a representation of the channels mute control.
    *
    * @return an object that provides access to the channels mute control.
    * @since API version 5
    */
   @OscNode
   SettableBooleanValue mute();

   /**
    * Gets a representation of the channels solo control.
    *
    * @return an object that provides access to the channels solo control.
    * @since API version 1
    * @deprecated Use {@link #solo()} instead.
    */
   @Deprecated
   SoloValue getSolo();

   /**
    * Gets a representation of the channels solo control.
    *
    * @return an object that provides access to the channels solo control.
    * @since API version 1
    */
   @OscNode
   SoloValue solo();

   /**
    * True if the current channel is being muted by an other channel with solo on.
    * @since API version 10
    */
   @OscNode
   BooleanValue isMutedBySolo();

   /**
    * Registers an observer for the VU-meter of this track.
    *
    * @param range
    *           the number of steps to which the reported values should be scaled. For example a range of 128
    *           would cause the callback to be called with values between 0 and 127.
    * @param channel
    *           0 for left channel, 1 for right channel, -1 for the sum of both
    * @param peak
    *           when `true` the peak value is reported, otherwise the RMS value
    * @param callback
    *           a callback function that takes a single numeric argument. The value is in the range
    *           [0..range-1].
    * @since API version 1
    */
   void addVuMeterObserver(int range, int channel, boolean peak, IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports notes when they are played on the channel.
    *
    * @param callback
    *           a callback function that receives three parameters: 1. on/off state (boolean), 2. key (int),
    *           and 3. velocity (float).
    * @since API version 1
    *
    * @deprecated use {@link #playingNotes()} instead.
    */
   @Deprecated
   void addNoteObserver(NotePlaybackCallback callback);

   /**
    * Returns an array of the playing notes.
    *
    * @since API version 2
    */
   @OscNode
   PlayingNoteArrayValue playingNotes();

   /**
    * Registers an observer that receives notifications about the color of the channel. The callback gets
    * called at least once immediately after this function call to report the current color. Additional calls
    * are fired each time the color changes.
    *
    * @param callback
    *           a callback function that receives three float parameters in the range [0..1]: 1. red, 2.
    *           green, and 3. blue.
    * @since API version 1
    * @deprecated use {@link #color()} instead.
    */
   @Deprecated
   void addColorObserver(ColorValueChangedCallback callback);

   /**
    * Get the color of the channel.
    *
    * @since API version 2
    */
   @OscNode
   SettableColorValue color();

   /**
    * Gets a {@link SendBank} that can be used to navigate the sends of this channel.
    *
    * @since API version 2
    */
   @OscNode
   SendBank sendBank();

   /**
    * Gets a representation of the channels send control at the given index.
    *
    * @param index
    *           the index of the send, must be valid
    * @return an object that provides access to the requested send control.
    * @since API version 1
    * @deprecated Use {@link #sendBank()} instead.
    */
   @Deprecated
   Send getSend(int index);

   /**
    * Duplicates the track.
    *
    * @since API version 1
    */
   @OscMethod
   void duplicate();

   /**
    * Selects the device chain in the Bitwig Studio mixer, in case it is a selectable object.
    *
    * @since API version 1
    */
   @OscMethod
   void selectInMixer();

   /**
    * Registers an observer that reports if the device chain is selected in Bitwig Studio mixer.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter.
    * @since API version 1
    */
   void addIsSelectedInMixerObserver(BooleanValueChangedCallback callback);

   /**
    * Tries to scroll the contents of the arrangement editor so that the channel becomes visible.
    *
    * @since API version 1
    */
   @OscMethod
   void makeVisibleInArranger();

   /**
    * Tries to scroll the contents of the mixer panel so that the channel becomes visible.
    *
    * @since API version 1
    */
   @OscMethod
   void makeVisibleInMixer();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing music files, including access to all filter columns and
 * the result column as shown in the 'Music' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface MusicBrowsingSession extends BrowsingSession
{
   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;

/**
 * An interface representing various commands which can be performed on the Bitwig Studio arranger.
 *
 * To receive an instance of the application interface call {@link ControllerHost#createArranger}.
 */
public interface Arranger extends TimelineEditor
{
   /**
    * Gets an object that allows to enable/disable arranger playback follow. Observers can be registered on
    * the returned object for receiving notifications when the setting switches between on and off.
    *
    * @return a boolean value object that represents the enabled state of arranger playback follow
    * @since API version 1
    */
   SettableBooleanValue isPlaybackFollowEnabled();

   /**
    * Gets an object that allows to control the arranger track height. Observers can be registered on the
    * returned object for receiving notifications when the track height changes.
    *
    * @return a boolean value object that has the state `true` when the tracks have double row height and
    *         `false` when the tracks have single row height.
    * @since API version 1
    */
   SettableBooleanValue hasDoubleRowTrackHeight();

   /**
    * Gets an object that allows to show/hide the cue markers in the arranger panel. Observers can be
    * registered on the returned object for receiving notifications when the cue marker lane switches between
    * shown and hidden.
    *
    * @return a boolean value object that represents the cue marker section visibility
    * @since API version 1
    */
   SettableBooleanValue areCueMarkersVisible();

   /**
    * Gets an object that allows to show/hide the clip launcher in the arranger panel. Observers can be
    * registered on the returned object for receiving notifications when the clip launcher switches between
    * shown and hidden.
    *
    * @return a boolean value object that represents the clip launcher visibility
    * @since API version 1
    */
   SettableBooleanValue isClipLauncherVisible();

   /**
    * Gets an object that allows to show/hide the timeline in the arranger panel. Observers can be registered
    * on the returned object for receiving notifications when the timeline switches between shown and hidden.
    *
    * @return a boolean value object that represents the timeline visibility
    * @since API version 1
    */
   SettableBooleanValue isTimelineVisible();

   /**
    * Gets an object that allows to show/hide the track input/output choosers in the arranger panel. Observers
    * can be registered on the returned object for receiving notifications when the I/O section switches
    * between shown and hidden.
    *
    * @return a boolean value object that represents the visibility of the track I/O section
    * @since API version 1
    */
   SettableBooleanValue isIoSectionVisible();

   /**
    * Gets an object that allows to show/hide the effect tracks in the arranger panel. Observers can be
    * registered on the returned object for receiving notifications when the effect track section switches
    * between shown and hidden.
    *
    * @return a boolean value object that represents the visibility of the effect track section
    * @since API version 1
    */
   SettableBooleanValue areEffectTracksVisible();

   /**
    * Returns an object that provides access to a bank of successive cue markers using a window configured with
    * the given size, that can be scrolled over the list of markers.
    *
    * @param size
    *           the number of simultaneously accessible items
    * @return the requested item bank object
    */
   CueMarkerBank createCueMarkerBank(int size);

   /**
    * Zooms in all arranger lanes, if it the arranger is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInLaneHeightsAllAction();

   void zoomInLaneHeightsAll();

   /**
    * Zooms out all arranger lanes, if it the arranger is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutLaneHeightsAllAction();

   void zoomOutLaneHeightsAll();

   /**
    * Same as zoomInLaneHeightsAllAction/zoomOutLaneHeightsAllAction, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomLaneHeightsAllStepper();

   /**
    * Zooms in selected arranger lanes, if it the arranger is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInLaneHeightsSelectedAction();

   void zoomInLaneHeightsSelected();

   /**
    * Zooms out selected arranger lanes, if it the arranger is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutLaneHeightsSelectedAction();

   void zoomOutLaneHeightsSelected();

   /**
    * Same as zoomInLaneHeightsSelectedAction/zoomOutLaneHeightsSelectedAction, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomLaneHeightsSelectedStepper();

   /**
    * Registers an observer that reports if playback-follow is enabled.
    *
    * @param callback
    *           a callback function object that accepts a single bool parameter
    * @see #isPlaybackFollowEnabled()
    * @deprecated call `isPlaybackFollowEnabled().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addPlaybackFollowObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the current configuration of the arranger track row height.
    *
    * @param callback
    *           a callback function object that accepts a single bool parameter. The parameter indicates if
    *           the row height is double (`true`) or single (`false`).
    * @see #hasDoubleRowTrackHeight()
    * @deprecated call `hasDoubleRowTrackHeight().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addTrackRowHeightObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the cue marker lane is visible.
    *
    * @param callback
    *           a callback function object that accepts a single bool parameter.
    * @see #areCueMarkersVisible()
    * @deprecated call `areCueMarkersVisible().addValueObserver` instead
    * @since API version 1
    */
   @Deprecated
   void addCueMarkerVisibilityObserver(BooleanValueChangedCallback callback);

   /**
    * Toggles the playback follow state.
    *
    * @see #isPlaybackFollowEnabled()
    * @deprecated call `isPlaybackFollowEnabled().toggle` instead
    * @since API version 1
    */
   @Deprecated
   void togglePlaybackFollow();

   /**
    * Toggles the arranger track row height between `double` and `single`.
    *
    * @see #hasDoubleRowTrackHeight()
    * @deprecated call `hasDoubleRowTrackHeight().toggle` instead
    * @since API version 1
    */
   @Deprecated
   void toggleTrackRowHeight();

   /**
    * Toggles the visibility of the arranger cue marker lane.
    *
    * @see #areCueMarkersVisible()
    * @deprecated call `areCueMarkersVisible().toggle` instead
    * @since API version 1
    */
   @Deprecated
   void toggleCueMarkerVisibility();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.ConnectionEstablishedCallback;

/**
 * Instances of this interface represent a TCP socket that other network clients can connect to, typically
 * created by calling {@link ControllerHost#createRemoteConnection}.
 *
 * @see ControllerHost#createRemoteConnection
 * @since API version 1
 */
public interface RemoteSocket
{
   /**
    * Sets a callback which receives a remote connection object for each incoming connection.
    *
    * @param callback
    *           a callback function which receives a single {@link RemoteConnection} argument
    * @since API version 1
    */
   void setClientConnectCallback(ConnectionEstablishedCallback callback);

   /**
    * Gets the actual port used for the remote socket, which might differ from the originally requested port
    * when calling {@link ControllerHost#createRemoteConnection(String name, int port)} in case the requested port was
    * already used.
    *
    * @return the actual port used for the remote socket
    * @since API version 1
    */
   int getPort();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Cursor clip that can act independently from the user's clip selection if desired by being pinned in the
 * controller settings panel.
 *
 * @since API version 10
 */
public interface PinnableCursorClip extends CursorClip, PinnableCursor
{
//   /**
//    * Will create a new empty clip at or after slot index.
//    * If necessary, a new scene will be created.
//    * The cursor will be set onto the new clip.
//    * @since API version 10
//    */
//   @OscMethod
//   void createNewClip(int slotIndex, int lengthInBeats);
//
//   /**
//    * Will start recording a new clip at or after slot index.
//    * If necessary, a new scene will be created.
//    * The cursor will be set onto the new clip.
//    * @since API version 10
//    */
//   @OscMethod
//   void recordNewClip(int slotIndex);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a hardware control that can input and absolute value (for example, a slider, knob or foot
 * pedal).
 *
 * @since API version 10
 */
public interface AbsoluteHardwareControl extends ContinuousHardwareControl<AbsoluteHardwareControlBinding>
{
   /**
    * Sets the {@link AbsoluteHardwareValueMatcher} that can be used to detect when the user adjusts the
    * hardware control's value.
    *
    * @see MidiIn#createAbsoluteCCValueMatcher(int, int)
    * @see MidiIn#createAbsoluteValueMatcher(String, String, int)
    */
   void setAdjustValueMatcher(AbsoluteHardwareValueMatcher matcher);

   /**
    * The current value of this hardware control (0..1)
    */
   DoubleValue value();

   /**
    * Determines if this hardware control should immediately take over the parameter it is bound to rather
    * than respecting the user's current take over mode.
    *
    * This is useful for motorized sliders for example, where the slider is already at the value of the bound
    * parameter.
    */
   void disableTakeOver();

   /** Adds a new binding from this hardware control to the supplied target. */
   AbsoluteHardwareControlBinding addBindingWithRange(
      AbsoluteHardwarControlBindable target,
      double minNormalizedValue,
      double maxNormalizedValue);

   /**
    * Convenience methods that ensures there is only a single binding to the supplied target. This is
    * equivalent to calling {@link #clearBindings()} and then
    * {@link #addBindingWithRange(AbsoluteHardwarControlBindable, double, double)}
    */
   AbsoluteHardwareControlBinding setBindingWithRange(
      AbsoluteHardwarControlBindable target,
      double minNormalizedValue,
      double maxNormalizedValue);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Represents a remote control in Bitwig Studio.
 *
 * @since API version 2
 */
public interface RemoteControl extends Parameter, DeleteableObject
{
   @Override
   SettableStringValue name();

   /**
    * Returns an object indicating whether this remote control's mapping is being changed. An unmapped remote control
    * slot can be mapped by setting this to true.
    */
   @OscNode
   SettableBooleanValue isBeingMapped();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * A channel bank provides access to a range of channels in Bitwig Studio, such as tracks or device layers.
 * Instances of channel bank are typically configured with support for a fixed number of channels and
 * represent an excerpt of a larger list of channels. Various methods are provided for scrolling to different
 * sections of the channel list. It basically acts like a window moving over the list of channels.
 *
 * @since API version 1
 */
public interface ChannelBank<ChannelType extends Channel> extends ObjectProxy, Bank<ChannelType>
{
   /**
    * Returns the channel for the given index.
    *
    * @param indexInBank
    *           the channel index within this bank, not the index within the list of all Bitwig Studio
    *           channels. Must be in the range [0..sizeOfBank-1].
    * @return the channel object
    * @since API version 1
    * @deprecated Use {@link #getItemAt(int)} instead.
    */
   @Deprecated
   Channel getChannel(int indexInBank);

   /**
    * Sets the step size used for scrolling the channel bank.
    *
    * @param stepSize
    *           the step size used for scrolling. Default is `1`.
    * @since API version 1
    */
   void setChannelScrollStepSize(int stepSize);

   /**
    * Scrolls the channels one page up. For example if the channel bank is configured with a window size of 8
    * channels and is currently showing channel [1..8], calling this method would scroll the channel bank to
    * show channel [9..16].
    *
    * @since API version 1
    * @deprecated {@link #scrollPageBackwards()}
    */
   @Deprecated
   void scrollChannelsPageUp();

   /**
    * Scrolls the channels one page up. For example if the channel bank is configured with a window size of 8
    * channels and is currently showing channel [9..16], calling this method would scroll the channel bank to
    * show channel [1..8].
    *
    * @since API version 1
    * @deprecated {@link #scrollPageForwards()}
    */
   @Deprecated
   void scrollChannelsPageDown();

   /**
    * Scrolls the channel window up by the amount specified via {@link #setChannelScrollStepSize(int)} (by
    * default one channel).
    *
    * @since API version 1
    * @deprecated {@link #scrollBackwards()}
    */
   @Deprecated
   void scrollChannelsUp();

   /**
    * Scrolls the channel window down by the amount specified via {@link #setChannelScrollStepSize(int)} (by
    * default one channel).
    *
    * @since API version 1
    * @deprecated {@link #scrollForwards()}
    */
   @Deprecated
   void scrollChannelsDown();

   /**
    * Scrolls the channel bank window so that the channel at the given position becomes visible.
    *
    * @param position
    *           the index of the channel within the underlying full list of channels (not the index within the
    *           bank). The position is typically directly related to the layout of the channel list in Bitwig
    *           Studio, starting with zero in case of the first channel.
    * @since API version 1
    * @deprecated {@link #scrollPosition()}
    */
   @Deprecated
   void scrollToChannel(int position);

   /**
    * Value that reports the current scroll position, more specifically the position of the
    * first channel within the underlying list of channels, that is shown as channel zero within the bank.
    *
    * @since API version 2
    * @deprecated {@link #scrollPosition()}
    */
   @Deprecated
   IntegerValue channelScrollPosition();

   /**
    * Registers an observer that reports the current scroll position, more specifically the position of the
    * first channel within the underlying list of channels, that is shown as channel zero within the bank.
    *
    * @param callback
    *           a callback function that receives a single integer number parameter
    * @param valueWhenUnassigned
    *           a default value for the channel position that gets reported in case the channel bank is not
    *           connected to a list of channels in Bitwig Studio.
    * @since API version 1
    * @deprecated Use {@link #channelScrollPosition()} instead
    */
   @Deprecated
   void addChannelScrollPositionObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);

   /**
    * Value that reports if the channel bank can be scrolled further down.
    *
    * @since API version 2
    */
   BooleanValue canScrollChannelsUp();

   /**
    * Registers an observer that reports if the channel bank can be scrolled further up.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use canScrollChannelsUp().addValueObserver(callback)
    */
   @Deprecated
   void addCanScrollChannelsUpObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the channel bank can be scrolled further down.
    *
    * @since API version 2
    */
   BooleanValue canScrollChannelsDown();

   /**
    * Registers an observer that reports if the channel bank can be scrolled further down.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollChannelsDown()}.addValueObserver(callback)
    */
   @Deprecated
   void addCanScrollChannelsDownObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the underlying total channel count (not the number of channels available in the bank
    * window).
    *
    * @since API version 2
    */
   IntegerValue channelCount();

   /**
    * Registers an observer that reports the underlying total channel count (not the number of channels
    * available in the bank window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #channelCount()}.addValueObserver(callback)
    */
   @Deprecated
   void addChannelCountObserver(IntegerValueChangedCallback callback);

   /**
    * Scrolls the sends one page up.
    *
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void scrollSendsPageUp();

   /**
    * Scrolls the sends one page down.
    *
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void scrollSendsPageDown();

   /**
    * Scrolls the sends one step up.
    *
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void scrollSendsUp();

   /**
    * Scrolls the sends one step down.
    *
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void scrollSendsDown();

   /**
    * Scrolls to the send.
    *
    * @param position
    *           the index of the send.
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void scrollToSend(int position);

   /**
    * Registers an observer that reports if the sends window can be scrolled further up.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void addCanScrollSendsUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the sends window can be scrolled further down.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void addCanScrollSendsDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the underlying total send count (not the number of sends available in
    * the bank window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Does nothing.
    */
   @Deprecated
   void addSendCountObserver(IntegerValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing Bitwig Studio document such as devices, presets,
 * multi-samples, or clips. Full access to all filter columns and the result column as shown in Bitwig
 * Studio's contextual browser window is provided.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface BitwigBrowsingSession extends BrowsingSession
{
   /**
    * Returns the creator filter as shown in the category column of Bitwig Studio's contextual browser.
    *
    * @return the requested creator filter object.
    * @since API version 1
    */
   BrowserFilterColumn getCreatorFilter();

   /**
    * Returns the tags filter as shown in the category column of Bitwig Studio's contextual browser.
    *
    * @return the requested tags filter object.
    * @since API version 1
    */
   BrowserFilterColumn getTagsFilter();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface are used for browsing material with bank-wise access to the filter columns.
 *
 * @see com.bitwig.extension.controller.api.BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface GenericBrowsingSession extends BrowsingSession
{
   /**
    * Value that reports the name of the browsing session.
    *
    * @since API version 2
    */
   StringValue name();

   /**
    * Registers an observer that reports the name of the browsing session.
    *
    * @param callback
    *           a callback function that receives a single string argument.
    * @since API version 1
    * @deprecated Use
    */
   @Deprecated
   void addNameObserver(int maxCharacters, String textWhenUnassigned, StringValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Creates useful MIDI expressions that can be used to match MIDI events.
 *
 * @since API version 10
 */
public interface MidiExpressions
{
   /** Creates an expression that recognizes a MIDI CC event regardless of its channel.
    * @since API version 11 */
   String createIsCCExpression(int controlNumber);

   /** Creates an expression that recognizes a MIDI CC event. */
   String createIsCCExpression(int channel, int controlNumber);

   /**
    * Creates an expression that recognizes a MIDI CC event with a specific value. This expression can be used
    * in {@link #createActionMatcher(String)} or {@link #createAbsoluteValueMatcher(String, String, int)}, for
    * example.
    *
    * @since API version 10
    */
   String createIsCCValueExpression(int channel, int control, int value);

   /**
    * Creates an expression that recognizes a pitch bend event. This expression can be used in
    * {@link #createActionMatcher(String)} or {@link #createAbsoluteValueMatcher(String, String, int)}, for
    * example.
    *
    * @since API version 10
    */
   String createIsPitchBendExpression(int channel);

   /**
    * Creates an expression that recognizes a note on event. This expression can be used in
    * {@link #createActionMatcher(String)} or {@link #createAbsoluteValueMatcher(String, String, int)}, for
    * example.
    *
    * @since API version 10
    */
   String createIsNoteOnExpression(int channel, int note);

   /**
    * Creates an expression that recognizes a note off event. This expression can be used in
    * {@link #createActionMatcher(String)} or {@link #createAbsoluteValueMatcher(String, String, int)}, for
    * example.
    *
    * @since API version 10
    */
   String createIsNoteOffExpression(int channel, int note);

   /**
    * Creates an expression that recognizes a polyphonic aftertouch event. This expression can be used in
    * {@link #createActionMatcher(String)} or {@link #createAbsoluteValueMatcher(String, String, int)}, for
    * example.
    *
    * @since API version 10
    */
   String createIsPolyAftertouch(int channel, int note);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Bitwig Studio supports automatic visual feedback from controllers that shows up as popup notifications. For
 * example when the selected track or the current device preset was changed on the controller, these
 * notifications are shown, depending on the configuration.
 *
 * It depends both on the users preference and the capabilities of the controller hardware if a certain
 * notification should be shown. This interface provides functions for enabling/disabling the various kinds of
 * automatic notifications from the hardware point of view. Typically, controllers that include an advanced
 * display don't need to show many notifications additionally on screen. For other controllers that do not
 * include a display it might be useful to show all notifications. By default all notifications are disabled.
 *
 * In addition, the user can enable or disable all notifications the have been enabled using this interface in
 * the preferences dialog of Bitwig Studio.
 *
 * @since API version 1
 */
public interface NotificationSettings
{
   /**
    * Returns an object that reports if user notifications are enabled and that allows to enable/disable user
    * notifications from the control surface. If user notifications are disabled, no automatic notifications
    * will be shown in the Bitwig Studio user interface. If user notifications are enabled, all automatic
    * notifications will be shown that are enabled using the methods of this interface.
    *
    * @return a boolean value object
    * @since API version 1
    */
   SettableBooleanValue getUserNotificationsEnabled();

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowSelectionNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowChannelSelectionNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowTrackSelectionNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowDeviceSelectionNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowDeviceLayerSelectionNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowPresetNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowMappingNotifications(boolean shouldShowNotifications);

   /**
    * Specifies if user notification related to selection changes should be shown. Please note that this
    * setting only applies when user notifications are enabled in general, otherwise no notification are
    * shown. By default this setting is `false`.
    *
    * @param shouldShowNotifications
    *           `true` in case selection notifications should be shown, `false` otherwise.
    * @see #getUserNotificationsEnabled()
    * @since API version 1
    */
   void setShouldShowValueNotifications(boolean shouldShowNotifications);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Supplier;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface represent time signature values.
 *
 * @since API version 1
 */
public interface TimeSignatureValue extends Value<StringValueChangedCallback>, Supplier<String>
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   @Override
   String get();

   /**
    * Updates the time signature according to the given string.
    *
    * @param name
    *           a textual representation of the new time signature value, formatted as
    *           `numerator/denominator[, ticks]`
    * @since API version 1
    */
   @OscMethod
   void set(String name);

   /**
    * Returns an object that provides access to the time signature numerator.
    *
    * @return an integer value object that represents the time signature numerator.
    * @since API version 1
    * @deprecated Use {@link #numerator()} instead.
    */
   @Deprecated
   SettableIntegerValue getNumerator();

   /**
    * Returns an object that provides access to the time signature numerator.
    *
    * @return an integer value object that represents the time signature numerator.
    * @since API version 5
    */
   @OscNode
   SettableIntegerValue numerator();

   /**
    * Returns an object that provides access to the time signature denominator.
    *
    * @return an integer value object that represents the time signature denominator.
    * @since API version 1
    * @deprecated Use {@link #denominator()} instead.
    */
   @Deprecated
   SettableIntegerValue getDenominator();

   /**
    * Returns an object that provides access to the time signature denominator.
    *
    * @return an integer value object that represents the time signature denominator.
    * @since API version 5
    */
   @OscNode
   SettableIntegerValue denominator();

   /**
    * Returns an object that provides access to the time signature tick subdivisions.
    *
    * @return an integer value object that represents the time signature ticks.
    * @since API version 1
    * @deprecated Use {@link #ticks()} instead.
    */
   @Deprecated
   SettableIntegerValue getTicks();

   /**
    * Returns an object that provides access to the time signature tick subdivisions.
    *
    * @return an integer value object that represents the time signature ticks.
    * @since API version 5
    */
   @OscNode
   SettableIntegerValue ticks();
}
-e 


package com.bitwig.extension.controller.api;

public interface LastClickedParameter
{
   SettableBooleanValue isLocked();

   /**
    * Toggle locked status, but if we are already locked and the mouse points
    * at a different parameter now, lock to the new parameter instead.
    */
   HardwareActionBindable smartToggleLockAction();

   /**
    * @see LastClickedParameter#smartToggleLockAction()
    */
   void smartToggleLock();

   Parameter parameter();

   ColorValue parameterColor();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent the cursor item of track selections.
 *
 * @since API version 1
 */
public interface CursorTrack extends CursorChannel, Track, PinnableCursor
{
   /**
    * Makes the cursor track point to it's parent group track, in case it is not already pointing to the root
    * group track.
    *
    * @since API version 1
    */
   @OscMethod
   void selectParent();

   /**
    * Makes the cursor track point to the first child found with the track group that this cursor currently
    * points to. If this cursor is not pointing to a track group or the track group is empty then this has no
    * effect.
    *
    * @since API version 2
    */
   @OscMethod
   void selectFirstChild();

   /**
    * Specifies the behaviour of the functions {@link #selectPrevious()}, {@link #selectNext()},
    * {@link #selectFirst()} and {@link #selectLast()}. Calling those functions can either navigate the cursor
    * within the current nesting level, or over a flat list of either all tracks or only the expanded tracks.
    * Default is CursorNavigationMode.FLAT.
    *
    * @since API version 1
    */
   void setCursorNavigationMode(CursorNavigationMode mode);

   @Override
   PinnableCursorDevice createCursorDevice();

   /**
    * @param name
    *           the name of the custom device selection cursor, for example "Primary", or `null` to refer to
    *           the device selection cursor in the arranger cursor track as shown in the Bitwig Studio user
    *           interface.
    * @deprecated Use {{@link #createCursorDevice(String, String, int, CursorDeviceFollowMode)}} instead.
    */
   @Override
   @Deprecated
   PinnableCursorDevice createCursorDevice(String name);

   /**
    * @param name
    *           the name of the custom device selection cursor, for example "Primary", or `null` to refer to
    *           the device selection cursor in the arranger cursor track as shown in the Bitwig Studio user
    *           interface.
    * @param numSends
    *           the number of sends that are simultaneously accessible in nested channels.
    * @deprecated Use {{@link #createCursorDevice(String, String, int, CursorDeviceFollowMode)}} instead.
    */
   @Override
   @Deprecated
   PinnableCursorDevice createCursorDevice(String name, int numSends);

   /**
    * Creates a {@link CursorDevice} for this cursor track that by default follows a device based on the
    * supplied follow mode.
    *
    * @param id
    *           An id that is used to identify this cursor.
    * @param name
    *           A name that is displayed to the user for this cursor.
    * @param numSends
    *           the number of sends that are simultaneously accessible in nested channels.
    * @param followMode
    *           Mode that defines how this cursor should follow devices.
    *
    * @since API version 2
    */
   PinnableCursorDevice createCursorDevice(
      String id,
      String name,
      int numSends,
      CursorDeviceFollowMode followMode);

   /**
    * Creates a {@link PinnableCursorClip} for this track that follows a clip within the track on the clip
    * launcher. This clip typically gets updated when the user selects a new clip on the clip launcher. It can
    * also act independently from the user's selection if the user so chooses in the settings for the
    * controller.
    *
    * @since API version 10
    */
   PinnableCursorClip createLauncherCursorClip(int gridWidth, int gridHeight);

   /**
    * Creates a {@link PinnableCursorClip} for this track that follows a clip within the track on the clip
    * launcher. This clip typically gets updated when the user selects a new clip on the clip launcher. It can
    * also act independently from the user's selection if the user so chooses in the settings for the
    * controller.
    *
    * @since API version 10
    */
   PinnableCursorClip createLauncherCursorClip(String id, String name, int gridWidth, int gridHeight);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Creates a proxy object to the NoteInput's NoteLatch component.
 *
 * @since API version 10
 */
public interface NoteLatch extends ObjectProxy
{
   /**
    * Returns an object to enable or disable the note latch component.
    *
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue isEnabled();

   /**
    * Returns an object to configure the note latch mode.
    * Possible values:
    *  - chord
    *  - toggle
    *  - velocity
    *
    * @since API version 10
    */
   @OscNode
   SettableEnumValue mode();

   /**
    * Only one note at a time.
    * @since API version 10
    */
   @OscNode
   SettableBooleanValue mono();

   /**
    * The velocity threshold used by the velocity latch mode.
    * @since API version 10
    */
   @OscNode
   SettableIntegerValue velocityThreshold();

   /**
    * How many notes are being latched.
    * @since API version 10
    */
   @OscNode
   IntegerValue activeNotes();

   /**
    * Release all notes being latched.
    * @since API version 10
    */
   @OscMethod
   void releaseNotes();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface are used to navigate a column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserColumn extends ObjectProxy
{
   /**
    * Registers an observer that reports if the column exists.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #exists()} instead.
    */
   @Deprecated
   void addExistsObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports the underlying total count of column entries (not the size of the column window).
    *
    * @since API version 2
    */
   IntegerValue entryCount();

   /**
    * Registers an observer that reports the underlying total count of column entries (not the size of the
    * column window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #entryCount()}.addValueObserver(callback)
    */
   @Deprecated
   void addEntryCountObserver(IntegerValueChangedCallback callback);

   /**
    * Returns the cursor item, which can be used to navigate over the list of entries.
    *
    * @return the requested filter item object
    * @since API version 1
    */
   BrowserItem createCursorItem();

   /**
    * Returns an object that provides access to a bank of successive entries using a window configured with
    * the given size, that can be scrolled over the list of entries.
    *
    * @param size
    *           the number of simultaneously accessible items
    * @return the requested item bank object
    */
   BrowserItemBank createItemBank(int size);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a cursor clip.
 *
 * @since API version 10
 */
public interface CursorClip extends Clip, Cursor
{
   /**
    * Requests that the supplied clip be selected in this cursor.
    * @since API version 10
    */
   void selectClip(Clip clip);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical hardware knob that inputs a relative value.
 *
 * @see HardwareSurface#createRelativeHardwareKnob(String)
 *
 * @since API version 10
 */
public interface RelativeHardwareKnob extends RelativeHardwareControl
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to categorize actions in Bitwig Studio. The list of action categories
 * provided by Bitwig Studio can be queried by calling {@link Application#getActionCategories()}. To receive a
 * specific action category call {@link Application#getActionCategory(String)}.
 *
 * @see Application#getActionCategories()
 * @see Application#getActionCategory(String)
 * @since API version 1
 */
public interface ActionCategory
{
   /**
    * Returns a string the identifies this action category uniquely.
    *
    * @return the identifier string
    * @since API version 1
    */
   String getId();

   /**
    * Returns the name of this action category.
    *
    * @return the name string
    * @since API version 1
    */
   String getName();

   /**
    * Lists all actions in this category.
    *
    * @return the array of actions in this category
    * @since API version 1
    */
   Action[] getActions();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Interface implemented by objects that can be deleted from the project.
 *
 * @since API version 10
 */
public interface DeleteableObject
{
   /**
    * Deletes this object from the document.
    *
    * If you want to delete multiple objects at once, see Host.deleteObjects().
    *
    * @since API version 10
    */
   @OscMethod
   void deleteObject();

   /**
    * Deletes this object from the document.
    *
    * @since API version 15
    */
   HardwareActionBindable deleteObjectAction();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Something that can be used to match a certain device. The matcher can be used to filter devices in a
 * {@link DeviceBank}, for example.
 *
 * {@link DeviceMatcher}s can be created by calling methods in
 * {@link ControllerHost} such as {@link ControllerHost#createInstrumentMatcher()}.
 *
 * @since API version 12
 */
public interface DeviceMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

public interface UsbOutputPipe extends UsbPipe, OutputPipe
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing devices, including access to all filter columns and the
 * result column as shown in the 'Devices' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface DeviceBrowsingSession extends BrowsingSession
{
   /**
    * Returns the category filter as shown in the category column of the browser.
    *
    * @return the requested category filter object.
    * @since API version 1
    */
   BrowserFilterColumn getCategoryFilter();

   /**
    * Returns the device type filter as shown in the category column of the browser.
    *
    * @return the requested device type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getDeviceTypeFilter();

   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;


import java.util.function.Supplier;

import com.bitwig.extension.callback.ObjectValueChangedCallback;

/**
 * @since API version 2
 */
public interface ObjectArrayValue<ObjectType> extends Value<ObjectValueChangedCallback<ObjectType[]>>, Supplier<ObjectType[]>
{
   /**
    * @since API version 2
    */
   @Override
   ObjectType[] get();

   /**
    * @since API version 2
    */
   default ObjectType get(final int index)
   {
      return get()[index];
   }

   /**
    * @since API version 7
    */
   default boolean isEmpty()
   {
      return get().length == 0;
   }
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a hardware control that can input a relative value (for example, a relative encoder knob).
 *
 * A relative adjustment is positive value when being increased and a negative when being decreased. The
 * relative amount represents the amount of adjustment made. In order to have relative hardware controls work
 * with the same level of sensitivity the relative amount should be +1.0 if the user were to rotate a knob one
 * full rotation (defined as roughly the same amount of rotation as that of an absolute knob to go from 0 to
 * 1) to the right.
 *
 * <p>
 * {@link RelativeHardwareControl}s can also be used to step through items (e.g in a list, or an enum
 * parameter). In this case the {@link #getStepSize()} is used to determine how far the knob has to be rotated
 * in order to increment by one step. For example, if a full rotation of a knob should step through 10 items
 * you would set the step size to 1.0 / 10 (i.e 0.1).
 *
 * @since API version 10
 */
public interface RelativeHardwareControl extends ContinuousHardwareControl<RelativeHardwareControlBinding>
{
   /**
    * Sets the sensitivity of this hardware control. The default sensitivity is 1. This value is a multiplied
    * with the adjustment coming from the {@link RelativeHardwareValueMatcher} to determine the final
    * adjustment amount.
    */
   void setSensitivity(double sensitivity);

   /**
    * Sets the {@link RelativeHardwareValueMatcher} that can be used to detect when the user adjusts the
    * hardware control's value.
    *
    * @see MidiIn#createRelative2sComplementCCValueMatcher(int, int)
    * @see MidiIn#createRelativeSignedBitValueMatcher(AbsoluteHardwareValueMatcher)
    */
   void setAdjustValueMatcher(RelativeHardwareValueMatcher matcher);

   /** Adds a binding to the supplied target with the supplied sensitivity. */
   RelativeHardwareControlBinding addBindingWithSensitivity(
      RelativeHardwarControlBindable target,
      double sensitivity);

   /** Makes sure there is a single binding to the supplied target with the supplied sensitivity. */
   RelativeHardwareControlBinding setBindingWithSensitivity(
      RelativeHardwarControlBindable target,
      double sensitivity);

   /**
    * Adds a binding to the supplied target that does not adjust the target outside of the supplied min and
    * max normalized range.
    */
   RelativeHardwareControlBinding addBindingWithRange(
      SettableRangedValue target,
      double minNormalizedValue,
      double maxNormalizedValue);

   /**
    * Makes sure there is single binding to the supplied target that does not adjust the target outside of the
    * supplied min and max normalized range.
    */
   RelativeHardwareControlBinding setBindingWithRange(
      SettableRangedValue target,
      double minNormalizedValue,
      double maxNormalizedValue);

   /**
    * Adds a binding to the supplied target that does not adjust the target outside of the supplied min and
    * max normalized range and is adjusted with the supplied sensitivity.
    */
   RelativeHardwareControlBinding addBindingWithRangeAndSensitivity(
      SettableRangedValue target,
      double minNormalizedValue,
      double maxNormalizedValue,
      double sensitivity);

   /**
    * Makes sure there is a single binding to the supplied target that does not adjust the target outside of
    * the supplied min and max normalized range and is adjusted with the supplied sensitivity.
    */
   RelativeHardwareControlBinding setBindingWithRangeAndSensitivity(
      SettableRangedValue target,
      double minNormalizedValue,
      double maxNormalizedValue,
      double sensitivity);

   /** The current steps size (amount of relative rotation) necessary to step through an item in a list. */
   double getStepSize();

   /**
    * Sets the step size of this relative hardware control. The step size is used when using this control to
    * step through items in a list, or values in an enum parameter, for example. For each step forwards a
    * certain action can be invoked and for each step backwards a different action.
    */
   void setStepSize(double stepSize);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Represents an output value shown on some hardware (for example, the title of a track).
 *
 * @since API version 10
 */
public interface StringHardwareProperty extends HardwareProperty
{
   /** Gets the current value. This is the value that should be sent to the hardware to be displayed. */
   String currentValue();

   /** The value that was last sent to the hardware. */
   String lastSentValue();

   /**
    * Specifies a callback that should be called with the value that needs to be sent to the hardware. This
    * callback is called as a result of calling the {@link HardwareSurface#updateHardware()} method (typically
    * from the flush method).
    */
   void onUpdateHardware(Consumer<String> sendValueConsumer);

   /** Sets the current value. */
   void setValue(String value);

   /** Sets the current value from a {@link Supplier} that supplies the latest value. */
   void setValueSupplier(Supplier<String> supplier);

   /** The maximum number of characters that can be output or -1 if not specified and there is no limit. */
   int getMaxChars();

   void setMaxChars(int maxChars);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Defines a single value from an enum.
 * @since API version 11
 */
public interface EnumValueDefinition
{
   /**
    * Gets the enum definition this value belongs to.
    * @since API version 11
    */
   EnumDefinition enumDefinition();

   /**
    * Index of this value in the enum definition.
    * @since API version 11
    */
   @OscMethod
   int getValueIndex();

   /**
    * Identifier for this enum value. It will never change.
    * This is the value to pass to {@link SettableEnumValue#set(String)}.
    * @since API version 11
    */
   @OscMethod
   String getId();

   /**
    * This is a string that is suitable for display.
    * @since API version 11
    */
   @OscMethod
   String getDisplayName();

   /**
    * This is a shorter version of {@link #getDisplayName()}.
    * @param maxLength Maximum number of characters
    * @since API version 11
    */
   @OscMethod
   String getLimitedDisplayName(int maxLength);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical piano keyboard on a {@link HardwareSurface}.
 */
public interface PianoKeyboard extends HardwareElement
{
   /**
    * The {@link MidiIn} where this piano keyboard would send key presses. If set this allows the simulator
    * for the hardware to simulate the note input.
    */
   void setMidiIn(MidiIn midiIn);

   /**
    * Sets the {@link NoteInput} that this keyboard should send notes to.
    *
    * @since API version 15
    */
   void setNoteInput(NoteInput noteInput);

   void setChannel(int channel);

   void setIsVelocitySensitive(boolean value);

   void setSupportsPolyAftertouch(boolean value);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a bank of parameters.
 *
 * @since API version 2
 */
public interface ParameterBank
{
   /**
    * Gets the number of slots that these remote controls have.
    * 
    * @since API version 2
    */
   int getParameterCount();

   /**
    * Returns the parameter at the given index within the bank.
    *
    * @param indexInBank
    *           the parameter index within this bank. Must be in the range [0..getParameterCount()-1].
    * @return the requested parameter
    * @since API version 2
    */
   Parameter getParameter(int indexInBank);

   /**
    * Informs the application how to display the controls during the on screen notification.
    *
    * @param type which kind of hardware control is used for this bank (knobs/encoders/sliders)
    * @param columns How wide this section is in terms of layout (4/8/9)
    *
    * @since API version 7
    */
   void setHardwareLayout(HardwareControlType type, int columns);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;

/**
 * A special kind of device that represents the primary device of a track.
 *
 * @since API version 1
 * @deprecated This is now replaced by creating a named {@link CursorDevice}.
 * @see Track#createCursorDevice(String)
 */
@Deprecated
public interface PrimaryDevice extends Device
{
   /**
    * An enum used to navigate the primary device within a device chain.
    *
    * @since API version 1
    * @deprecated
    */
   enum ChainLocation
   {
      FIRST, NEXT, PREVIOUS, LAST,
   };

   /**
    * An enum used to specify different kinds of devices.
    *
    * @since API version 1
    * @deprecated
    */
   enum DeviceType
   {
      ANY,
      // INSTRUMENT,
      // EQ,
      // DYNAMICS,
   };

   /**
    * Makes the device with the given type and location the new primary device.
    *
    * @param deviceType
    *           the requested device type of the new primary device
    * @param chainLocation
    *           the requested chain location of the new primary device
    * @since API version 1
    */
   void switchToDevice(DeviceType deviceType, ChainLocation chainLocation);

   /**
    * Registers an observer that reports if navigation to another device with the provided characteristics is
    * possible.
    *
    * @param deviceType
    *           the requested device type of the new primary device
    * @param chainLocation
    *           the requested chain location of the new primary device
    * @param callback
    *           a callback function the receives a single boolean parameter
    * @since API version 1
    * @deprecated This method never did anything. Please do not use.
    */
   @Deprecated
   void addCanSwitchToDeviceObserver(
      DeviceType deviceType,
      ChainLocation chainLocation,
      BooleanValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Supplier;

import com.bitwig.extension.api.Color;
import com.bitwig.extension.callback.ColorValueChangedCallback;

public interface ColorValue extends Value<ColorValueChangedCallback>, Supplier<Color>
{
   /**
    * Gets the red component of the current value.
    *
    * @since API version 2
    */
   float red();

   /**
    * Gets the green component of the current value.
    *
    * @since API version 2
    */
   float green();

   /**
    * Gets the blue component of the current value.
    *
    * @since API version 2
    */
   float blue();

   /**
    * Gets the alpha component of the current value.
    *
    * @since API version 5
    */
   float alpha();

   @Override
   default Color get()
   {
      return Color.fromRGBA(red(), green(), blue(), alpha());
   }
}
-e 


package com.bitwig.extension.controller.api;

/**
 * An interface representing the global groove settings of the project.
 *
 * @since API version 1
 */
public interface Groove
{
   /**
    * Returns the enabled state of the groove.
    *
    * @return an object that provides access to the groove on/off setting
    * @since API version 1
    */
   Parameter getEnabled();

   /**
    * Returns the object that represents the shuffle amount in Bitwig Studio.
    *
    * @return an ranged value object that provides access to the shuffle amount
    * @since API version 1
    */
   Parameter getShuffleAmount();

   /**
    * Returns the object that represents the shuffle rate in Bitwig Studio.
    *
    * @return an ranged value object that provides access to the shuffle rate
    * @since API version 1
    */
   Parameter getShuffleRate();

   /**
    * Returns the object that represents the accent amount in Bitwig Studio.
    *
    * @return an ranged value object that provides access to the accent amount
    * @since API version 1
    */
   Parameter getAccentAmount();

   /**
    * Returns the object that represents the accent rate in Bitwig Studio.
    *
    * @return an ranged value object that provides access to the accent rate
    * @since API version 1
    */
   Parameter getAccentRate();

   /**
    * Returns the object that represents the accent phase in Bitwig Studio.
    *
    * @return an ranged value object that provides access to the accent phase
    * @since API version 1
    */
   Parameter getAccentPhase();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent the state of a solo button.
 *
 * @since API version 1
 */
public interface SoloValue extends SettableBooleanValue
{
   /**
    * Toggles the current solo state.
    *
    * @param exclusive
    *           specifies if solo on other channels should be disabled automatically ('true') or not
    *           ('false').
    * @since API version 1
    */
   @OscMethod
   void toggle(boolean exclusive);

   /**
    * Toggles the current solo state, using the exclusive setting from the user preferences.
    *
    * @param negatePreferences
    *           If false, then toggles the solo using the exclusive behavior specified in the user preferences,
    *           ortherwise negate the preference setting.
    * @since API version 18
    */
   @OscMethod
   void toggleUsingPreferences(boolean negatePreferences);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * This interface defines access to the common attributes and operations of cue markers.
 *
 * @since API version 2
 */
public interface CueMarker extends ObjectProxy, DeleteableObject, DuplicableObject
{
   /**
    * Launches playback at the marker position.
    *
    * @param quantized Specified if the cue marker should be launched quantized or immediately
    * @since API version 2
    */
   void launch(final boolean quantized);

   /**
    * Gets a representation of the marker name.
    *
    * @since API version 15
    */
   @OscNode
   SettableStringValue name();

   /**
    * Gets a representation of the marker color.
    *
    * @since API version 2
    */
   ColorValue getColor();

   /**
    * Gets a representation of the markers beat-time position in quarter-notes.
    *
    * @since API version 10
    */
   SettableBeatTimeValue position();

   /**
    * Gets a representation of the marker name.
    *
    * @since API version 2
    * @deprecated Use {@link #name()} instead
    */
   StringValue getName();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.DoubleSupplier;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.DoubleValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/** Instances of this interface represent numeric values that have an upper and lower limit.
 *
 * @since API version 1
 * */
public interface RangedValue extends Value<DoubleValueChangedCallback>, DoubleSupplier
{
   /**
    * The current value normalized between 0..1 where 0 represents the minimum value and 1 the maximum.
    *
    * @since API version 2
    */
   @OscMethod
   double get();

   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   @OscMethod
   double getRaw();

   @Override
   @OscMethod
   default double getAsDouble()
   {
      return get();
   }

   /**
    * The normalized origin of this value.
    *
    * For example, the origin for a pan value is 0.5 (representing center), but the origin for a level value is 0.
    *
    * @since API version 20
    */
   @OscNode
   DoubleValue getOrigin();

   /**
    * The number of discrete steps available in the range, or -1 for continuous value ranges.
    *
    * @since API version 20
    */
   @OscNode
   IntegerValue discreteValueCount();

   /**
    * Gets the name for @param index with the index between 0 and discreteValueCount() - 1.
    * WARNING: the returned value may have fewer entries than the discreteValueCount.
    *
    * @since API version 23
    */
   @OscNode
   StringArrayValue discreteValueNames();

   /**
    * Value that represents a formatted text representation of the value whenever the value changes.
    *
    * @since API version 2
    */
   @OscNode
   StringValue displayedValue();

   /**
    * Adds an observer which receives the normalized value of the parameter as an integer number within the
    * range [0..range-1].
    *
    * @param range
    *           the range used to scale the value when reported to the callback
    * @param callback
    *           a callback function that receives a single double parameter
    * @since API version 1
    */
   void addValueObserver(int range, IntegerValueChangedCallback callback);

   /**
    * Add an observer which receives the internal raw of the parameter as floating point.
    *
    * @param callback
    *           a callback function that receives a single numeric parameter with double precision.
    * @since API version 1
    */
   void addRawValueObserver(DoubleValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Object that represents the popup browser in Bitwig Studio.
 *
 * @since API version 2
 */
public interface PopupBrowser extends ObjectProxy, RelativeHardwarControlBindable
{
   /**
    * The title of the popup browser.
    *
    * @since API version 2
    */
   StringValue title();

   /**
    * Value that reports the possible content types that can be inserted by the popup browser. These are
    * represented by the tabs in Bitwig Studio's popup browser.
    *
    * (e.g "Device", "Preset", "Sample" etc.)
    *
    * @since API version 2
    */
   StringArrayValue contentTypeNames();

   /**
    * Value that represents the selected content type.
    *
    * @since API version 2
    */
   StringValue selectedContentTypeName();

   /**
    * Value that represents the index of the selected content type within the content types supported.
    *
    * @since API version 2
    */
   SettableIntegerValue selectedContentTypeIndex();

   /**
    * The smart collections column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn smartCollectionColumn();

   /**
    * The location column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn locationColumn();

   /**
    * The device column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn deviceColumn();

   /**
    * The category column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn categoryColumn();

   /**
    * The tag column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn tagColumn();

   /**
    * The device type column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn deviceTypeColumn();

   /**
    * The file type column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn fileTypeColumn();

   /**
    * The creator column of the browser.
    *
    * @since API version 2
    */
   BrowserFilterColumn creatorColumn();

   /**
    * Column that represents the results of the search.
    *
    * @since API version 2
    */
   BrowserResultsColumn resultsColumn();

   /**
    * Value that indicates if the browser is able to audition material in place while browsing.
    *
    * @since API version 2
    */
   BooleanValue canAudition();

   /**
    * Value that decides if the browser is currently auditioning material in place while browsing or not.
    *
    * @since API version 2
    */
   SettableBooleanValue shouldAudition();

   /**
    * Selects the next file.
    *
    * @since API version 2
    */
   void selectNextFile();

   /**
    * Action that selects the next file
    *
    * @since API version 15
    */
   HardwareActionBindable selectNextFileAction();

   /**
    * Selects the previous file.
    *
    * @since API version 2
    */
   void selectPreviousFile();

   /**
    * Action that selects the next file
    *
    * @since API version 15
    */
   HardwareActionBindable selectPreviousFileAction();

   /**
    * Selects the first file.
    *
    * @since API version 2
    */
   void selectFirstFile();

   /**
    * Selects the last file.
    *
    * @since API version 2
    */
   void selectLastFile();

   /**
    * Cancels the popup browser.
    *
    * @since API version 2
    */
   void cancel();

   HardwareActionBindable cancelAction();

   /**
    * Commits the selected item in the popup browser.
    *
    * @since API version 2
    */
   void commit();

   HardwareActionBindable commitAction();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a physical hardware button on a controller
 *
 * @since API version 10
 */
public interface HardwareButton extends HardwareControl
{
   /** Action that happens when the user presses the button. */
   HardwareAction pressedAction();

   /** Action that happens when the user releases the button. */
   HardwareAction releasedAction();

   /** Button state */
   BooleanValue isPressed();

   /** Sets the optional control that represents the aftertouch value for this button. */
   void setAftertouchControl(AbsoluteHardwareControl control);

   /** An indication of how rounded the corners of this button should be. */
   void setRoundedCornerRadius(double radiusInMM);


}
-e 


package com.bitwig.extension.controller.api;

import java.util.UUID;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.DirectParameterDisplayedValueChangedCallback;
import com.bitwig.extension.callback.DirectParameterNameChangedCallback;
import com.bitwig.extension.callback.DirectParameterNormalizedValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;
import com.bitwig.extension.callback.StringArrayValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * This interface represents a device in Bitwig Studio, both internal devices and plugins.
 *
 * @since API version 1
 */
public interface Device extends ObjectProxy, DeleteableObject, DuplicableObject
{
   /**
    * Returns a representation of the device chain that contains this device. Possible device chain instances
    * are tracks, device layers, drums pads, or FX slots.
    *
    * @return the requested device chain object
    * @since API version 1
    * @deprecated Use {@link #deviceChain()} instead.
    */
   @Deprecated
   DeviceChain getDeviceChain();

   /**
    * Returns a representation of the device chain that contains this device. Possible device chain instances
    * are tracks, device layers, drums pads, or FX slots.
    *
    * @return the requested device chain object
    * @since API version 5
    */
   @OscNode
   DeviceChain deviceChain();

   /**
    * Value that reports the position of the device within the parent device chain.
    *
    * @since API version 2
    */
   IntegerValue position();

   /**
    * Registers an observer that reports the position of the device within the parent device chain.
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #position()} instead.
    */
   @Deprecated
   void addPositionObserver(IntegerValueChangedCallback callback);

   /**
    * Returns an object that provides access to the open state of plugin windows.
    *
    * @return a boolean value object that represents the open state of the editor window, in case the device
    *         features a custom editor window (such as plugins).
    * @since API version 1
    */
   @OscNode
   SettableBooleanValue isWindowOpen();

   /**
    * Returns an object that provides access to the expanded state of the device.
    *
    * @return a boolean value object that represents the expanded state of the device.
    * @since API version 1
    */
   @OscNode
   SettableBooleanValue isExpanded();

   /**
    * Returns an object that provides access to the visibility of the device macros section.
    *
    * @return a boolean value object that represents the macro section visibility.
    *
    * @deprecated Use {@link #isRemoteControlsSectionVisible()} instead
    * @since API version 1
    */
   @Deprecated
   SettableBooleanValue isMacroSectionVisible();

   /**
    * Returns an object that provides access to the visibility of the device remote controls section.
    *
    * @return a boolean value object that represents the remote controls section visibility.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isRemoteControlsSectionVisible();

   /**
    * Returns an object that provides access to the visibility of the parameter page mapping editor.
    *
    * @return a boolean value object that represents visibility of the parameter page mapping editor.
    *
    * @deprecated Use {@link #isRemoteControlsSectionVisible()} instead
    * @since API version 1
    */
   @Deprecated
   SettableBooleanValue isParameterPageSectionVisible();

   /**
    * Returns the parameter with the given index in the current parameter page.
    *
    * @param indexInPage
    *           the index of the parameter within the current parameter page.
    * @return an object that provides access to the requested parameter
    * @deprecated Use getRemoteControls().getRemoteControlInSlot(indexInPage)
    * @since API version 1
    */
   @Deprecated
   Parameter getParameter(int indexInPage);

   /**
    * Creates a cursor for the selected remote controls page in the device with the supplied number of
    * parameters. This section will follow the current page selection made by the user in the application.
    *
    * @param parameterCount
    *           The number of parameters the remote controls should contain
    *
    * @since API version 2
    */
   CursorRemoteControlsPage createCursorRemoteControlsPage(int parameterCount);

   /**
    * Creates a cursor for a remote controls page in the device with the supplied number of parameters. This
    * section will be independent from the current page selected by the user in Bitwig Studio's user
    * interface. The supplied filter is an expression that can be used to match pages this section is
    * interested in. The expression is matched by looking at the tags added to the pages. If the expression is
    * empty then no filtering will occur.
    *
    * @param name
    *           A name to associate with this section. This will be used to remember manual mappings made by
    *           the user within this section.
    *
    *
    * @param parameterCount
    *           The number of parameters the remote controls should contain
    *
    * @param filterExpression
    *           An expression used to match pages that the user can navigate through. For now this can only be
    *           the name of a single tag the pages should contain (e.g "drawbars", "dyn", "env", "eq",
    *           "filter", "fx", "lfo", "mixer", "osc", "overview", "perf").
    *
    * @since API version 2
    */
   CursorRemoteControlsPage createCursorRemoteControlsPage(
      String name,
      int parameterCount,
      String filterExpression);

   /**
    * Returns the parameter with the given index in the envelope parameter page.
    *
    * @param index
    *           the index of the parameter within the envelope parameter page.
    * @return an object that provides access to the requested parameter
    * @since API version 1
    * @deprecated The remote controls deprecate this feature. Instead create remote controls with
    *             {@link #createIndependentRemoteControls(String, int, String)}.
    */
   @Deprecated
   Parameter getEnvelopeParameter(int index);

   /**
    * Returns the parameter with the given index in the common parameter page.
    *
    * @param index
    *           the index of the parameter within the common parameter page.
    * @return an object that provides access to the requested parameter
    * @since API version 1
    * @deprecated The remote controls deprecate this feature. Instead create remote controls with
    *             {@link #createIndependentRemoteControls(String, int, String)}.
    */
   @Deprecated
   Parameter getCommonParameter(int index);

   /**
    * Returns the modulation source at the given index.
    *
    * @param index
    *           the index of the modulation source
    * @return An object that represents the requested modulation source
    * @since API version 1
    * @deprecated The remote controls deprecate this feature. Instead create remote controls with
    *             {@link #createIndependentRemoteControls(String, int, String)}.
    */
   @Deprecated
   ModulationSource getModulationSource(int index);

   /**
    * Returns the macro control at the given index.
    *
    * @param index
    *           the index of the macro control, must be in the range [0..7]
    * @return An object that represents the requested macro control
    * @since API version 1
    * @deprecated Devices no longer have a built in fixed macro section. Instead the user can define pages of
    *             mappings and these should be used instead.
    */
   @Deprecated
   Macro getMacro(int index);

   /**
    * Registers an observer that reports if the device is selected.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #exists()} instead.
    */
   @Deprecated
   void addHasSelectedDeviceObserver(BooleanValueChangedCallback callback);

   /**
    * Selects the device in Bitwig Studio.
    *
    * @since API version 1
    */
   @OscMethod
   void selectInEditor();

   /**
    * Value that reports if the device is a plugin.
    *
    * @since API version 2
    */
   @OscMethod
   BooleanValue isPlugin();

   /**
    * Registers an observer that reports if the device is a plugin.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #isPlugin()} instead
    */
   @Deprecated
   void addIsPluginObserver(BooleanValueChangedCallback callback);

   /**
    * Switches to the previous parameter page.
    *
    * @since API version 1
    */
   @OscMethod
   void previousParameterPage();

   /**
    * Switches to the next parameter page.
    *
    * @since API version 1
    */
   @OscMethod
   void nextParameterPage();

   /**
    * Registers an observer that reports if there is a previous parameter page.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    */
   void addPreviousParameterPageEnabledObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if there is a next parameter page.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    */
   void addNextParameterPageEnabledObserver(BooleanValueChangedCallback callback);

   /**
    * Switches to the parameter page at the given page index.
    *
    * @param page
    *           the index of the desired parameter page
    * @since API version 1
    */
   @OscMethod
   void setParameterPage(int page);

   /**
    * Loads the previous preset.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToPreviousPreset();

   /**
    * Loads the next preset.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToNextPreset();

   /**
    * Switches to the previous preset category.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToPreviousPresetCategory();

   /**
    * Switches to the next preset category.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToNextPresetCategory();

   /**
    * Switches to the previous preset creator.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToPreviousPresetCreator();

   /**
    * Switches to the next preset creator.
    *
    * @since API version 1
    * @deprecated Use new browser API provided via {@link #createDeviceBrowser(int, int)} instead.
    */
   @Deprecated
   void switchToNextPresetCreator();

   /**
    * Returns an object used for browsing devices, presets and other content. Committing the browsing session
    * will load or create a device from the selected resource and replace the current device.
    *
    * @param numFilterColumnEntries
    *           the size of the window used to navigate the filter column entries.
    * @param numResultsColumnEntries
    *           the size of the window used to navigate the results column entries.
    * @return the requested device browser object.
    * @since API version 1
    * @deprecated Use {@link ControllerHost#createPopupBrowser()} instead
    */
   @Deprecated
   Browser createDeviceBrowser(final int numFilterColumnEntries, final int numResultsColumnEntries);

   /**
    * Value that reports the name of the device.
    *
    * @since API version 2
    */
   StringValue name();

   /**
    * Registers an observer that reports the name of the device.
    *
    * @param len
    *           the maximum length of the name. Longer names will get truncated.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single name (string) parameter
    * @since API version 1
    * @deprecated Use {@link #name()} instead
    */
   @Deprecated
   void addNameObserver(int len, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Value that reports the last loaded preset name.
    *
    * @since API version 2
    */
   StringValue presetName();

   /**
    * Registers an observer that reports the last loaded preset name.
    *
    * @param len
    *           the maximum length of the name. Longer names will get truncated.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single name (string) parameter
    * @since API version 1
    * @deprecated Use {@link #presetName()}.addValueObserver(callback) instead.
    */
   @Deprecated
   void addPresetNameObserver(int len, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Value that reports the current preset category name.
    *
    * @since API version 2
    */
   StringValue presetCategory();

   /**
    * Registers an observer that reports the current preset category name.
    *
    * @param len
    *           the maximum length of the name. Longer names will get truncated.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single name (string) parameter
    * @since API version 1
    * @deprecated use {@link #presetCategory()} instead.
    */
   @Deprecated
   void addPresetCategoryObserver(int len, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Value that reports the current preset creator name.
    *
    * @since API version 2
    */
   StringValue presetCreator();

   /**
    * Registers an observer that reports the current preset creator name.
    *
    * @param len
    *           the maximum length of the name. Longer names will get truncated.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single name (string) parameter
    * @since API version 1
    * @deprecated Use {@link #presetCreator()} instead.
    */
   @Deprecated
   void addPresetCreatorObserver(int len, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Registers an observer that reports the currently selected parameter page.
    *
    * @param valueWhenUnassigned
    *           the default page index that gets reported when the device is not associated with a device
    *           instance in Bitwig Studio yet.
    * @param callback
    *           a callback function that receives a single page index parameter (integer)
    * @since API version 1
    * @deprecated Use {@link #createCursorRemoteControlsPage(int)} instead.
    */
   @Deprecated
   void addSelectedPageObserver(int valueWhenUnassigned, IntegerValueChangedCallback callback);

   /**
    * Registers an observer that reports the name of the active modulation source.
    *
    * @param len
    *           the maximum length of the name. Longer names will get truncated.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single name parameter (string)
    * @since API version 1
    * @deprecated Use {@link #createCursorRemoteControlsPage(int)} instead.
    */
   @Deprecated
   void addActiveModulationSourceObserver(
      int len,
      String textWhenUnassigned,
      StringValueChangedCallback callback);

   /**
    * Registers an observer that reports the names of the devices parameter pages.
    *
    * @param callback
    *           a callback function that receives a single string array parameter containing the names of the
    *           parameter pages
    * @since API version 1
    * @deprecated Use {@link #createCursorRemoteControlsPage(int)} instead.
    */
   @Deprecated
   void addPageNamesObserver(StringArrayValueChangedCallback callback);

   /**
    * Registers an observer that reports the names of the available presets for the device according to the
    * current configuration of preset category and creator filtering.
    *
    * @param callback
    *           a callback function that receives a single string array parameter containing the names of the
    *           presets for the current category and creator filter.
    * @see #addPresetCategoryObserver
    * @see #addPresetCreatorObserver
    * @see #setPresetCategory
    * @see #setPresetCreator
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void addPresetNamesObserver(StringArrayValueChangedCallback callback);

   /**
    * Loads the preset with the index from the list provided by {@link #addPresetNamesObserver}.
    *
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void loadPreset(int index);

   /**
    * Registers an observer that reports the names of the available preset categories for the device.
    *
    * @param callback
    *           a callback function that receives a single string array parameter containing the names of the
    *           preset categories
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void addPresetCategoriesObserver(StringArrayValueChangedCallback callback);

   /**
    * Sets the preset category filter with the index from the array provided by
    * {@link #addPresetCategoriesObserver}.
    *
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void setPresetCategory(int index);

   /**
    * Registers an observer that reports the names of the available preset creators for the device.
    *
    * @param callback
    *           a callback function that receives a single string array parameter containing the names of the
    *           preset creators
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void addPresetCreatorsObserver(StringArrayValueChangedCallback callback);

   /**
    * Sets the preset creator filter with the index from the list provided by
    * {@link #addPresetCreatorsObserver}.
    *
    * @since API version 1
    * @deprecated Use the new browser API instead.
    */
   @Deprecated
   void setPresetCreator(int index);

   /**
    * Toggles the enabled state of the device.
    *
    * @since API version 1
    * @deprecated Use isEnabled().toggle() instead.
    */
   @Deprecated
   void toggleEnabledState();

   /**
    * Value that reports if the device is enabled.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isEnabled();

   /**
    * Registers an observer that reports if the device is enabled.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #isEnabled()} instead.
    */
   @Deprecated
   void addIsEnabledObserver(BooleanValueChangedCallback callback);

   /**
    * Indicates if the device has nested device chain slots. Use {@link #slotNames()} to get a list of
    * available slot names, and navigate to devices in those slots using the {@link CursorDevice} interface.
    *
    * @return a value object that indicates if the device has nested device chains in FX slots.
    * @since API version 1
    */
   BooleanValue hasSlots();

   /**
    * Value of the list of available FX slots in this device.
    *
    * @since API version 2
    */
   StringArrayValue slotNames();

   /**
    * Registers an observer that gets notified when the list of available FX slots changes.
    *
    * @param callback
    *           a callback function which takes a single string array argument that contains the names of the
    *           slots.
    * @since API version 1
    * @deprecated Use {@link #slotNames()} instead.
    */
   @Deprecated
   void addSlotsObserver(StringArrayValueChangedCallback callback);

   /**
    * Returns an object that represents the selected device slot as shown in the user interface, and that
    * provides access to the contents of slot's device chain.
    *
    * @return the requested slot cursor object
    * @since API version 1
    */
   DeviceSlot getCursorSlot();

   /**
    * Indicates if the device is contained by another device.
    *
    * @return a value object that indicates if the device is nested
    * @since API version 1
    */
   BooleanValue isNested();

   /**
    * Indicates if the device supports nested layers.
    *
    * @return a value object that indicates if the device supports nested layers.
    * @since API version 1
    */
   BooleanValue hasLayers();

   /**
    * Indicates if the device has individual device chains for each note value.
    *
    * @return a value object that indicates if the device has individual device chains for each note value.
    * @since API version 1
    */
   BooleanValue hasDrumPads();

   /**
    * Create a bank for navigating the nested layers of the device using a fixed-size window.
    *
    * This bank will work over the following devices:
    *  - Instrument Layer
    *  - Effect Layer
    *  - Instrument Selector
    *  - Effect Selector
    *
    * @param numChannels
    *           the number of channels that the device layer bank should be configured with
    * @return a device layer bank object configured with the desired number of channels
    * @since API version 1
    */
   DeviceLayerBank createLayerBank(final int numChannels);

   /**
    * Create a bank for navigating the nested layers of the device using a fixed-size window.
    *
    * @param numPads
    *           the number of channels that the drum pad bank should be configured with
    * @return a drum pad bank object configured with the desired number of pads
    * @since API version 1
    */
   DrumPadBank createDrumPadBank(final int numPads);

   /**
    * Returns a device layer instance that can be used to navigate the layers or drum pads of the device, in
    * case it has any
    *
    * This is the selected layer from the user interface.
    *
    * @return a cursor device layer instance
    * @since API version 1
    */
   CursorDeviceLayer createCursorLayer();

   /**
    * Creates a ChainSelector object which will give you control over the current device if it is an
    * Instrument Selector or an Effect Selector.
    *
    * To check if the device is currently a ChainSelector, use {@link ChainSelector.exists()}.
    *
    * If you want to have access to all the chains, use {@link #createLayerBank(int)}.
    *
    * @return a chain selector instance
    * @since API version 6
    */
   ChainSelector createChainSelector();

   /**
    * Creates an interface for accessing the features of a specific Bitwig device.
    *
    * @since API version 12
    * */
   SpecificBitwigDevice createSpecificBitwigDevice(UUID deviceId);

   /**
    * Creates an interface for accessing the features of a specific VST2 device.
    *
    * @since API version 12
    * */
   SpecificPluginDevice createSpecificVst2Device(int deviceId);

   /**
    * Creates an interface for accessing the features of a specific VST2 device.
    *
    * @since API version 12
    * */
   SpecificPluginDevice createSpecificVst2Device(int... deviceIds);

   /**
    * Creates an interface for accessing the features of a specific VST2 device.
    *
    * @since API version 12
    * */
   SpecificPluginDevice createSpecificVst3Device(String deviceId);

   /**
    * Creates an interface for accessing the features of a specific VST2 device.
    *
    * @since API version 12
    * */
   SpecificPluginDevice createSpecificVst3Device(String... deviceIds);

   /**
    * Adds an observer on a list of all parameters for the device.
    *
    * The callback always updates with an array containing all the IDs for the device.
    *
    * @param callback
    *           function with the signature (String[])
    * @since API version 1
    */
   void addDirectParameterIdObserver(StringArrayValueChangedCallback callback);

   /**
    * Adds an observer for the parameter names (initial and changes) of all parameters for the device.
    *
    * @param maxChars
    *           maximum length of the string sent to the observer.
    * @param callback
    *           function with the signature (String ID, String name)
    * @since API version 1
    */
   void addDirectParameterNameObserver(int maxChars, DirectParameterNameChangedCallback callback);

   /**
    * Returns an observer that reports changes of parameter display values, i.e. parameter values formatted as
    * a string to be read by the user, for example "-6.02 dB". The returned observer object can be used to
    * configure which parameters should be observed. By default no parameters are observed. It should be
    * avoided to observe all parameters at the same time for performance reasons.
    *
    * @return an observer object that can be used to enable or disable actual observing for certain
    *         parameters.
    * @param maxChars
    *           maximum length of the string sent to the observer.
    * @param callback
    *           function with the signature (String ID, String valueDisplay)
    * @since API version 1
    */
   DirectParameterValueDisplayObserver addDirectParameterValueDisplayObserver(
      int maxChars,
      DirectParameterDisplayedValueChangedCallback callback);

   /**
    * Adds an observer for the parameter display value (initial and changes) of all parameters for the device.
    *
    * @param callback
    *           a callback function with the signature (String ID, float normalizedValue). If the value is not
    *           accessible 'Number.NaN' (not-a-number) is reported, can be checked with 'isNaN(value)'.
    * @since API version 1
    */
   void addDirectParameterNormalizedValueObserver(DirectParameterNormalizedValueChangedCallback callback);

   /**
    * Sets the parameter with the specified `id` to the given `value` according to the given `resolution`.
    *
    * @param id
    *           the parameter identifier string
    * @param value
    *           the new value normalized to the range [0..resolution-1]
    * @param resolution
    *           the resolution of the new value
    * @since API version 1
    */
   void setDirectParameterValueNormalized(String id, Number value, Number resolution);

   /**
    * Increases the parameter with the specified `id` by the given `increment` according to the given
    * `resolution`. To decrease the parameter value pass in a negative increment.
    *
    * @param id
    *           the parameter identifier string
    * @param increment
    *           the amount that the parameter value should be increased by, normalized to the range
    *           [0..resolution-1]
    * @param resolution
    *           the resolution of the new value
    * @since API version 1
    */
   void incDirectParameterValueNormalized(String id, Number increment, Number resolution);

   /**
    * Value that reports the file name of the currently loaded sample, in case the device is a sample
    * container device.
    *
    * @since API version 2
    */
   StringValue sampleName();

   /**
    * Registers an observer that reports the file name of the currently loaded sample, in case the device is a
    * sample container device.
    *
    * @param maxChars
    *           maximum length of the string sent to the observer.
    * @param textWhenUnassigned
    *           the default name that gets reported when the device is not associated with a Bitwig Studio
    *           device yet.
    * @param callback
    *           a callback function that receives a single string parameter.
    * @deprecated Use {@link #sampleName()} instead.
    */
   @Deprecated
   void addSampleNameObserver(int maxChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Returns an object that provides bank-wise navigation of sibling devices of the same device chain
    * (including the device instance used to create the siblings bank).
    *
    * @param numDevices
    *           the number of devices that are simultaneously accessible
    * @return the requested device bank object
    * @since API version 1
    */
   DeviceBank createSiblingsDeviceBank(int numDevices);

   /**
    * Starts browsing for content that can be inserted before this device in Bitwig Studio's popup browser.
    *
    * @since API version 2
    * @deprecated Use {@link #beforeDeviceInsertionPoint()} instead.
    */
   @Deprecated
   @OscMethod
   void browseToInsertBeforeDevice();

   /**
    * Starts browsing for content that can be inserted before this device in Bitwig Studio's popup browser.
    *
    * @since API version 2
    * @deprecated Use {@link #afterDeviceInsertionPoint()} instead.
    */
   @OscMethod
   @Deprecated
   void browseToInsertAfterDevice();

   /**
    * Starts browsing for content that can replace this device in Bitwig Studio's popup browser.
    *
    * @since API version 2
    * @deprecated Use {@link #replaceDeviceInsertionPoint()} instead.
    */
   @OscMethod
   @Deprecated
   void browseToReplaceDevice();

   /**
    * {@link InsertionPoint} that can be used for inserting after this device.
    *
    * @since API version 7
    */
   InsertionPoint afterDeviceInsertionPoint();

   /**
    * {@link InsertionPoint} that can be used for inserting before this device.
    *
    * @since API version 7
    */
   InsertionPoint beforeDeviceInsertionPoint();

   /**
    * {@link InsertionPoint} that can be used for replacing this device.
    *
    * @since API version 7
    */
   InsertionPoint replaceDeviceInsertionPoint();

   /**
    * The type of this device.
    *
    * @since API version 12
    */
   EnumValue deviceType();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.Color;

public interface SettableColorValue extends ColorValue
{
   /**
    * Sets the internal value.
    *
    * @since API version 2
    */
   @OscMethod
   void set(float red, float green, float blue);

   /**
    * Sets the internal value.
    *
    * @since API version 5
    */
   @OscMethod
   void set(float red, float green, float blue, float alpha);

   /**
    * Sets the color.
    *
    * @since API version 11
    */
   void set(Color color);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * Represents an output value shown on some hardware.
 *
 * @since API version 10
 */
public interface ObjectHardwareProperty<T> extends HardwareProperty
{
   /** Gets the current value. This is the value that should be sent to the hardware to be displayed. */
   T currentValue();

   /** The value that was last sent to the hardware. */
   T lastSentValue();

   /**
    * Specifies a callback that should be called with the value that needs to be sent to the hardware. This
    * callback is called as a result of calling the {@link HardwareSurface#updateHardware()} method (typically
    * from the flush method).
    */
   void onUpdateHardware(Consumer<? extends T> sendValueConsumer);

   /** Sets the current value. */
   void setValue(T value);

   /** Sets the current value from a {@link BooleanSupplier} that supplies the latest value. */
   void setValueSupplier(Supplier<? extends T> supplier);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.Supplier;

import com.bitwig.extension.callback.StringValueChangedCallback;

public interface StringValue extends Value<StringValueChangedCallback>, Supplier<String>
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   @Override
   String get();

   /**
    * Gets the current value and tries to intelligently limit it to the supplied length in the best way
    * possible.
    *
    * @since API version 2
    */
   String getLimited(int maxLength);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.List;

import com.bitwig.extension.api.graphics.Bitmap;

/**
 * Represents a surface that can contain {@link HardwareElement}s such as {@link HardwareButton}s,
 * {@link HardwareSlider}s, {@link MultiStateHardwareLight}s etc
 *
 * <p>
 * This information allows Bitwig Studio to construct a reliable physical model of the hardware. This
 * information can be used to simulate hardware being present even when physical hardware is not available
 * (and may also be used for other purposes in the future).
 *
 * <p>
 * To be able to simulate hardware being connected so that you can debug controllers without the real hardware
 * you need to do the following:
 *
 * <p>
 * Create a file with the name "config.json" in your user settings directory. The location of this directory
 * is platform dependent:
 *
 * <ul>
 * <li>On Windows: %LOCALAPPDATA%\Bitwig Studio
 * <li>On macOS: Library/Application Support/Bitwig/Bitwig Studio
 * <li>On Linux: $HOME/.BitwigStudio
 * </ul>
 *
 * <p>
 * Then add the following line to the config.json file:
 *
 * <pre>
 * extension-dev : true
 * </pre>
 *
 * <p>
 * You will then need to restart Bitwig Studio. To simulate the controller being connected you can right click
 * on the controller in the preferences and select "Simulate device connected".
 *
 * <p>
 * If you have also provided physical positions for various {@link HardwareElement}s using
 * {@link HardwareElement#setBounds(double, double, double, double)} then you can also see a GUI simulator for
 * your controller by selecting "Show simulated hardware GUI".
 *
 * @since API version 10
 */
public interface HardwareSurface
{
   /**
    * Creates a {@link HardwareSlider} that represents a physical slider on a controller.
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @since API version 10
    */
   HardwareSlider createHardwareSlider(String id);

   /**
    * Creates a {@link HardwareSlider} that represents a physical slider on a controller.
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @param currentValue
    *          The current position of the slider 0..1
    *
    * @since API version 15
    */
   HardwareSlider createHardwareSlider(String id, double currentValue);

   /**
    * Creates an {@link AbsoluteHardwareKnob} that represents a physical knob on a controller that can be used
    * to input an absolute value.
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @since API version 10
    */
   AbsoluteHardwareKnob createAbsoluteHardwareKnob(String id);

   /**
    * Creates an {@link AbsoluteHardwareKnob} that represents a physical knob on a controller that can be used
    * to input an absolute value.
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @param currentValue
    *          The current position of the knob 0..1
    *
    * @since API version 10
    */
   AbsoluteHardwareKnob createAbsoluteHardwareKnob(String id, double currentValue);

   /**
    * Creates an {@link RelativeHardwareKnob} that represents a physical knob on a controller that can be used
    * to input a relative value change.
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @since API version 10
    */
   RelativeHardwareKnob createRelativeHardwareKnob(String id);

   PianoKeyboard createPianoKeyboard(String id, int numKeys, int octave, int startKeyInOctave);

   /**
    * Creates a {@link HardwareButton} that represents a physical button on a controller
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @since API version 10
    */
   HardwareButton createHardwareButton(String id);

   /**
    * Creates a {@link OnOffHardwareLight} that represents a physical light on a controller
    *
    * @since API version 10
    */
   OnOffHardwareLight createOnOffHardwareLight(String id);

   /**
    * Creates a {@link MultiStateHardwareLight} that represents a physical light on a controller
    *
    * @param id
    *           A unique string that identifies this parameter.
    *
    * @since API version 10
    */
   MultiStateHardwareLight createMultiStateHardwareLight(String id);

   /**
    * Creates a {@link HardwareTextDisplay} that represents a physical text display on a controller
    *
    * @param id
    *           A unique string that identifies this control.
    *
    * @since API version 10
    */
   HardwareTextDisplay createHardwareTextDisplay(String id, int numLines);

   /**
    * Creates a {@link HardwarePixelDisplay} that displays the provided {@link Bitmap} that is rendered by the
    * controller.
    *
    * @since API version 10
    */
   HardwarePixelDisplay createHardwarePixelDisplay(String id, Bitmap bitmap);

   /**
    * Sets the physical size of this controller in mm.
    *
    * @since API version 10
    */
   void setPhysicalSize(double widthInMM, double heightInMM);

   /**
    * Updates the state of all {@link HardwareOutputElement}s that have changed since the last time this
    * method was called.
    *
    * Any onUpdateHardware callbacks that have been registered on {@link HardwareOutputElement}s or
    * {@link HardwareProperty}s will be invoked if their state/value has changed since the last time it was
    * called.
    *
    * This is typically called by the control script from its flush method.
    *
    * @since API version 10
    */
   void updateHardware();

   /**
    * Mark all {@link HardwareOutputElement}s as needing to resend their output state, regardless of it has
    * changed or not.
    */
   void invalidateHardwareOutputState();

   /**
    * A list of all the {@link HardwareControl}s that have been created on this {@link HardwareSurface}.
    */
   List<? extends HardwareControl> hardwareControls();

   /** Finds the {@link HardwareElement} that has the supplied id or null if not found. */
   HardwareElement hardwareElementWithId(String id);

   /** List of all {@link HardwareElement}s on this {@link HardwareSurface}. */
   List<? extends HardwareOutputElement> hardwareOutputElements();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * @since API version 2
 */
public interface SettableStringArrayValue extends StringArrayValue
{
   /**
    * Sets the internal value.
    *
    * @param value
    *           the new value.
    * @since API version 2
    */
   void set(String[] value);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.StringArrayValueChangedCallback;

/**
 * @since API version 2
 */
public interface StringArrayValue extends ObjectArrayValue<String>
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   String[] get();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.List;

import com.bitwig.extension.controller.UsbInterfaceMatcher;

public interface UsbInterface
{
   /**
    * The {@link UsbInterfaceMatcher} that was provided by the controller for identifying this device.
    *
    * */
   UsbInterfaceMatcher interfaceMatcher();

   /** The list of pipes that have been opened for this interface. */
   List<UsbPipe> pipes();

   UsbPipe pipe(int index);

   int pipeCount();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing presets, including access to all filter columns and the
 * result column as shown in the 'Presets' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface PresetBrowsingSession extends BitwigBrowsingSession
{
   /**
    * Returns the category filter as shown in the category column of the browser.
    *
    * @return the requested category filter object.
    * @since API version 1
    */
   BrowserFilterColumn getCategoryFilter();

   /**
    * Returns the preset type filter as shown in the category column of the browser.
    *
    * @return the requested preset type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getPresetTypeFilter();

   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent a bank of custom controls that can be manually learned to device
 * parameters by the user.
 *
 * @since API version 1
 */
public interface UserControlBank
{
   /**
    * Gets the user control at the given bank index.
    *
    * @param index
    *           the index of the control within the bank
    * @return the requested user control object
    * @since API version 1
    */
   Parameter getControl(int index);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface are used to represent macro controls in Bitwig Studio to controllers.
 *
 * @deprecated Macros no longer exist as built in features of all devices. Instead the user can customize
 *             pages of controls.
 * @since API version 1
 */
@Deprecated
public interface Macro
{
   /**
    * Returns an object that provides access to the control value of the macro.
    *
    * @return a ranged value object.
    * @since API version 1
    */
   Parameter getAmount();

   /**
    * Returns an object that provides access to the modulation source of the macro.
    *
    * @return a modulation source object.
    * @since API version 1
    */
   ModulationSource getModulationSource();

   /**
    * Registers an observer that reports the label of the macro control.
    *
    * @param numChars
    *           the maximum number of characters of the reported label
    * @param textWhenUnassigned
    *           the default text that is reported when the macro is not connected to a Bitwig Studio macro
    *           control.
    * @param callback
    *           a callback function that receives a single string parameter.
    */
   void addLabelObserver(int numChars, String textWhenUnassigned, StringValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * An interface representing various commands which can be performed on the Bitwig Studio detail editor.<br/>
 *
 * To receive an instance of the application interface call {@link ControllerHost#createDetailEditor}.
 *
 * @since API version 14
 */
public interface DetailEditor extends TimelineEditor
{
   /**
    * Zooms in all detail editor lanes, if it the detail editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomInLaneHeightsAction();

   void zoomInLaneHeights();

   /**
    * Zooms out all detail editor lanes, if it the detail editor is visible.
    *
    * @since API version 14
    */
   HardwareActionBindable zoomOutLaneHeightsAction();

   void zoomOutLaneHeights();

   /**
    * Same as zoomInLaneHeightsAction/zoomOutLaneHeightsAction, but as a stepper
    *
    * @since API version 14
    */
   RelativeHardwarControlBindable zoomLaneHeightsStepper();

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * A track bank provides access to a range of tracks and their scenes (clip launcher slots) in Bitwig Studio.
 * Instances of track bank are configured with a fixed number of tracks and scenes and represent an excerpt of
 * a larger list of tracks and scenes. Various methods are provided for scrolling to different sections of the
 * track/scene list. It basically acts like a 2-dimensional window moving over the grid of tracks and scenes.
 *
 * To receive an instance of track bank that supports all kinds of tracks call {@link ControllerHost#createTrackBank}.
 * Additional methods are provided in the {@link ControllerHost} interface to create track banks that include only main
 * tracks ({@link ControllerHost#createMainTrackBank}) or only effect tracks ({@link ControllerHost#createEffectTrackBank}).
 *
 * @see ControllerHost#createTrackBank
 * @see ControllerHost#createMainTrackBank
 * @see ControllerHost#createEffectTrackBank
 * @since API version 1
 */
public interface TrackBank extends ChannelBank<Track>
{
   /**
    * @deprecated use {@link #getChannel(int)} instead.
    * @since API version 1
    */
   @Deprecated
   Track getTrack(int indexInBank);

   /**
    * Returns the track at the given index within the bank.
    *
    * @param indexInBank
    *           the track index within this bank, not the index within the list of all Bitwig Studio tracks.
    *           Must be in the range [0..sizeOfBank-1].
    * @return the requested track object
    * @since API version 1
    * @deprecated Use {@link #getItemAt(int)} instead.
    */
   @Deprecated
   @Override
   Track getChannel(int indexInBank);

   /**
    * @deprecated use {@link #setChannelScrollStepSize(int)} instead.
    */
   @Deprecated
   void setTrackScrollStepSize(int stepSize);

   /**
    * @deprecated use {@link #scrollChannelsPageUp()} instead.
    */
   @Deprecated
   void scrollTracksPageUp();

   /**
    * @deprecated use {@link #scrollChannelsPageDown()} instead.
    */
   @Deprecated
   void scrollTracksPageDown();

   /**
    * @deprecated use {@link #scrollChannelsUp()} instead.
    */
   @Deprecated
   void scrollTracksUp();

   /**
    * @deprecated use {@link #scrollChannelsDown()} instead.
    */
   @Deprecated
   void scrollTracksDown();

   /**
    * @deprecated use {@link #scrollToChannel(int)} instead.
    */
   @Deprecated
   void scrollToTrack(int position);

   /**
    * @deprecated use {@link #scrollPosition()} instead.
    */
   @Deprecated
   void addTrackScrollPositionObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);

   /**
    * {@link SceneBank} that represents a view on the scenes in this {@link TrackBank}.
    *
    * @since API version 2
    */
   SceneBank sceneBank();

   /**
    * Scrolls the scenes one page up.
    *
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void scrollScenesPageUp();

   /**
    * Scrolls the scenes one page down.
    *
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void scrollScenesPageDown();

   /**
    * Scrolls the scenes one step up.
    *
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void scrollScenesUp();

   /**
    * Scrolls the scenes one step down.
    *
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void scrollScenesDown();

   /**
    * Makes the scene with the given position visible in the track bank.
    *
    * @param position
    *           the position of the scene within the underlying full list of scenes
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void scrollToScene(int position);

   /**
    * Registers an observer that reports the current scene scroll position.
    *
    * @param callback
    *           a callback function that takes a single integer parameter
    * @param valueWhenUnassigned
    *           the default value that gets reports when the track bank is not yet connected to a Bitwig
    *           Studio document
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void addSceneScrollPositionObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);

   /**
    * @deprecated use {@link #canScrollChannelsUp()} instead.
    */
   @Deprecated
   void addCanScrollTracksUpObserver(BooleanValueChangedCallback callback);

   /**
    * @deprecated use {@link #canScrollChannelsDown()} instead.
    */
   @Deprecated
   void addCanScrollTracksDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the scene window can be scrolled further up.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    *
    * @deprecated use {@link #sceneBank()} instead.
    */
   @Deprecated
   void addCanScrollScenesUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the scene window can be scrolled further down.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    *
    * @deprecated use {@link #sceneBank()} instead.
    */
   @Deprecated
   void addCanScrollScenesDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the underlying total scene count (not the number of scenes available
    * in the bank window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #sceneBank()}.itemCount().addValueObserver()
    */
   @Deprecated
   void addSceneCountObserver(IntegerValueChangedCallback callback);

   /**
    * Returns an object that provides access to the clip launcher scenes of the track bank.
    *
    * @return an object that provides access to the clip launcher scenes of the track bank.
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   ClipLauncherSlotOrSceneBank getClipLauncherScenes();

   /**
    * Launches the scene with the given bank index.
    *
    * @param indexInWindow
    *           the scene index within the bank, not the position of the scene withing the underlying full
    *           list of scenes.
    * @since API version 1
    * @deprecated Use {@link #sceneBank()} instead.
    */
   @Deprecated
   void launchScene(int indexInWindow);

   /**
    * Causes this bank to follow the supplied cursor. When the cursor moves to a new item the bank will be
    * scrolled so that the cursor is within the bank, if possible.
    *
    * @param cursorTrack
    *           The {@link CursorTrack} that this bank should follow.
    *
    * @since API version 2
    */
   void followCursorTrack(CursorTrack cursorTrack);

   /**
    * Decides if Bitwig Studio's clip launcher should indicate the area being controlled by this controller or not.
    *
    * @since API versian 17
    */
   void setShouldShowClipLauncherFeedback(boolean value);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * @param mode
    */
   void setFlatteningMode(TrackBankFlatteningMode mode);

   /**
    * Beta API - this method might not be available in a future version of Bitwig Studio
    *
    * Sets whether to include all channels that are visible in the mixer. When off, only tracks and groups are included;
    * when on, drum pads and FX layers are included in addition.
    * Disabled by default.
    *
    * @since API version 24
    */
   void setShouldIncludeAllMixerChannels(final boolean shouldSkip);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from an {@link RelativeHardwareControl} to a {@link SettableRangedValue}
 *
 * @since API version 10
 */
public interface RelativeHardwareControlToRangedValueBinding
   extends RelativeHardwareControlBinding, HardwareBindingWithRange
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent nested FX slots in devices.
 *
 * @since API version 1
 */
public interface DeviceSlot extends DeviceChain
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a page of remote controls in a device.
 *
 * @since API version 2
 */
public interface RemoteControlsPage extends ParameterBank, DeleteableObject
{
   @Override
   RemoteControl getParameter(int indexInBank);

   /** @since API version 4 */
   StringValue getName();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Represents a binding from some hardware input to a target.
 *
 * When the binding is no longer needed the {@link #removeBinding()} method can be called to remove it.
 *
 * @since API version 10
 */
public interface HardwareBinding
{
   /** Removes this binding between its source and target so it is no longer in effect. */
   void removeBinding();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * @since API version 2
 */
public interface PlayingNoteArrayValue extends ObjectArrayValue<PlayingNote>
{
   default public boolean isNotePlaying(int note)
   {
      PlayingNote[] playingNotes = get();
      assert playingNotes != null;

      for (PlayingNote playingNote : playingNotes)
      {
         assert playingNote != null;
         if (playingNote.pitch() == note)
            return true;
      }
      return false;
   }
}
-e 


package com.bitwig.extension.controller.api;

/**
 * @since API version 2
 */
public interface PlayingNote
{
   /**
    * @since API version 2
    */
   int pitch();

   /**
    * @since API version 2
    */
   int velocity();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

public interface DuplicableObject
{
   /**
    * Duplicates this object into the document.
    *
    * If you want to duplicate multiple objects at once, see Host.duplicateObjects().
    *
    * @since API version 19
    */
   @OscMethod
   void duplicateObject();

   /**
    * Duplicates this object into the document.
    *
    * @since API version 19
    */
   HardwareActionBindable duplicateObjectAction();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * A common base interface for labeled and categorized settings.
 *
 * @since API version 1
 */
public interface Setting
{
   /**
    * Returns the category name of the setting.
    *
    * @return a string value containing the category name
    * @since API version 1
    */
   String getCategory();

   /**
    * Returns the label text of the setting.
    *
    * @return a string value containing the label text
    * @since API version 1
    */
   String getLabel();

   /**
    * Marks the settings as enabled in Bitwig Studio. By default the setting is enabled.
    *
    * @since API version 1
    */
   @OscMethod
   void enable();

   /**
    * Marks the settings as disabled in Bitwig Studio. By default the setting is enabled.
    *
    * @since API version 1
    */
   @OscMethod
   void disable();

   /**
    * Shows the setting in Bitwig Studio. By default the setting is shown.
    *
    * @since API version 1
    */
   @OscMethod
   void show();

   /**
    * Hides the setting in Bitwig Studio. By default the setting is shown.
    *
    * @since API version 1
    */
   @OscMethod
   void hide();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.DoubleValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;
import com.bitwig.extension.callback.ValueChangedCallback;

/**
 * Instances of this interface represent beat time values.
 *
 * Beat time values are double-precision number representing the number of quarter notes, regardless of time-signature.
 *
 * @since API version 1
 */
public interface BeatTimeValue extends DoubleValue
{
   /**
    * Add an observer which receives the internal raw of the parameter as floating point.
    *
    * @param callback
    *           a callback function that receives a single numeric parameter with double precision.
    * @since API version 1
    * @deprecated This exists for backwards compatibility. Use
    *             {@link #addValueObserver(ValueChangedCallback)} instead.
    */
   @Deprecated
   void addRawValueObserver(DoubleValueChangedCallback callback);

   /**
    * Gets the current beat time formatted according to the supplied formatter.
    *
    * @since API version 2
    */
   String getFormatted(BeatTimeFormatter formatter);

   /**
    * Gets the current beat time formatted according to the default beat time formatter.
    *
    * @see ControllerHost#setDefaultBeatTimeFormatter(BeatTimeFormatter)
    * @since API version 2
    */
   String getFormatted();

   /**
    * Registers an observer that reports the internal beat time value as formatted text, for example
    * "012:03:00:01".
    *
    * @param separator
    *           the character used to separate the segments of the formatted beat time, typically ":", "." or
    *           "-"
    * @param barsLen
    *           the number of digits reserved for bars
    * @param beatsLen
    *           the number of digits reserved for beats
    * @param subdivisionLen
    *           the number of digits reserved for beat subdivisions
    * @param ticksLen
    *           the number of digits reserved for ticks
    * @param callback
    *           a callback function that receives a single string parameter
    * @since API version 1
    * @deprecated Use {@link #getFormatted(BeatTimeFormatter)} instead.
    */
   @Deprecated
   void addTimeObserver(
      String separator,
      int barsLen,
      int beatsLen,
      int subdivisionLen,
      int ticksLen,
      StringValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * An interface for representing the current project.
 *
 * @since API version 1
 */
public interface Project extends ObjectProxy
{
   /**
    * Returns an object that represents the root track group of the active Bitwig Studio project.
    *
    * @return the root track group of the currently active project
    * @since API version 1
    */
   @OscNode
   Track getRootTrackGroup();

   /**
    * Returns an object that represents the top level track group as shown in the arranger/mixer of the active
    * Bitwig Studio project.
    *
    * @return the shown top level track group of the currently active project
    * @since API version 1
    */
   @OscNode
   Track getShownTopLevelTrackGroup();

   /**
    * Creates a new empty scene as the last scene in the project.
    *
    * @since API version 13
    */
   @OscMethod
   void createScene();

   /**
    * Creates a new scene (using an existing empty scene if possible) from the clips that are currently
    * playing in the clip launcher.
    *
    * @since API version 1
    */
   @OscMethod
   void createSceneFromPlayingLauncherClips();

   /**
    * The volume used for cue output.
    *
    * @since API version 10
    */
   @OscNode
   Parameter cueVolume();

   /**
    * Mix between cue bus and the studio bus (master).
    *
    * @since API version 10
    */
   @OscNode
   Parameter cueMix();

   /**
    * Sets the solo state of all tracks to off.
    *
    * @since API version 10
    */
   @OscMethod
   void unsoloAll();

   @OscNode
   BooleanValue hasSoloedTracks();

   /**
    * Sets the mute state of all tracks to off.
    *
    * @since API version 10
    */
   @OscMethod
   void unmuteAll();

   /**
    * Value that indicates if the project has muted tracks or not.
    *
    * @since API version 10
    */
   @OscNode
   BooleanValue hasMutedTracks();

   /**
    * Sets the arm state of all tracks to off.
    *
    * @since API version 10
    */
   @OscNode
   void unarmAll();

   /**
    * Value that indicates if the project has armed tracks or not.
    *
    * @since API version 10
    */
   @OscNode
   BooleanValue hasArmedTracks();

   /**
    * Value that indicates if the project is modified or not.
    *
    * @since API version 18
    */
   @OscNode
   BooleanValue isModified();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent the cursor item of track selections.
 *
 * @since API version 1
 */
public enum CursorNavigationMode
{
   NESTED, FLAT, GUI;
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Cursor that can be pinned to the current device or follow the selection.
 *
 * @since API version 2
 */
public interface PinnableCursorDevice extends CursorDevice, PinnableCursor
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.ValueChangedCallback;

/**
 * The common interface that is shared by all value objects in the controller API.
 *
 * @since API version 1
 */
public interface Value<ObserverType extends ValueChangedCallback> extends Subscribable
{
   /**
    * Marks this value as being of interest to the driver. This can only be called once during the driver's
    * init method. A value that is of interest to the driver can be obtained using the value's get method. If
    * a value has not been marked as interested then an error will be reported if the driver attempts to get
    * the current value. Adding an observer to a value will automatically mark this value as interested.
    *
    * @since API version 2
    */
   void markInterested();

   /**
    * Registers an observer that reports the current value.
    *
    * @param callback
    *           a callback function that receives a single parameter
    * @since API version 1
    */
   void addValueObserver(ObserverType callback);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * A bank provides access to a range of items in Bitwig Studio. Instances of a bank are configured with a
 * fixed number of items and represent an excerpt of a larger list of items. Various methods are provided for
 * scrolling to different sections of the item list. It basically acts like a window moving over the list of
 * underlying items.
 *
 * @since API version 2
 */
public interface Bank<ItemType extends ObjectProxy> extends ObjectProxy, Scrollable
{
   /**
    * The fixed size of this bank.
    * This will be initially equal to the capacity of the Bank.
    *
    * @since API version 2
    */
   int getSizeOfBank();

   /**
    * The maximum number of items in the bank which is defined when the bank is initially created.
    *
    * @since API version 7
    */
   int getCapacityOfBank();

   /**
    * Sets the size of this bank
    *
    * @param size number of items in the bank that has to be greater than 0 and less or equal to the capacity of the bank.
    *
    * @since API version 7
    */
   void setSizeOfBank(int size);

   /**
    * Gets the item in the bank at the supplied index. The index must be {@literal >= 0 and <} {@link #getSizeOfBank()}.
    *
    * @since API version 2
    */
   ItemType getItemAt(int index);

   /**
    * Value that reports the underlying total item count (not the number of items available in the bank
    * window).
    *
    * @since API version 2
    */
   IntegerValue itemCount();

   /**
    * An integer value that defines the location of the cursor that this bank is following. If there is no
    * cursor or the cursor is not within the bank then the value is -1.
    *
    * @since API version 2
    */
   @OscNode
   SettableIntegerValue cursorIndex();

   /**
    * Disabled items will not be accessible via the bank if set to true.
    * @since API version 11
    */
   @OscMethod
   void setSkipDisabledItems(boolean shouldSkip);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent entries in a browser column.
 *
 * @since API version 1
 */
public interface CursorBrowserResultItem extends BrowserResultsItem, CursorBrowserItem
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for browsing samples, including access to all filter columns and the
 * result column as shown in the 'Samples' tab of Bitwig Studio's contextual browser window.
 *
 * @see BrowsingSession
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface SampleBrowsingSession extends BrowsingSession
{
   /**
    * Returns the file type filter as shown in the category column of the browser.
    *
    * @return the requested file type filter object.
    * @since API version 1
    */
   BrowserFilterColumn getFileTypeFilter();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent actions in Bitwig Studio, such as commands that can be launched from
 * the main menu or via keyboard shortcuts.
 *
 * To receive the list of all actions provided by Bitwig Studio call {@link Application#getActions()}. The
 * list of actions that belong to a certain category can be queried by calling
 * {@link ActionCategory#getActions()}. Access to specific actions is provided in
 * {@link Application#getAction(String)}.
 *
 * @since API version 1
 */
public interface Action extends HardwareActionBindable
{
   /**
    * Returns a string the identifies this action uniquely.
    *
    * @return the identifier string
    * @since API version 1
    */
   String getId();

   /**
    * Returns the name of this action.
    *
    * @return the name string
    * @since API version 1
    */
   String getName();

   /**
    * Returns the category of this action.
    *
    * @return the category string
    * @since API version 1
    */
   ActionCategory getCategory();

   /**
    * Returns the text that is displayed in menu items associated with this action.
    *
    * @return the menu item text
    * @since API version 1
    */
   String getMenuItemText();

   /**
    * Invokes the action.
    *
    * @since API version 1
    */
   @Override
   void invoke();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.ColorValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;
import com.bitwig.extension.callback.NoteStepChangedCallback;
import com.bitwig.extension.callback.StepDataChangedCallback;

/**
 * An interface that provides access to the contents of a clip in Bitwig Studio.
 *
 * The note content of the clip is exposed in terms of steps and keys, mainly targeted to x-y-grid
 * applications such as step sequencers.
 *
 * @since API version 1
 */

public interface Clip extends ObjectProxy
{
   /**
    * Scroll the note grid so that the given key becomes the key with y position of 0.
    *
    * Note: This can cause some parts of the grid to represent invalid keys as there is no clipping
    *
    * @param key
    *           the key that should be the new key with a y position of 0. This must be a value in the range
    *           0...127.
    * @since API version 1
    */
   @OscMethod
   void scrollToKey(int key);

   /**
    * Scrolls the note grid keys one page up. For example if the note grid is configured to show 12 keys and
    * is currently showing keys [36..47], calling this method would scroll the note grid to key range
    * [48..59].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollKeysPageUp();

   /**
    * Scrolls the note grid keys one page down. For example if the note grid is configured to show 12 keys and
    * is currently showing keys [36..47], calling this method would scroll the note grid to key range
    * [48..59].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollKeysPageDown();

   /**
    * Scrolls the note grid keys one key up. For example if the note grid is configured to show 12 keys and is
    * currently showing keys [36..47], calling this method would scroll the note grid to key range [37..48].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollKeysStepUp();

   /**
    * Scrolls the note grid keys one key down. For example if the note grid is configured to show 12 keys and
    * is currently showing keys [36..47], calling this method would scroll the note grid to key range
    * [35..46].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollKeysStepDown();

   /**
    * Scroll the note grid so that the given step becomes visible.
    *
    * @param step
    *           the step that should become visible
    * @since API version 1
    */
   @OscMethod
   void scrollToStep(int step);

   /**
    * Scrolls the note grid steps one page forward. For example if the note grid is configured to show 16
    * steps and is currently showing keys [0..15], calling this method would scroll the note grid to key range
    * [16..31].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollStepsPageForward();

   /**
    * Scrolls the note grid steps one page backwards. For example if the note grid is configured to show 16
    * steps and is currently showing keys [16..31], calling this method would scroll the note grid to key
    * range [0..16].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollStepsPageBackwards();

   /**
    * Scrolls the note grid steps one step forward. For example if the note grid is configured to show 16
    * steps and is currently showing keys [0..15], calling this method would scroll the note grid to key range
    * [1..16].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollStepsStepForward();

   /**
    * Scrolls the note grid steps one step backwards. For example if the note grid is configured to show 16
    * steps and is currently showing keys [1..16], calling this method would scroll the note grid to key range
    * [0..15].
    *
    * @since API version 1
    */
   @OscMethod
   void scrollStepsStepBackwards();

   /**
    * Value that reports if the note grid keys can be scrolled further up.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue canScrollKeysUp();

   /**
    * Registers an observer that reports if the note grid keys can be scrolled further up.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #canScrollKeysUp()} instead.
    */
   @Deprecated
   void addCanScrollKeysUpObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the note grid keys can be scrolled further down.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue canScrollKeysDown();

   /**
    * Registers an observer that reports if the note grid keys can be scrolled further down.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #canScrollKeysDown()} instead.
    */
   @Deprecated
   void addCanScrollKeysDownObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the note grid if the note grid steps can be scrolled backwards.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue canScrollStepsBackwards();

   /**
    * Registers an observer that reports if the note grid steps can be scrolled backwards.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #canScrollStepsBackwards()} instead.
    */
   @Deprecated
   void addCanScrollStepsBackwardsObserver(BooleanValueChangedCallback callback);

   /**
    * Value that reports if the note grid if the note grid steps can be scrolled forwards.
    *
    * @since API version 2
    */
   @OscNode
   BooleanValue canScrollStepsForwards();

   /**
    * Registers an observer that reports if the note grid keys can be scrolled forward.
    *
    * @param callback
    *           a callback function that receives a single boolean parameter.
    * @since API version 1
    * @deprecated Use {@link #canScrollStepsForwards()} instead.
    */
   @Deprecated
   void addCanScrollStepsForwardObserver(BooleanValueChangedCallback callback);

   /**
    * @see #toggleStep(int, int, int, int) channel will be 0.
    * @since API version 1
    */
   @OscMethod
   void toggleStep(int x, int y, int insertVelocity);

   /**
    * Toggles the existence of a note in the note grid cell specified by the given x and y arguments.
    *
    * @param channel the MIDI channel, between 0 and 15.
    * @param x
    *           the x position within the note grid, defining the step/time of the target note
    * @param y
    *           the y position within the note grid, defining the key of the target note
    * @param insertVelocity
    *           the velocity of the target note in case a new note gets inserted
    * @since API version 10
    */
   @OscMethod
   void toggleStep(int channel, int x, int y, int insertVelocity);

   /**
    * @see #setStep(int, int, int, int, double) channel will be 0.
    * @since API version 1
    */
   @OscMethod
   void setStep(int x, int y, int insertVelocity, double insertDuration);

   /**
    * Creates a note in the grid cell specified by the given x and y arguments. Existing notes are
    * overwritten.
    *
    * @param x
    *           the x position within the note grid, defining the step/time of the new note
    * @param y
    *           the y position within the note grid, defining the key of the new note
    * @param insertVelocity
    *           the velocity of the new note
    * @param insertDuration
    *           the duration of the new note
    * @since API version 1
    */
   @OscMethod
   void setStep(int channel, int x, int y, int insertVelocity, double insertDuration);

   /**
    * @see #clearStep(int, int, int)
    * @since API version 1
    */
   @OscMethod
   void clearStep(int x, int y);

   /**
    * Removes the note in the grid cell specified by the given x and y arguments. Calling this method does
    * nothing in case no note exists at the given x-y-coordinates.
    *
    * @param channel MIDI channel, from 0 to 15.
    * @param x
    *           the x position within the note grid, defining the step/time of the target note
    * @param y
    *           the y position within the note grid, defining the key of the target note
    * @since API version 10
    */
   @OscMethod
   void clearStep(int channel, int x, int y);

   /**
    * Removes all notes in the grid started on the step x.
    *
    * @since API version 10
    */
   @OscMethod
   void clearStepsAtX(final int channel, int x);

   /**
    * @see #clearStepsAtY(int, int) channel will be 0.
    * @since API version 1
    * @deprecated Use {@link #clearStepsAtY(int, int)} instead.
    */
   @OscMethod
   @Deprecated
   void clearSteps(int y);

   /**
    * Removes all notes in the grid row specified by the given y argument.
    *
    * @param channel MIDI channel, from 0 to 15.
    * @param y the y position within the note grid, defining the key of the target note
    * @since API version 10
    */
   @OscMethod
   void clearStepsAtY(int channel, int y);

   /**
    * Removes all notes in the grid.
    *
    * @since API version 1
    */
   @OscMethod
   void clearSteps();

   /**
    * @see #moveStep(int, int, int, int, int) channel will be 0.
    * @since API version 16
    */
   @OscMethod
   void moveStep(int x, int y, int dx, int dy);

   /**
    * Moves a note in the note grid cell specified by the given x and y arguments to the grid cell (x + dx, y + dy).
    * @param channel MIDI channel, from 0 to 15.
    * @param x
    *           the x position within the note grid, defining the step/time of the target note
    * @param y
    *           the y position within the note grid, defining the key of the target note
    * @param dx
    *           the offset in x direction
    * @param dy
    *           the offset in y direction
    * @since API version 16
    */
   @OscMethod
   void moveStep(int channel, int x, int y, int dx, int dy);

   /**
    * @see #selectStepContents(int, int, int, boolean) channel will be 0.
    * @since API version 1
    */
   @OscMethod
   void selectStepContents(int x, int y, boolean clearCurrentSelection);

   /**
    * Selects the note in the grid cell specified by the given x and y arguments, in case there actually is a
    * note at the given x-y-coordinates.
    *
    * @param channel MIDI channel, from 0 to 15.
    * @param x
    *           the x position within the note grid, defining the step/time of the target note
    * @param y
    *           the y position within the note grid, defining the key of the target note
    * @param clearCurrentSelection
    *           `true` if the existing selection should be cleared, false if the note should be added to
    *           the current selection.
    * @since API version 10
    */
   @OscMethod
   void selectStepContents(int channel, int x, int y, boolean clearCurrentSelection);

   /**
    * Sets the beat time duration that is represented by one note grid step.
    *
    * @param lengthInBeatTime
    *           the length of one note grid step in beat time.
    * @since API version 1
    */
   @OscMethod
   void setStepSize(double lengthInBeatTime);

   /**
    * Registers an observer that reports which note grid steps/keys contain notes.
    *
    * @param callback
    *           A callback function that receives three parameters: 1. the x (step) coordinate within the note
    *           grid (integer), 2. the y (key) coordinate within the note grid (integer), and 3. an integer
    *           value that indicates if the step is empty (`0`) or if a note continues playing (`1`) or starts
    *           playing (`2`).
    * @since API version 1
    * @see #addNoteStepObserver(NoteStepChangedCallback) which will provide more details.
    */
   void addStepDataObserver(StepDataChangedCallback callback);

   /**
    * Registers an observer that reports which note grid steps/keys contain notes.
    *
    * @param callback A callback function that receives the StepInfo.
    * @since API version 10
    */
   void addNoteStepObserver(NoteStepChangedCallback callback);

   /**
    * Value that reports note grid cells as they get played by the sequencer.
    *
    * @since API version 2
    */
   @OscNode
   IntegerValue playingStep();

   /**
    * Registers an observer that reports note grid cells as they get played by the sequencer.
    *
    * @param callback
    *           A callback function that receives a single integer parameter, which reflects the step
    *           coordinate that is played, or -1 if no step is associated with the current playback position.
    * @since API version 1
    * @deprecated Use {@link #playingStep()} instead.
    */
   @Deprecated
   void addPlayingStepObserver(IntegerValueChangedCallback callback);

   /**
    * Updates the name of the clip.
    *
    * @param name
    *           the new clip name
    * @since API version 1
    */
   @OscMethod
   void setName(String name);

   /**
    * Returns shuffle settings of the clip.
    *
    * @return the value object that represents the clips shuffle setting.
    * @since API version 1
    */
   @OscNode
   SettableBooleanValue getShuffle();

   /**
    * Returns accent setting of the clip.
    *
    * @return the ranged value object that represents the clips accent setting.
    * @since API version 1
    */
   @OscNode
   SettableRangedValue getAccent();

   /**
    * Returns the start of the clip in beat time.
    *
    * @return the beat time object that represents the clips start time.
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getPlayStart();

   /**
    * Returns the length of the clip in beat time.
    *
    * @return the beat time object that represents the duration of the clip.
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getPlayStop();

   /**
    * Returns an object that provides access to the loop enabled state of the clip.
    *
    * @return a boolean value object.
    * @since API version 1
    */
   @OscNode
   SettableBooleanValue isLoopEnabled();

   /**
    * Returns the loop start time of the clip in beat time.
    *
    * @return the beat time object that represents the clips loop start time.
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getLoopStart();

   /**
    * Returns the loop length of the clip in beat time.
    *
    * @return the beat time object that represents the clips loop length.
    * @since API version 1
    */
   @OscNode
   SettableBeatTimeValue getLoopLength();

   /**
    * Registers an observer that reports the clip color.
    *
    * @param callback
    *           a callback function that receives three parameters: 1. the red coordinate of the RBG color
    *           value, 2. the green coordinate of the RBG color value, and 3. the blue coordinate of the RBG
    *           color value
    * @since API version 1
    * @deprecated use {@link #color()} instead.
    */
   @Deprecated
   void addColorObserver(ColorValueChangedCallback callback);

   /**
    * Get the color of the clip.
    *
    * @since API version 2
    */
   @OscNode
   SettableColorValue color();

   /**
    * Duplicates the clip.
    *
    * @since API version 1
    */
   @OscMethod
   void duplicate();

   /**
    * Duplicates the content of the clip.
    *
    * @since API version 1
    */
   @OscMethod
   void duplicateContent();

   /**
    * Transposes all notes in the clip by the given number of semitones.
    *
    * @param semitones
    *           the amount of semitones to transpose, can be a positive or negative integer value.
    * @since API version 1
    */
   @OscMethod
   void transpose(int semitones);

   /**
    * Quantize the start time of all notes in the clip according to the given amount. The note lengths remain
    * the same as before.
    *
    * @param amount
    *           a factor between `0` and `1` that allows to morph between the original note start and the
    *           quantized note start.
    * @since API version 1
    */
   @OscMethod
   void quantize(double amount);

   /**
    * Gets the track that contains the clip.
    *
    * @return a track object that represents the track which contains the clip.
    * @since API version 1
    */
   @OscNode
   Track getTrack();

   /**
    * Setting for the default launch quantization.
    *
    * Possible values are "default", "none", "8", "4", "2", "1", "1/2", "1/4", "1/8", "1/16"
    *
    * @since API version 8
    */
   @OscNode
   SettableEnumValue launchQuantization();

   /**
    * Setting "Q to loop" in the inspector.
    *
    * @since API version 8
    */
   @OscNode
   SettableBooleanValue useLoopStartAsQuantizationReference();

   /**
    * Setting "Legato" from the inspector.
    *
    * @since API version 8
    * @deprecated  Use {@link #launchMode()} instead.
    */
   @Deprecated
   SettableBooleanValue launchLegato();

   /**
    * Setting "Launch Mode" from the inspector.
    * Possible values are:
    *  - default
    *  - from_start
    *  - continue_or_from_start
    *  - continue_or_synced
    *  - synced
    *
    * @since API version 9
    */
   @OscNode
   SettableEnumValue launchMode();

   /**
    * Get step info
    *
    * @since API version 10
    */
   @OscNode
   NoteStep getStep(final int channel, int x, int y);

   /**
    * Launches the clip.
    *
    * @since API version 10
    */
   @OscMethod
   void launch();

   /**
    * Launches with the given options:
    *
    * @param quantization possible values are "default", "none", "8", "4", "2", "1", "1/2", "1/4", "1/8", "1/16"
    * @param launchMode possible values are: "default", "from_start", "continue_or_from_start",
    *                   "continue_or_synced", "synced"
    *
    * @since API version 16
    */
   @OscMethod
   void launchWithOptions(final String quantization, final String launchMode);

   /**
    * Get the clip launcher slot containing the clip.
    *
    * @since API version 10
    */
   @OscNode
   ClipLauncherSlot clipLauncherSlot();

   /**
    * Open the detail editor and show the clip.
    *
    * @since API version 18
    */
   @OscMethod
   void showInEditor();

   /**
    * Deletes all automation in this clip.
    *
    * @since API version 12
    */
   //void deleteAllAutomation();

   /**
    * Deletes all automation for the supplied parameter in this clip.
    *
    * @since API version 12
    */
   //void deleteAutomationForParameter(Parameter parameter);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.Color;

/**
 * This interface builds the foundation for storing custom settings in Bitwig Studio documents or in the
 * Bitwig Studio preferences.
 *
 * @since API version 1
 */
public interface Settings
{
   /**
    * Returns a signal setting object, which is shown a push button with the given label in Bitwig Studio.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param action
    *           the action string as displayed on the related Bitwig Studio button, must not be `null`
    * @return the object that encapsulates the requested signal
    * @since API version 1
    */
   Signal getSignalSetting(final String label, final String category, final String action);

   /**
    * Returns a numeric setting that is shown a number field in Bitwig Studio.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param minValue
    *           the minimum value that the user is allowed to enter
    * @param maxValue
    *           the minimum value that the user is allowed to enter
    * @param stepResolution
    *           the step resolution used for the number field
    * @param unit
    *           the string that should be used to display the unit of the number
    * @param initialValue
    *           the initial numeric value of the setting
    * @return the object that encapsulates the requested numeric setting
    * @since API version 1
    */
   SettableRangedValue getNumberSetting(
      final String label,
      final String category,
      final double minValue,
      final double maxValue,
      final double stepResolution,
      final String unit,
      final double initialValue);

   /**
    * Returns an enumeration setting that is shown either as a chooser or as a button group in Bitwig Studio,
    * depending on the number of provided options.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param options
    *           the string array that defines the allowed options for the button group or chooser
    * @param initialValue
    *           the initial string value, must be one of the items specified with the option argument
    * @return the object that encapsulates the requested enum setting
    * @since API version 1
    */
   SettableEnumValue getEnumSetting(
      final String label,
      final String category,
      final String[] options,
      final String initialValue);

   /**
    * Returns an enumeration setting that is shown either as a chooser or as a button group in Bitwig Studio,
    * depending on the number of provided options.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param initialValue
    *           the initial string value, must be one of the items specified with the option argument
    * @return the object that encapsulates the requested enum setting
    * @since API version 11
    */
   SettableEnumValue getEnumSetting(
      final String label,
      final String category,
      final EnumValueDefinition initialValue);

   /**
    * Returns an enumeration setting that is shown either as a chooser or as a button group in Bitwig Studio,
    * depending on the number of provided options.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param value
    *           the settable enum value that the setting will be connected to
    * @return the object that encapsulates the requested enum setting
    * @since API version 11
    */
   SettableEnumValue getEnumSettingForValue(
      final String label,
      final String category,
      final SettableEnumValue value);

   /**
    * Returns a textual setting that is shown as a text field in the Bitwig Studio user interface.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param numChars
    *           the maximum number of character used for the text value
    * @param initialText
    *           the initial text value of the setting
    * @return the object that encapsulates the requested string setting
    * @since API version 1
    */
   SettableStringValue getStringSetting(
      final String label,
      final String category,
      final int numChars,
      final String initialText);

   /**
    * Returns a color setting that is shown in the Bitwig Studio user interface.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param initialColor
    *           the initial color value of the setting
    * @return the object that encapsulates the requested string setting
    * @since API version 5
    */
   SettableColorValue getColorSetting(
      final String label,
      final String category,
      final Color initialColor);

   /**
    * Returns a color setting that is shown in the Bitwig Studio user interface.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param value
    *           the color value to which the setting will be connected to
    * @return the object that encapsulates the requested string setting
    * @since API version 5
    */
   SettableColorValue getColorSettingForValue(
      final String label,
      final String category,
      final SettableColorValue value);

   /**
    * Returns a boolean setting.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param initialValue
    *           the initial color value of the setting
    * @return the object that encapsulates the requested string setting
    * @since API version 7
    */
   SettableBooleanValue getBooleanSetting(
      final String label,
      final String category,
      final boolean initialValue);

   /**
    * Returns an boolean setting.
    *
    * @param label
    *           the name of the setting, must not be `null`
    * @param category
    *           the name of the category, may not be `null`
    * @param value
    *           the settable enum value that the setting will be connected to
    * @return the object that encapsulates the requested boolean setting
    * @since API version 11
    */
   SettableBooleanValue getBooleanSettingForValue(
      final String label,
      final String category,
      final SettableBooleanValue value);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Status of an USB transfer.
 *
 * @since API version 7
 */
public enum UsbTransferStatus
{
   Completed,
   Error,
   TimedOut,
   Cancelled,
   Stall,
   NoDevice,
   Overflow,
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.MemoryBlock;

/**
 * A pipe that can be used to read data.
 *
 * @since API version 7
 */
public interface InputPipe extends Pipe
{
   /**
    * Requests to read some data from this pipe in an asynchronous way (the caller is not blocked). Once some
    * data has been read the callback will be notified on the controller's thread.
    *
    * @param data
    *           A {@link MemoryBlock} that can receive the data that is read.
    * @param callback
    *           A callback that is notified on the controller's thread when the read has completed.
    * @param timeoutInMs
    *           A timeout in milliseconds that will result in an error and termination of the controller if
    *           the read does not happen in this time. For inifnite timeout use 0.
    */
   void readAsync(MemoryBlock data, AsyncTransferCompledCallback callback, int timeoutInMs);

   /**
    * Requests to read some data from this pipe in a synchronous way (the caller is blocked until the transfer
    * completes).
    *
    * @return The number of bytes that was read.
    * @param timeoutInMs
    *           A timeout in milliseconds that will result in an error and termination of the controller if
    *           the read does not happen in this time. For inifinite timeout use 0.
    */
   int read(MemoryBlock data, int timeoutInMs);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * An object that can be a target in a {@link HardwareBinding}.
 *
 * @since API version 10
 */
public interface HardwareBindable
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used to navigate a filter column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserFilterItemBank extends BrowserItemBank<BrowserFilterItem>
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a means of recognizing when a {@link HardwareAction} happens based on some hardware input.
 *
 * For example, when a certain MIDI CC message happens.
 *
 * @see MidiIn#createActionMatcher(String)
 *
 * @since API version 10
 *
 */
public interface HardwareActionMatcher extends HardwareInputMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

public interface SendBank extends Bank<Send>
{

}
-e 


package com.bitwig.extension.controller.api;

/**
 * Opaque type used to match audio I/O devices. Create instances of this type
 * using the factory methods in ControllerHost.
 * @see ControllerHost#createAudioIoDeviceHardwareAddressMatcher(String)
 * @see ControllerHost#createUsbAudioIoDeviceMatcher(int, int)
 */
public interface AudioIoDeviceMatcher
{
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface represent the selected device slot as shown in the Bitwig Studio user
 * interface.
 *
 * @since API version 1
 */
public interface CursorDeviceSlot extends DeviceChain
{
   void selectSlot(String slot);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.UUID;

/**
 * Defines an insertion point where various objects can be inserted as if the user had dragged and dropped
 * them to this insertion point (e.g with the mouse). Some things may not make sense to insert in which case
 * nothing happens.
 *
 * @since API version 7
 */
public interface InsertionPoint
{
   /**
    * Copies the supplied tracks to this insertion point. If it's not possible to do so then this does
    * nothing.
    */
   void copyTracks(Track... tracks);

   /**
    * Moves the supplied tracks to this insertion point. If it's not possible to do so then this does nothing.
    */
   void moveTracks(Track... tracks);

   /**
    * Copies the supplied devices to this insertion point. If it's not possible to do so then this does
    * nothing.
    */
   void copyDevices(Device... devices);

   /**
    * Moves the supplied devices to this insertion point. If it's not possible to do so then this does
    * nothing.
    */
   void moveDevices(Device... devices);

   /**
    * Copies the supplied slots or scenes to this insertion point. If it's not possible to do so then this
    * does nothing.
    */
   void copySlotsOrScenes(ClipLauncherSlotOrScene... clipLauncherSlotOrScenes);

   /**
    * Moves the supplied slots or scenes to this insertion point. If it's not possible to do so then this does
    * nothing.
    */
   void moveSlotsOrScenes(ClipLauncherSlotOrScene... clipLauncherSlotOrScenes);

   /**
    * Inserts the supplied file at this insertion point. If it's not possible to do so then this does nothing.
    */
   void insertFile(String path);

   /**
    * Inserts a Bitwig device with the supplied id at this insertion point. If the device is unknown or it's
    * not possible to insert a device here then his does nothing.
    *
    * @param id
    *           The Bitwig device id to insert
    */
   void insertBitwigDevice(UUID id);

   /**
    * Inserts a VST2 plugin device with the supplied id at this insertion point. If the plug-in is unknown, or
    * it's not possible to insert a plug-in here then his does nothing.
    *
    * @param id
    *           The VST2 plugin id to insert
    */
   void insertVST2Device(int id);

   /**
    * Inserts a VST3 plugin device with the supplied id at this insertion point. If the plug-in is unknown, or
    * it's not possible to insert a plug-in here then his does nothing.
    *
    * @param id
    *           The VST3 plugin id to insert
    */
   void insertVST3Device(String id);

   /**
    * Inserts a CLAP plugin device with the supplied id at this insertion point. If the plug-in is unknown, or
    * it's not possible to insert a plug-in here then his does nothing.
    *
    * @param id
    *           The CLAP plugin id to insert
    *
    * @since API version 18
    */
   void insertCLAPDevice(String id);

   /** Pastes the contents of the clipboard at this insertion point. */
   void paste();

   /** Starts browsing using the popup browser for something to insert at this insertion point. */
   void browse();

   /**
    *
    * @since API version 15
    */
   HardwareActionBindable browseAction();
}
-e 


package com.bitwig.extension.controller.api;

import java.util.UUID;
import java.util.function.DoubleConsumer;
import java.util.function.Supplier;

import com.bitwig.extension.api.Host;
import com.bitwig.extension.callback.ConnectionEstablishedCallback;
import com.bitwig.extension.callback.DataReceivedCallback;
import com.bitwig.extension.controller.ControllerExtensionDefinition;
import com.bitwig.extension.controller.HardwareDeviceMatcher;

/**
 * @include api-changes
 */

/**
 * An interface representing the host application to the script. A singleton instance of this interface is
 * available in the global scope of each script. The methods provided by this interface can be divided in
 * different categories:
 *
 * 1. functions for registering the script in Bitwig Studio, so that it can be listed, detected and configured
 * in the controller preferences. The methods that belong to this group are {@link #defineController},
 * {@link #defineMidiPorts}, {@link #defineSysexIdentityReply} and {@link #addDeviceNameBasedDiscoveryPair}.
 * 2. functions for creating objects that provide access to the various areas of Bitwig Studio to the script.
 * The name of those methods typically start with `create...` 3. functions for printing to the Control Surface
 * Console, which can be opened from the `View` menu of Bitwig Studio. 4. functions for determining the name
 * of the host application, API version, the host operating system and such.
 *
 * The first group of methods should be called on the global scope of the script. The function in the second
 * and third group are typically called from the init method of the script or other handler functions. The
 * last group is probably only required in rare cases and can be called any time.
 *
 * @since API version 1
 */
@SuppressWarnings("restriction")
public interface ControllerHost extends Host
{
   /**
    * Restarts this controller.
    *
    * @since API version 7
    */
   void restart();

   /**
    * Loads the supplied API version into the calling script. This is only intended to be called from a
    * controller script. It cannot be called from a Java controller extension.
    */
   void loadAPI(int version);

   /**
    * Call this method to allow your script to use Beta APIs.
    *
    * Beta APIs are still on development and might not be available in a future version of Bitwig Studio.
    *
    * Turning this flag to true, will flag your extension as being a beta extension which might not work after
    * updating Bitwig Studio.
    *
    * @since API version 7
    */
   void useBetaApi();

   /**
    * Determines whether the calling script should fail if it calls a deprecated method based on the API
    * version that it requested.
    */
   boolean shouldFailOnDeprecatedUse();

   /**
    * Sets whether the calling script should fail if it calls a deprecated method based on the API version
    * that it requested. This is only intended to be called from a controller script. It cannot be called from
    * a Java controller extension.
    */
   void setShouldFailOnDeprecatedUse(boolean value);

   /**
    * Loads the script defined by the supplied path. This is only intended to be called from a controller
    * script. It cannot be called from a Java controller extension.
    */
   void load(String path);

   /**
    * Indicates if the host platform is Windows.
    *
    * @return `true` if the host platform is Windows, `false` otherwise.
    * @since API version 1
    */
   boolean platformIsWindows();

   /**
    * Indicates if the host platform is Apple Mac OS X.
    *
    * @return `true` if the host platform is Mac, `false` otherwise.
    * @since API version 1
    */
   boolean platformIsMac();

   /**
    * Indicates if the host platform is Linux.
    *
    * @return `true` if the host platform is Linux, `false` otherwise.
    * @since API version 1
    */
   boolean platformIsLinux();

   /**
    * Registers a controller script with the given parameters. This function must be called once at the global
    * scope of the script.
    *
    * @param vendor
    *           the name of the hardware vendor. Must not be <code>null</code>.
    * @param name
    *           the name of the controller script as listed in the user interface of Bitwig Studio. Must not
    *           be <code>null</code>.
    * @param version
    *           the version of the controller script. Must not be <code>null</code>.
    * @param uuid
    *           a universal unique identifier (UUID) string that is used to distinguish one script from
    *           another, for example `550e8400-e29b-11d4-a716-446655440000`. Must not be <code>null</code>.
    *           For generating random UUID strings several free web tools are available.
    * @param author
    *           the name of the script author
    * @since API version 1
    */
   void defineController(String vendor, String name, String version, String uuid, String author);

   /**
    * Defines the number of MIDI ports for input and output that the device uses. This method should be called
    * once in the global scope if the script is supposed to exchange MIDI messages with the device, or if the
    * script adds entries to the MIDI input/output choosers in Bitwig Studio. After calling this method the
    * individual port objects can be accessed using {@link #getMidiInPort(int index)} and
    * {@link #getMidiInPort(int index)}.
    *
    * @param numInports
    *           the number of input ports
    * @param numOutports
    *           the number of output ports
    * @since API version 1
    */
   void defineMidiPorts(int numInports, int numOutports);

   /**
    * Returns the MIDI input port with the given index.
    *
    * @param index
    *           the index of the MIDI input port, must be valid.
    * @return the requested MIDI input port
    * @since API version 1
    */
   MidiIn getMidiInPort(int index);

   /**
    * Returns the MIDI output port with the given index.
    *
    * @param index
    *           the index of the MIDI output port, must be valid.
    * @return the requested MIDI output port
    * @since API version 1
    */
   MidiOut getMidiOutPort(int index);

   /**
    * Gets the {@link HardwareDevice} at the specified index. This index corresponds to the index of the
    * {@link HardwareDeviceMatcher} specified in the
    * {@link ControllerExtensionDefinition#listHardwareDevices}
    *
    * @since API version 7
    */
   HardwareDevice hardwareDevice(int index);

   /**
    * Registers patterns which are used to automatically detect hardware devices that can be used with the
    * script.<br/>
    *
    * When the user clicks on the `detect` button in the Bitwig Studio controller preferences dialog, Bitwig
    * Studio searches for connected controller hardware by comparing the parameters passed into this function
    * are compared with the port names of the available MIDI drivers. Found controller scripts are
    * automatically added with their input/output ports configured.<br/>
    *
    * Calling this function is optional, but can also be called multiple times in the global script scope in
    * order to support alternative driver names.
    *
    * @param inputs
    *           the array of strings used to detect MIDI input ports, must not be `null`.
    * @param outputs
    *           the array of strings used to detect MIDI output ports, must not be `null`.
    * @since API version 1
    */
   void addDeviceNameBasedDiscoveryPair(String[] inputs, String[] outputs);

   /**
    * Registers the `Identity Reply Universal SysEx` message (if any) that the MIDI device sends after
    * receiving the `Identity Request Universal SysEx` message (`F0 7E 7F 06 01 F7`), as defined in the MIDI
    * standard.<br/>
    *
    * This function may be called at the global scope of the script, but is optional. Please note that this
    * function is only applicable to scripts with one MIDI input and one MIDI output. Also note that not all
    * MIDI hardware supports SysEx identity messages.
    *
    * @param reply
    *           the `Identity Reply Universal SysEx` message. Must not be <code>null</code>
    * @deprecated
    * @since API version 1
    */
   @Deprecated
   void defineSysexIdentityReply(String reply);

   /**
    * Creates a preferences object that can be used to insert settings into the Controller Preferences panel
    * in Bitwig Studio.
    *
    * @return an object that provides access to custom controller preferences
    * @since API version 1
    */
   Preferences getPreferences();

   /**
    * Creates a document state object that can be used to insert settings into the Studio I/O Panel in Bitwig
    * Studio.
    *
    * @return an object that provides access to custom document settings
    * @since API version 1
    */
   DocumentState getDocumentState();

   /**
    * Returns an object that is used to configure automatic notifications. Bitwig Studio supports automatic
    * visual feedback from controllers that shows up as popup notifications. For example when the selected
    * track or the current device preset was changed on the controller these notifications are shown,
    * depending on your configuration.
    *
    * @return a configuration object used to enable/disable the various automatic notifications supported by
    *         Bitwig Studio
    * @since API version 1
    */
   NotificationSettings getNotificationSettings();

   /**
    * Returns an object for controlling various aspects of the currently selected project.
    *
    * @since API version 1
    */
   Project getProject();

   /**
    * Returns an object for controlling and monitoring the elements of the `Transport` section in Bitwig
    * Studio. This function should be called once during initialization of the script if transport access is
    * desired.
    *
    * @return an object that represents the `Transport` section in Bitwig Studio.
    * @since API version 1
    */
   Transport createTransport();

   /**
    * Returns an object for controlling and monitoring the `Groove` section in Bitwig Studio. This function
    * should be called once during initialization of the script if groove control is desired.
    *
    * @return an object that represents the `Groove` section in Bitwig Studio.
    * @since API version 1
    */
   Groove createGroove();

   /**
    * Returns an object that provides access to general application functionality, including global view
    * settings, the list of open projects, and other global settings that are not related to a certain
    * document.
    *
    * @return an application object.
    * @since API version 1
    */
   Application createApplication();

   /**
    * Returns an object which provides access to the `Arranger` panel of Bitwig Studio. Calling this function
    * is equal to `createArranger(-1)`.
    *
    * @return an arranger object
    * @see #createArranger(int)
    * @since API version 1
    */
   Arranger createArranger();

   /**
    * Returns an object which provides access to the `Arranger` panel inside the specified window.
    *
    * @param window
    *           the index of the window where the arranger panel is shown, or -1 in case the first arranger
    *           panel found on any window should be taken
    * @return an arranger object
    * @since API version 1
    */
   Arranger createArranger(final int window);

   /**
    * Returns an object which provides access to the `Mixer` panel of Bitwig Studio. Calling this function is
    * equal to `createMixer(-1, null)`.
    *
    * @return a `Mixer` object
    * @since API version 1
    */
   Mixer createMixer();

   /**
    * Returns an object which provides access to the `Mixer` panel that belongs to the specified panel layout.
    * Calling this function is equal to `createMixer(-1, panelLayout)`.
    *
    * @param panelLayout
    *           the name of the panel layout that contains the mixer panel, or `null` in case the selected
    *           panel layout in Bitwig Studio should be followed. Empty strings or invalid names are treated
    *           the same way as `null`. To receive the list of available panel layouts see
    *           {@link Application#addPanelLayoutObserver}.
    * @return a `Mixer` object
    * @since API version 1
    */
   Mixer createMixer(final String panelLayout);

   /**
    * Returns an object which provides access to the `Mixer` panel inside the specified window. Calling this
    * function is equal to `createMixer(window, null)`.
    *
    * @param window
    *           the index of the window where the mixer panel is shown, or -1 in case the first mixer panel
    *           found on any window should be taken
    * @return a `Mixer` object
    * @since API version 1
    */
   Mixer createMixer(final int window);

   /**
    * Returns an object which provides access to the `Mixer` panel that matches the specified parameters.
    *
    * @param panelLayout
    *           the name of the panel layout that contains the mixer panel, or `null` in case the selected
    *           panel layout in Bitwig Studio should be followed. Empty strings or invalid names are treated
    *           the same way as `null`. To receive the list of available panel layouts see
    *           {@link Application#addPanelLayoutObserver}.
    * @param window
    *           the index of the window where the mixer panel is shown, or -1 in case the first mixer panel
    *           found on any window should be taken
    * @return a `Mixer` object
    * @since API version 1
    */
   Mixer createMixer(final String panelLayout, final int window);

   /**
    * Returns an object which provides access to the `DetailEditor` panel of Bitwig Studio. Calling this function
    * is equal to `createDetailEditor(-1)`.
    *
    * @return a detail editor object
    * @see #createDetailEditor(int)
    * @since API version 14
    */
   DetailEditor createDetailEditor();

   /**
    * Returns an object which provides access to the `DetailEditor` panel inside the specified window.
    *
    * @param window
    *           the index of the window where the detail editor panel is shown, or -1 in case the first detail
    *           editor panel found on any window should be taken
    * @return a detail editor object
    * @since API version 14
    */
   DetailEditor createDetailEditor(final int window);

   /**
    * Returns a track bank with the given number of tracks, sends and scenes.<br/>
    *
    * A track bank can be seen as a fixed-size window onto the list of tracks in the current document
    * including their sends and scenes, that can be scrolled in order to access different parts of the track
    * list. For example a track bank configured for 8 tracks can show track 1-8, 2-9, 3-10 and so on.<br/>
    *
    * The idea behind the `bank pattern` is that hardware typically is equipped with a fixed amount of channel
    * strips or controls, for example consider a mixing console with 8 channels, but Bitwig Studio documents
    * contain a dynamic list of tracks, most likely more tracks than the hardware can control simultaneously.
    * The track bank returned by this function provides a convenient interface for controlling which tracks
    * are currently shown on the hardware.<br/>
    *
    * Creating a track bank using this method will consider all tracks in the document, including effect
    * tracks and the master track. Use {@link #createMainTrackBank} or {@link #createEffectTrackBank} in case
    * you are only interested in tracks of a certain kind.
    *
    * @param numTracks
    *           the number of tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see Track#createTrackBank
    * @see #createMainTrackBank
    * @see #createEffectTrackBank
    * @since API version 1
    */
   TrackBank createTrackBank(final int numTracks, final int numSends, final int numScenes);

   /**
    * Returns a track bank with the given number of child tracks, sends and scenes.<br/>
    *
    * A track bank can be seen as a fixed-size window onto the list of tracks in the connected track group
    * including their sends and scenes, that can be scrolled in order to access different parts of the track
    * list. For example a track bank configured for 8 tracks can show track 1-8, 2-9, 3-10 and so on.<br/>
    *
    * The idea behind the `bank pattern` is that hardware typically is equipped with a fixed amount of channel
    * strips or controls, for example consider a mixing console with 8 channels, but Bitwig Studio documents
    * contain a dynamic list of tracks, most likely more tracks than the hardware can control simultaneously.
    * The track bank returned by this function provides a convenient interface for controlling which tracks
    * are currently shown on the hardware.<br/>
    *
    * Creating a track bank using this method will consider all tracks in the document, including effect
    * tracks and the master track. Use {@link #createMainTrackBank} or {@link #createEffectTrackBank} in case
    * you are only interested in tracks of a certain kind.
    *
    * @param numTracks
    *           the number of child tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @param hasFlatTrackList
    *           specifies whether the track bank should operate on a flat list of all nested child tracks or
    *           only on the direct child tracks of the connected group track.
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see #createMainTrackBank
    * @see #createEffectTrackBank
    * @since API version 1
    */
   TrackBank createTrackBank(
      final int numTracks,
      final int numSends,
      final int numScenes,
      final boolean hasFlatTrackList);

   /**
    * Returns a track bank with the given number of tracks, sends and scenes. Only audio tracks, instrument
    * tracks and hybrid tracks are considered. For more information about track banks and the `bank pattern`
    * in general, see the documentation for {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see Track#createMainTrackBank
    * @see #createTrackBank
    * @see #createEffectTrackBank
    * @since API version 1
    */
   TrackBank createMainTrackBank(final int numTracks, final int numSends, final int numScenes);

   /**
    * Returns a track bank with the given number of effect tracks, sends and scenes. Only effect tracks are
    * considered. For more information about track banks and the `bank pattern` in general, see the
    * documentation for {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of tracks spanned by the track bank
    * @param numSends
    *           the number of sends spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see Track#createEffectTrackBank
    * @see #createTrackBank
    * @see #createMainTrackBank
    * @since API version 18
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numSends, final int numScenes);

   /**
    * Returns a track bank with the given number of effect tracks and scenes. Only effect tracks are
    * considered. For more information about track banks and the `bank pattern` in general, see the
    * documentation for {@link #createTrackBank}.
    *
    * @param numTracks
    *           the number of tracks spanned by the track bank
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @return an object for bank-wise navigation of tracks, sends and scenes
    * @see Track#createEffectTrackBank
    * @see #createTrackBank
    * @see #createMainTrackBank
    * @since API version 1
    */
   TrackBank createEffectTrackBank(final int numTracks, final int numScenes);

   /**
    * Returns an object that represents the master track of the document.
    *
    * @param numScenes
    *           the number of scenes for bank-wise navigation of the master tracks clip launcher slots.
    * @return an object representing the master track.
    * @see Track#createMasterTrack
    * @since API version 1
    */
   MasterTrack createMasterTrack(final int numScenes);

   /**
    * Returns an object that represents the cursor item of the arranger track selection.
    *
    * @param numSends
    *           the number of sends for bank-wise navigation of the sends that are associated with the track
    *           selection
    * @param numScenes
    *           the number of scenes for bank-wise navigation of the clip launcher slots that are associated
    *           with the track selection
    * @return an object representing the currently selected arranger track (in the future also multiple
    *         tracks)
    * @since API version 1
    * @deprecated Use {@link #createCursorTrack(int, int)} instead.
    */
   @Deprecated
   CursorTrack createArrangerCursorTrack(final int numSends, final int numScenes);

   /**
    * Returns an object that represents a named cursor track, that is independent from the arranger or mixer
    * track selection in the user interface of Bitwig Studio.
    *
    * @param name
    *           the name of the track cursor
    * @param numSends
    *           the number of sends for bank-wise navigation of the sends that are associated with the track
    *           selection
    * @param numScenes
    *           the number of scenes for bank-wise navigation of the clip launcher slots that are associated
    *           with the track selection
    * @return an object representing the currently selected arranger track (in the future also multiple
    *         tracks).
    * @since API version 1
    * @deprecated use {@link #createCursorTrack(String, String, int, int, boolean)} instead.
    */
   @Deprecated
   CursorTrack createCursorTrack(final String name, final int numSends, final int numScenes);

   /**
    * Returns an object that represents a named cursor track, that is independent from the arranger or mixer
    * track selection in the user interface of Bitwig Studio.
    *
    * @param name
    *           the name of the track cursor
    * @param numSends
    *           the number of sends for bank-wise navigation of the sends that are associated with the track
    *           selection
    * @param numScenes
    *           the number of scenes for bank-wise navigation of the clip launcher slots that are associated
    *           with the track selection
    * @return an object representing the currently selected arranger track (in the future also multiple
    *         tracks).
    * @since API version 1
    */
   CursorTrack createCursorTrack(
      final String id,
      String name,
      final int numSends,
      final int numScenes,
      boolean shouldFollowSelection);

   /**
    * Returns a scene bank with the given number of scenes.<br/>
    *
    * A scene bank can be seen as a fixed-size window onto the list of scenes in the current document, that
    * can be scrolled in order to access different parts of the scene list. For example a scene bank
    * configured for 8 scenes can show scene 1-8, 2-9, 3-10 and so on.<br/>
    *
    * The idea behind the `bank pattern` is that hardware typically is equipped with a fixed amount of channel
    * strips or controls, for example consider a mixing console with 8 channels, but Bitwig Studio documents
    * contain a dynamic list of scenes, most likely more scenes than the hardware can control simultaneously.
    * The scene bank returned by this function provides a convenient interface for controlling which scenes
    * are currently shown on the hardware.<br/>
    *
    * @param numScenes
    *           the number of scenes spanned by the track bank
    * @return an object for bank-wise navigation of scenes
    * @since API version 1
    */
   SceneBank createSceneBank(final int numScenes);

   /**
    * Returns an object that represents the cursor device in devices selections made by the user in Bitwig
    * Studio. Calling this method is equal to the following code: {@code
    * var cursorTrack = createArrangerCursorTrack(numSends, numScenes);
    * var cursorDevice = cursorTrack.createCursorDevice();
    * } To create a custom device selection that is not connected to the main device selection in the user
    * interface, call {@link Track#createCursorDevice(String) cursorTrack.createCursorDevice(String name)}.
    *
    * @return an object representing the currently selected device.
    * @see Track#createCursorDevice()
    * @see Track#createCursorDevice(String)
    * @see #createEditorCursorDevice(int numSends)
    * @since API version 1
    * @deprecated
    */
   @Deprecated
   CursorDevice createEditorCursorDevice();

   /**
    * Returns an object that represents the cursor device in devices selections made by the user in Bitwig
    * Studio. Calling this method is equal to the following code: {@code
    * var cursorTrack = createArrangerCursorTrack(numSends, numScenes);
    * var cursorDevice = cursorTrack.createCursorDevice();
    * } To create a custom device selection that is not connected to the main device selection in the user
    * interface, call {@link Track#createCursorDevice(String) cursorTrack.createCursorDevice(String name)}.
    *
    * @param numSends
    *           the number of sends that are simultaneously accessible in nested channels.
    * @return an object representing the currently selected device.
    * @deprecated Use cursorTrack.createCursorDevice().
    * @see Track#createCursorDevice()
    * @see Track#createCursorDevice(String)
    * @since API version 1
    */
   @Deprecated
   CursorDevice createEditorCursorDevice(int numSends);

   /**
    * @deprecated Use {@link #createLauncherCursorClip(int, int)} or
    *             {@link #createArrangerCursorClip(int, int)} instead.
    * @since API version 1
    */
   @Deprecated
   Clip createCursorClip(final int gridWidth, final int gridHeight);

   /**
    * Returns a clip object that represents the cursor of the launcher clip selection. The gridWidth and
    * gridHeight parameters specify the grid dimensions used to access the note content of the clip.
    *
    * @param gridWidth
    *           the number of steps spanned by one page of the note content grid.
    * @param gridHeight
    *           the number of keys spanned by one page of the note content grid.
    * @return an object representing the currently selected cursor clip
    * @since API version 1
    */
   Clip createLauncherCursorClip(final int gridWidth, final int gridHeight);

   /**
    * Returns a clip object that represents the cursor of the arranger clip selection. The gridWidth and
    * gridHeight parameters specify the grid dimensions used to access the note content of the clip.
    *
    * @param gridWidth
    *           the number of steps spanned by one page of the note content grid.
    * @param gridHeight
    *           the number of keys spanned by one page of the note content grid.
    * @return an object representing the currently selected cursor clip
    * @since API version 1
    */
   Clip createArrangerCursorClip(final int gridWidth, final int gridHeight);

   /**
    * Returns an object that is used to define a bank of custom user controls. These controls are available to
    * the user for free controller assignments and are typically used when bank-wise navigation is
    * inconvenient.
    *
    * @param numControllers
    *           the number of controls that are available for free assignments
    * @return An object that represents a set of custom user controls.
    * @since API version 1
    */
   UserControlBank createUserControls(final int numControllers);

   /**
    * The last clicked parameter in the gui. Can also be pinned
    * @param id used for persistent state. Extensions should use different IDs for different objects, but should try to
    *           not change IDs in between different versions.
    * @param name user facing name, used for example in context menus. Extensions may change the name in between
    *             different versions.
    * @since API version 20
    */
   LastClickedParameter createLastClickedParameter(final String id, final String name);

   /**
    * Schedules the given callback function for execution after the given delay. For timer applications call
    * this method once initially and then from within the callback function.
    *
    * @param callback
    *           the callback function that will be called
    * @param args
    *           that array of arguments that gets passed into the callback function, may be `null`
    * @param delay
    *           the duration after which the callback function will be called in milliseconds
    * @deprecated
    * @since API version 1
    */
   @Deprecated
   void scheduleTask(Object callback, Object[] args, long delay);

   /**
    * Schedules the given callback function for execution after the given delay. For timer applications call
    * this method once initially and then from within the callback function.
    *
    * @param callback
    *           the callback function that will be called
    * @param delay
    *           the duration after which the callback function will be called in milliseconds
    * @since API version 2
    */
   void scheduleTask(Runnable callback, long delay);

   /**
    * Requests that the driver's flush method gets called.
    *
    * @since API version 2
    */
   void requestFlush();

   /**
    * Prints the given string in the control surface console window. The console window can be opened in the
    * view menu of Bitwig Studio.
    *
    * @param s
    *           the string to be printed
    * @since API version 1
    */
   void println(String s);

   /**
    * Prints the given string in the control surface console window using a text style that highlights the
    * string as error. The console window can be opened in the view menu of Bitwig Studio.
    *
    * @param s
    *           the error string to be printed
    * @since API version 1
    */
   void errorln(String s);

   /**
    * Shows a temporary text overlay on top of the application GUI, that will fade-out after a short interval.
    * If the overlay is already shown, it will get updated with the given text.
    *
    * @param text
    *           the text to be shown
    * @since API version 1
    */
   void showPopupNotification(String text);

   /**
    * Opens a TCP (Transmission Control Protocol) host socket for allowing network connections from other
    * hardware and software.
    *
    * @param name
    *           a meaningful name that describes the purpose of this connection.
    * @param defaultPort
    *           the port that should be used for the connection. If the port is already in use, then another
    *           port will be used. Check {@link RemoteSocket#getPort()} on the returned object to be sure.
    * @return the object that represents the socket
    * @since API version 1
    */
   RemoteSocket createRemoteConnection(String name, int defaultPort);

   /**
    * Connects to a remote TCP (Transmission Control Protocol) socket.
    *
    * @param host
    *           the host name or IP address to connect to.
    * @param port
    *           the port to connect to
    * @param callback
    *           the callback function that gets called when the connection gets established. A single
    *           {@link RemoteConnection} parameter is passed into the callback function.
    * @since API version 1
    */
   void connectToRemoteHost(String host, int port, ConnectionEstablishedCallback callback);

   /**
    * Sends a UDP (User Datagram Protocol) packet with the given data to the specified host.
    *
    * @param host
    *           the destination host name or IP address
    * @param port
    *           the destination port
    * @param data
    *           the data to be send. When creating a numeric byte array in JavaScript, the byte values must be
    *           signed (in the range -128..127).
    * @since API version 1
    */
   void sendDatagramPacket(String host, int port, byte[] data);

   /**
    * Adds an observer for incoming UDP (User Datagram Protocol) packets on the selected port.
    *
    * @param name
    *           a meaningful name that describes the purpose of this observer.
    * @param port
    *           the port that should be used
    * @param callback
    *           the callback function that gets called when data arrives. The function receives a single
    *           parameter that contains the data byte array.
    *
    * @return true if was possible to bind the port, false otherwise
    * @since API version 1
    */
   boolean addDatagramPacketObserver(String name, int port, DataReceivedCallback callback);

   /**
    * @deprecated Use {@link #defineController(String, String, String, String, String)} instead.
    * @since API version 1
    */
   @Deprecated
   void defineController(String vendor, String name, String version, String uuid);

   /**
    * @deprecated Use {@link #createTransport} instead.
    * @since API version 1
    */
   @Deprecated
   Transport createTransportSection();

   /**
    * @since API version 1
    */
   CursorTrack createCursorTrack(final int numSends, final int numScenes);

   /**
    * @deprecated Use {@link #createGroove()} instead.
    * @since API version 1
    */
   @Deprecated
   Groove createGrooveSection();

   /**
    * @deprecated Use {@link #createApplication()} instead.
    * @since API version 1
    */
   @Deprecated
   Application createApplicationSection();

   /**
    * @deprecated Use {@link #createArranger(int)} instead.
    * @since API version 1
    */
   @Deprecated
   Arranger createArrangerSection(final int screenIndex);

   /**
    * @deprecated Use {@link #createMixer(String, int)} instead.
    * @since API version 1
    */
   @Deprecated
   Mixer createMixerSection(final String perspective, final int screenIndex);

   /**
    * @deprecated Use {@link #createTrackBank(int, int, int)} instead.
    * @since API version 1
    */
   @Deprecated
   TrackBank createTrackBankSection(final int numTracks, final int numSends, final int numScenes);

   /**
    * @deprecated Use {@link #createMainTrackBank(int, int, int)} instead.
    * @since API version 1
    */
   @Deprecated
   TrackBank createMainTrackBankSection(final int numTracks, final int numSends, final int numScenes);

   /**
    * @deprecated Use {@link #createEffectTrackBank(int, int)} instead.
    * @since API version 1
    */
   @Deprecated
   TrackBank createEffectTrackBankSection(final int numTracks, final int numScenes);

   /**
    * @deprecated Use {@link #createArrangerCursorTrack} instead.
    * @since API version 1
    */
   @Deprecated
   CursorTrack createCursorTrackSection(final int numSends, final int numScenes);

   /**
    * @deprecated Use {@link #createMasterTrack(int)} instead.
    * @since API version 1
    */
   @Deprecated
   Track createMasterTrackSection(final int numScenes);

   /**
    * @deprecated Use {@link #createCursorClip(int, int)} instead.
    * @since API version 1
    */
   @Deprecated
   Clip createCursorClipSection(final int gridWidth, final int gridHeight);

   /**
    * @deprecated Use {@link #createEditorCursorDevice createEditorCursorDevice()} instead.
    * @since API version 1
    */
   @Deprecated
   CursorDevice createCursorDeviceSection(final int numControllers);

   /**
    * @deprecated Use {@link #createEditorCursorDevice createEditorCursorDevice()} instead.
    * @since API version 1
    */
   @Deprecated
   CursorDevice createCursorDevice();

   /**
    * @deprecated Use {@link #createUserControls(int)} instead.
    * @since API version 1
    */
   @Deprecated
   UserControlBank createUserControlsSection(final int numControllers);

   /**
    * @deprecated Use {@link #defineSysexIdentityReply(String)} instead.
    * @since API version 1
    */
   @Deprecated
   void defineSysexDiscovery(String request, String reply);

   /**
    * Creates a {@link PopupBrowser} that represents the pop-up browser in Bitwig Studio.
    *
    * @since API version 2
    */
   PopupBrowser createPopupBrowser();

   /**
    * {@link BeatTimeFormatter} used to format beat times by default. This will be used to format beat times
    * when asking for a beat time in string format without providing any formatting options. For example by
    * calling {@link BeatTimeValue#get()}.
    *
    * @since API version 2
    */
   BeatTimeFormatter defaultBeatTimeFormatter();

   /**
    * Sets the {@link BeatTimeFormatter} to use by default for formatting beat times.
    *
    * @see #defaultBeatTimeFormatter()
    * @since API version 2
    */
   void setDefaultBeatTimeFormatter(BeatTimeFormatter formatter);

   /**
    * Creates a {@link BeatTimeFormatter} that can be used to format beat times.
    *
    * @param separator
    *           the character used to separate the segments of the formatted beat time, typically ":", "." or
    *           "-"
    * @param barsLen
    *           the number of digits reserved for bars
    * @param beatsLen
    *           the number of digits reserved for beats
    * @param subdivisionLen
    *           the number of digits reserved for beat subdivisions
    * @param ticksLen
    *           the number of digits reserved for ticks
    *
    * @since API version 2
    */
   BeatTimeFormatter createBeatTimeFormatter(
      final String separator,
      final int barsLen,
      final int beatsLen,
      final int subdivisionLen,
      final int ticksLen);

   /**
    * Creates a {@link HardwareSurface} that can contain hardware controls.
    *
    * @since API version 10
    */
   HardwareSurface createHardwareSurface();

   /**
    * Creates a {@link HardwareActionMatcher} that is matched by either of the 2 supplied action matchers.
    *
    * @since API version 10
    */
   HardwareActionMatcher createOrHardwareActionMatcher(
      HardwareActionMatcher matcher1,
      HardwareActionMatcher matcher2);

   /**
    * Creates a {@link RelativeHardwareValueMatcher} that is matched by either of the 2 supplied action
    * matchers.
    *
    * @since API version 10
    */
   RelativeHardwareValueMatcher createOrRelativeHardwareValueMatcher(
      RelativeHardwareValueMatcher matcher1,
      RelativeHardwareValueMatcher matcher2);

   /**
    * Creates a {@link AbsoluteHardwareValueMatcher} that is matched by either of the 2 supplied action
    * matchers.
    *
    * @since API version 10
    */
   AbsoluteHardwareValueMatcher createOrAbsoluteHardwareValueMatcher(
      AbsoluteHardwareValueMatcher matcher1,
      AbsoluteHardwareValueMatcher matcher2);

   /**
    * An object that can be used to generate useful MIDI expression strings which can be used in
    * {@link MidiIn#createActionMatcher(String)} and other related methods.
    *
    * @since API version 10
    */
   MidiExpressions midiExpressions();

   /**
    * Creates a {@link HardwareActionBindable} that can be bound to some {@link HardwareAction} (such as a
    * button press) and when that action occurs the supplied {@link Runnable} will be run.
    *
    * This is exactly the same as {@link #createAction(Runnable, Supplier)} but does not use parameter
    * overloading so can be used from non type safe languages like JavaScript.
    *
    * @param runnable
    *           The runnable to be run
    * @param descriptionProvider
    *           Provider that can provide a description of what the runnable does (used for showing onscreen
    *           feedback or help to the user).
    *
    * @since API version 18
    */
   default HardwareActionBindable createCallbackAction(final Runnable runnable, final Supplier<String> descriptionProvider)
   {
      return createAction(runnable, descriptionProvider);
   }

   /**
    * Creates a {@link HardwareActionBindable} that can be bound to some {@link HardwareAction} (such as a
    * button press) and when that action occurs the supplied {@link Runnable} will be run.
    *
    * @param runnable
    *           The runnable to be run
    * @param descriptionProvider
    *           Provider that can provide a description of what the runnable does (used for showing onscreen
    *           feedback or help to the user).
    *
    * @since API version 10
    */
   HardwareActionBindable createAction(Runnable runnable, Supplier<String> descriptionProvider);

   /**
   * Creates a {@link HardwareActionBindable} that can be bound to some {@link HardwareAction} (such as a
   * button press) and when that action occurs the supplied {@link Runnable} will be run.
   *
   * This is exactly the same as {@link #createAction(DoubleConsumer, Supplier)} but does not use parameter
   * overloading so can be used from non type safe languages like JavaScript.
   *
   * @param actionPressureConsumer
   *           Consumer that will be notified of the pressure of the action
   * @param descriptionProvider
   *           Provider that can provide a description of what the runnable does (used for showing onscreen
   *           feedback or help to the user).
   *
   * @since API version 18
   */
  default HardwareActionBindable createPressureCallbackAction(
     final DoubleConsumer actionPressureConsumer,
     final Supplier<String> descriptionProvider)
  {
     return createAction(actionPressureConsumer, descriptionProvider);
  }

   /**
    * Creates a {@link HardwareActionBindable} that can be bound to some {@link HardwareAction} (such as a
    * button press) and when that action occurs the supplied {@link Runnable} will be run
    *
    * @param actionPressureConsumer
    *           Consumer that will be notified of the pressure of the action
    * @param descriptionProvider
    *           Provider that can provide a description of what the runnable does (used for showing onscreen
    *           feedback or help to the user).
    *
    * @since API version 10
    */
   HardwareActionBindable createAction(
      DoubleConsumer actionPressureConsumer,
      Supplier<String> descriptionProvider);

   /**
    * Creates a {@link RelativeHardwarControlBindable} that can be used to step forwards or backwards when a
    * {@link RelativeHardwareControl} is adjusted. A step is defined by the
    * {@link RelativeHardwareControl#setStepSize(double)}.
    *
    * @param stepForwardsAction
    *           The action that should happen when stepping forwards
    * @param stepBackwardsAction
    *           The action that should happen when stepping backwards
    *
    * @since API version 10
    */
   RelativeHardwarControlBindable createRelativeHardwareControlStepTarget(
      HardwareActionBindable stepForwardsAction,
      HardwareActionBindable stepBackwardsAction);

   /**
    * Creates a {@link RelativeHardwarControlBindable} that can be used to adjust some value in an arbitrary
    * way.
    *
    * @param adjustmentConsumer
    *           A consumer that will receive the relative adjustment amount when bound to a
    *           {@link RelativeHardwareControl}.
    *
    * @since API version 10
    */
   RelativeHardwarControlBindable createRelativeHardwareControlAdjustmentTarget(
      DoubleConsumer adjustmentConsumer);

   /**
    * Creates a {@link AbsoluteHardwarControlBindable} that can be used to adjust some value in an arbitrary
    * way.
    *
    * @param adjustmentConsumer
    *           A consumer that will receive the absolute adjustment amount when bound to an
    *           {@link AbsoluteHardwareControl}.
    *
    * @since API version 10
    */
   AbsoluteHardwarControlBindable createAbsoluteHardwareControlAdjustmentTarget(
      DoubleConsumer adjustmentConsumer);

   /**
    * It will delete multiple object within one undo step.
    *
    * @since API version 10
    */
   void deleteObjects(String undoName, DeleteableObject... objects);

   /**
    * It will delete multiple object within one undo step.
    *
    * @since API version 10
    */
   void deleteObjects(DeleteableObject... objects);

   /**
    * It will duplicate multiple object within one undo step.
    *
    * @since API version 19
    */
   void duplicateObjects(String undoName, DuplicableObject... objects);

   /**
    * It will duplicate multiple object within one undo step.
    *
    * @since API version 19
    */
   void duplicateObjects(DuplicableObject... objects);

   /**
    * Creates a {@link DeviceMatcher} that will match any instrument.
    *
    * @since API version 12
    */
   DeviceMatcher createInstrumentMatcher();

   /**
    * Creates a {@link DeviceMatcher} that will match any audio effect.
    *
    * @since API version 12
    */
   DeviceMatcher createAudioEffectMatcher();

   /**
    * Creates a {@link DeviceMatcher} that will match any note effect.
    *
    * @since API version 12
    */
   DeviceMatcher createNoteEffectMatcher();

   /**
    * Creates a {@link DeviceMatcher} that will match any Bitwig native device with the supplied id.
    *
    * @since API version 12
    */
   DeviceMatcher createBitwigDeviceMatcher(UUID id);

   /**
    * Creates a {@link DeviceMatcher} that will match any VST2 plug-in with the supplied id.
    *
    * @since API version 12
    */
   DeviceMatcher createVST2DeviceMatcher(int id);

   /**
    * Creates a {@link DeviceMatcher} that will match any VST3 plug-in with the supplied id.
    *
    * @since API version 12
    */
   DeviceMatcher createVST3DeviceMatcher(String id);

   /**
    * Creates a {@link DeviceMatcher} that will only match devices that are currently active.
    *
    * @since API version 12
    */
   DeviceMatcher createActiveDeviceMatcher();

   /**
    * Creates a {@link DeviceMatcher} that will only match devices if it is the last device in the chain.
    *
    * @since API version 12
    */
   DeviceMatcher createFirstDeviceInChainMatcher();

   /**
    * Creates a {@link DeviceMatcher} that will only match devices if it is the last device in the chain.
    *
    * @since API version 12
    */
   DeviceMatcher createLastDeviceInChainMatcher();

   /**
    * Creates a {@link DeviceMatcher} that matches a device if any of the supplied matchers match the device.
    *
    * @since API version 12
    */
   DeviceMatcher createOrDeviceMatcher(DeviceMatcher... deviceMatchers);

   /**
    * Creates a {@link DeviceMatcher} that matches a device if all the supplied matchers match the device.
    *
    * @since API version 12
    */
   DeviceMatcher createAndDeviceMatcher(DeviceMatcher... deviceMatchers);

   /**
    * Creates a {@link DeviceMatcher} that matches a device if the supplied matcher does not match the device.
    *
    * @since API version 12
    */
   DeviceMatcher createNotDeviceMatcher(DeviceMatcher deviceMatcher);

   /**
    * Creates a {@link MasterRecorder}.
    *
    * @since API version 20
    */
   MasterRecorder createMasterRecorder();

   /**
    * Creates a matcher that matches devices with the given hardware address.
    * @since API version 22
    */
   AudioIoDeviceMatcher createAudioIoDeviceHardwareAddressMatcher(final String hardwareAddress);

   /**
    * Creates a matcher that matches devices with the given USB vendor and product id.
    * @since API version 22
    */
   AudioIoDeviceMatcher createUsbAudioIoDeviceMatcher(final int vendorId, final int productId);

   /**
    * Creates a {@link AudioHardwareIoInfo} for the specified output.
    * @since API version 22
    * @param channels zero based channel indices
    */
   AudioHardwareIoInfo createAudioHardwareOutputInfo(final AudioIoDeviceMatcher matcher, final int[] channels);

   /**
    * Creates a {@link AudioHardwareIoInfo} for the specified input.
    * @since API version 22
    * @param channels zero based channel indices
    */

   AudioHardwareIoInfo createAudioHardwareInputInfo(final AudioIoDeviceMatcher matcher, final int[] channels);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * Instances of this interface are used for browsing material according to a certain type. Possible material
 * types are devices, presets, samples, multi-samples, clips, or files from your music collection.
 *
 * In Bitwig Studio's contextual browser window the search sessions for the various material kinds are shown
 * in tabs. Just like the tabs in the browser window, instances of this interface provide access to multiple
 * filter columns and one result column. The filter columns are used to control the content of the results
 * column.
 *
 * @since API version 1
 * @deprecated Use {@link PopupBrowser} instead.
 */
@Deprecated
public interface BrowsingSession extends ObjectProxy
{
   /**
    * Registers an observer that reports if the browser session is available for the current context.
    *
    * @param callback
    *           a callback function that receives a single boolean argument.
    * @since API version 1
    * @deprecated Use {@link #exists()} instead.
    */
   @Deprecated
   void addIsAvailableObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the browser session is currently active.
    *
    * @param callback
    *           a callback function that receives a single boolean argument.
    * @since API version 1
    */
   void addIsActiveObserver(BooleanValueChangedCallback callback);

   /**
    * Activates the given search session, same as calling {@link Browser#activateSession
    * Browser#activateSession(this)}. Please note that only one search session can be active at a time.
    *
    * @since API version 1
    * @see Browser#activateSession
    */
   void activate();

   /**
    * Returns an object that represents the column which shows the results according to the current filter
    * settings in Bitwig Studio's contextual browser.
    *
    * @return the requested results browser column.
    * @since API version 1
    */
   BrowserResultsColumn getResults();

   /**
    * Returns an object used for navigating the entries in the results column of Bitwig Studio's contextual
    * browser.
    *
    * @return the requested cursor object.
    * @since API version 1
    */
   CursorBrowserResultItem getCursorResult();

   /**
    * Returns an object that represents the currently loaded material item.
    *
    * @return the requested settled result object
    * @since API version 1
    */
   BrowserResultsItem getSettledResult();

   /**
    * Returns an object that can be used to navigate over the various filter sections of the browsing session.
    *
    * @return the requested filter cursor object
    */
   CursorBrowserFilterColumn getCursorFilter();

   /**
    * Returns an object that provided bank-wise navigation of filter columns.
    *
    * @return the requested file column bank object
    * @since API version 1
    * @param numColumns
    *           the number of columns that are simultaneously accessible.
    */
   BrowserFilterColumnBank createFilterBank(int numColumns);

   /**
    * Value that reports the number of results available for the current filter settings.
    *
    * @since API version 2
    */
   IntegerValue hitCount();

   /**
    * Registers an observer that reports the number of results available for the current filter settings.
    *
    * @param callback
    *           a callback function that receives a single integer argument.
    * @since API version 1
    * @deprecated Use {@link #hitCount()} instead.
    */
   @Deprecated
   void addHitCountObserver(IntegerValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a means of recognizing when a relative value is input by the user (for example, when turning a continuous knob).
 *
 * For example, when a certain MIDI CC message happens.
 *
 * @see MidiIn#createRelative2sComplementCCValueMatcher(int, int, int)
 * @see MidiIn#createRelativeBinOffsetCCValueMatcher(int, int, int)
 * @see MidiIn#createRelativeSignedBit2CCValueMatcher(int, int, int)
 *
 * @since API version 10
 *
 */
public interface RelativeHardwareValueMatcher extends ContinuousHardwareValueMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

public enum UsbTransferType
{
   BULK, INTERRUPT/*, CONTROL*/;
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a relative position of something to something else.
 *
 * @since API version 10
 */
public enum RelativePosition
{
   ABOVE,
   BELOW,
   LEFT,
   RIGHT,
   INSIDE
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are used for navigating the various browsing sessions of Bitwig Studio's
 * contextual browser.
 *
 * @since API version 1
 */
public interface CursorBrowsingSession extends GenericBrowsingSession, Cursor
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Object that describes the content of a step at a given position: x for the time, and y for the key.
 *
 * @since API version 10
 */
public interface NoteStep
{
   /**
    * @since API version 10
    */
   enum State
   {
      Empty, NoteOn, NoteSustain,
   }

   /**
    * @return the position of the step (time)
    * @since API version 10
    */
   @OscMethod
   int x();

   /**
    * @return the position of the step (key)
    * @since API version 10
    */
   @OscMethod
   int y();

   /**
    * @return the note's channel, in the range 0..15.
    * @since API version 10
    */
   @OscMethod
   int channel();

   /**
    * @return the state of the step, it lets you know if a note starts.
    * @since API version 10
    */
   @OscMethod
   State state();

   /**
    * @return the velocity of the step, in the range 0..1
    * @since API version 10
    */
   @OscMethod
   double velocity();

   /**
    * If there is a note started at this position, it will update the velocity of the note.
    * @param velocity between 0 and 1
    * @since API version 10
    */
   @OscMethod
   void setVelocity(double velocity);

   /**
    * @return the release velocity of the step, in the range 0..1
    * @since API version 10
    */
   @OscMethod
   double releaseVelocity();

   /**
    * If there is a note started at this position, it will update the release velocity of the note.
    * @param velocity between 0 and 1
    * @since API version 10
    */
   @OscMethod
   void setReleaseVelocity(double velocity);

   /**
    * @since API version 14
    */
   @OscMethod
   double velocitySpread();

   /**
    * @since API version 14
    * @param amount velocity spread amount in the range 0..1
    */
   @OscMethod
   void setVelocitySpread(double amount);

   /**
    * @return the duration of the step in beats
    * @since API version 10
    */
   @OscMethod
   double duration();

   /**
    * If there is a note started at this position, it will update the duration of the note.
    * @param duration in beats
    * @since API version 10
    */
   @OscMethod
   void setDuration(double duration);

   /**
    * @return the pan of the step in the range -1..1
    * @since API version 10
    */
   @OscMethod
   double pan();

   /**
    * If there is a note started at this position, it will update the panning of the note.
    * @param pan -1 for left, +1 for right
    * @since API version 10
    */
   @OscMethod
   void setPan(double pan);

   /**
    * @return the timbre of the step, in the range -1..1
    * @since API version 10
    */
   @OscMethod
   double timbre();

   /**
    * If there is a note started at this position, it will update the timbre of the note.
    * @param timbre from -1 to +1
    * @since API version 10
    */
   @OscMethod
   void setTimbre(double timbre);

   /**
    * @return the pressure of the step, in the range 0..1
    * @since API version 10
    */
   @OscMethod
   double pressure();

   /**
    * If there is a note started at this position, it will update the pressure of the note.
    * @param pressure from 0 to +1
    * @since API version 10
    */
   @OscMethod
   void setPressure(double pressure);

   /**
    * @return the gain of the step, in the range 0..1
    * @since API version 10
    */
   @OscMethod
   double gain();

   /**
    * If there is a note started at this position, it will update the gain of the note.
    * @param gain in the range 0..1, a value of 0.5 results in a gain of 0dB.
    * @since API version 10
    */
   @OscMethod
   void setGain(double gain);

   /**
    * @return the transpose of the step, in semitones
    * @since API version 10
    */
   @OscMethod
   double transpose();

   /**
    * If there is a note started at this position, it will update the pitch offset of the note.
    * @param transpose in semitones, from -96 to +96
    * @since API version 10
    */
   @OscMethod
   void setTranspose(double transpose);

   /**
    * @return true if a note exists and is selected
    * @since API version 10
    */
   @OscMethod
   boolean isIsSelected();

   /**
    * Gets the note chance.
    * @return the probability, 0..1
    * @since API version 14
    */
   @OscMethod
   double chance();

   /**
    * Sets the note chance.
    * @param chance 0..1
    * @since API version 14
    */
   @OscMethod
   void setChance(double chance);

   /**
    * @since API version 14
    */
   @OscMethod
   boolean isChanceEnabled();

   /**
    * @since API version 14
    */
   @OscMethod
   void setIsChanceEnabled(boolean isEnabled);

   /**
    * @since API version 14
    */
   @OscMethod
   boolean isOccurrenceEnabled();

   /**
    * @since API version 14
    */
   @OscMethod
   void setIsOccurrenceEnabled(boolean isEnabled);

   /**
    * @since API version 14
    */
   @OscMethod
   NoteOccurrence occurrence();

   /**
    * @since API version 14
    */
   @OscMethod
   void setOccurrence(NoteOccurrence condition);

   /**
    * @since API version 14
    */
   @OscMethod
   boolean isRecurrenceEnabled();

   /**
    * @since API version 14
    */
   @OscMethod
   void setIsRecurrenceEnabled(boolean isEnabled);

   /**
    * @since API version 14
    */
   @OscMethod
   int recurrenceLength();

   /**
    * @since API version 14
    */
   @OscMethod
   int recurrenceMask();

   /**
    * @param length from 1 to 8
    * @param mask bitfield, cycle N -> bit N; max 8 cycles
    * @since API version 14
    */
   @OscMethod
   void setRecurrence(int length, int mask);

   /**
    * @since API version 14
    */
   @OscMethod
   boolean isRepeatEnabled();

   /**
    * @since API version 14
    */
   @OscMethod
   void setIsRepeatEnabled(boolean isEnabled);

   /**
    * @since API version 14
    */
   @OscMethod
   int repeatCount();

   /**
    * @param count -127..127, positive values indicates a number of divisions, negative values a rate.
    * @since API version 14
    */
   @OscMethod
   void setRepeatCount(int count);

   /**
    * @since API version 14
    */
   @OscMethod
   double repeatCurve();

   /**
    * @param curve -1..1
    * @since API version 14
    */
   @OscMethod
   void setRepeatCurve(double curve);

   /**
    * @since API version 14
    */
   @OscMethod
   double repeatVelocityEnd();

   /**
    * @param velocityEnd -1..1, relative velocity amount applied to the note on velocity.
    * @since API version 14
    */
   @OscMethod
   void setRepeatVelocityEnd(double velocityEnd);

   /**
    * @since API version 14
    */
   @OscMethod
   double repeatVelocityCurve();

   /**
    * @param curve -1..1
    * @since API version 14
    */
   @OscMethod
   void setRepeatVelocityCurve(double curve);

   /**
    * @return true if the note is muted
    * @since API version 14
    */
   @OscMethod
   boolean isMuted();

   /**
    * Mutes the note if values is true.
    * @since API version 14
    */
   @OscMethod
   void setIsMuted(boolean value);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.graphics.Bitmap;

/**
 * Defines a physical pixel display on the controller.
 *
 * @since API version 10
 */
public interface HardwarePixelDisplay extends HardwareOutputElement
{
   /** The {@link Bitmap} that contains the contents of this display. */
   Bitmap bitmap();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.api.opensoundcontrol.OscNode;
import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * The foundation of all interfaces that contain devices, such as tracks, device layers, drum pads or FX
 * slots.
 *
 * @since API version 1
 */
public interface DeviceChain extends ObjectProxy
{
   /**
    * Selects the device chain in Bitwig Studio, in case it is a selectable object.
    *
    * @since API version 1
    */
   @OscMethod
   void selectInEditor();

   /**
    * Value that reports the name of the device chain, such as the track name or the drum pad
    * name.
    *
    * @since API version 2
    */
   @OscNode
   SettableStringValue name();

   /**
    * Registers an observer that reports the name of the device chain, such as the track name or the drum pad
    * name.
    *
    * @param numChars
    *           the maximum number of characters used for the reported name
    * @param textWhenUnassigned
    *           the default text that gets reported when the device chain is not associated with an object in
    *           Bitwig Studio yet.
    * @param callback
    *           a callback function that receives a single name parameter (string).
    * @since API version 1
    * @deprecated Use {@link #name()} instead.
    */
   @Deprecated
   void addNameObserver(int numChars, String textWhenUnassigned, StringValueChangedCallback callback);

   /**
    * Registers an observer that reports if the device chain is selected in Bitwig Studio editors.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter.
    * @since API version 1
    */
   void addIsSelectedInEditorObserver(BooleanValueChangedCallback callback);

   /**
    * @deprecated Use {@link #addIsSelectedInEditorObserver} instead.
    * @since API version 1
    */
   @Deprecated
   void addIsSelectedObserver(BooleanValueChangedCallback callback);

   /**
    * Returns an object that provides bank-wise navigation of devices.
    *
    * @param numDevices
    *           the number of devices should be accessible simultaneously
    * @return the requested device bank object
    * @since API version 1
    */
   DeviceBank createDeviceBank(int numDevices);

   /**
    * Returns an object used for browsing devices, presets and other content. Committing the browsing session
    * will load or create a device from the selected resource and insert it into the device chain.
    *
    * @param numFilterColumnEntries
    *           the size of the window used to navigate the filter column entries.
    * @param numResultsColumnEntries
    *           the size of the window used to navigate the results column entries.
    * @return the requested device browser object.
    * @since API version 1
    */
   Browser createDeviceBrowser(final int numFilterColumnEntries, final int numResultsColumnEntries);

   /**
    * @deprecated Use {@link #selectInEditor()} or {@link Channel#selectInMixer()} instead.
    * @since API version 1
    */
   @Deprecated
   void select();

   /**
    * Starts browsing for content that can be inserted at the start of this device chain.
    *
    * @since API version 2
    * @deprecated Use {@link #startOfDeviceChainInsertionPoint()} instead.
    */
   @Deprecated
   @OscMethod
   void browseToInsertAtStartOfChain();

   /**
    * Starts browsing for content that can be inserted at the end of this device chain.
    *
    * @since API version 2
    * @deprecated Use {@link #endOfDeviceChainInsertionPoint()} instead.
    */
   @Deprecated
   @OscMethod
   void browseToInsertAtEndOfChain();

   /**
    * {@link InsertionPoint} that can be used to insert at the start of the device chain.
    *
    * @since API version 7
    */
   InsertionPoint startOfDeviceChainInsertionPoint();

   /**
    * {@link InsertionPoint} that can be used to insert at the end of the device chain.
    *
    * @since API version 7
    */
   InsertionPoint endOfDeviceChainInsertionPoint();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscNode;

/**
 * Interface that defines a cursor that can be "pinned".
 *
 * @since API version 2
 */
public interface PinnableCursor extends Cursor
{
   /**
    * Determines if this cursor is currently pinned or not. If the cursor is pinned then it won't follow the
    * selection the user makes in the application.
    *
    * @since API version 2
    */
   @OscNode
   SettableBooleanValue isPinned();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface implement the {@link Value} interface for string values.
 *
 * @since API version 1
 */
public interface SettableStringValue extends StringValue
{
   /**
    * Sets the value object to the given string.
    *
    * @param value
    *           the new value string
    * @since API version 1
    */
   @OscMethod
   void set(String value);
}
-e 


package com.bitwig.extension.controller.api;

public interface AudioHardwareIoInfo extends ObjectProxy
{
   ColorValue color();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Devices layers are features of special Bitwig Studio devices, more specifically the Layer Instrument and
 * Layer FX devices, and are also shown as sub-channels in the mixer panel.
 *
 * Instances of device layer bank are configured with a fixed number of channels and represent an excerpt of
 * underlying complete list of channels. Various methods are provided for scrolling to different sections of
 * the underlying list. It basically acts like a one-dimensional window moving over the device layers.
 *
 * To receive an instance of device layer bank call {@link Device#createLayerBank(int numChannels)}.
 *
 * @see Device#createLayerBank(int)
 * @since API version 1
 */
public interface DeviceLayerBank extends ChannelBank<DeviceLayer>
{
   /**
    * Returns the device layer at the given index.
    *
    * @param indexInBank
    *           the device layer index within this bank, not the index within the list of all device layers as
    *           shown in Bitwig Studio layer devices. Must be in the range [0..sizeOfBank-1].
    * @return the device layer object
    * @since API version 1
    * @deprecated Use {@link #getItemAt(int)} instead.
    */
   @Deprecated
   @Override
   DeviceLayer getChannel(int indexInBank);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * A special kind of track that represents the master track in Bitwig Studio.
 *
 * @since API version 1
 */
public interface MasterTrack extends Track
{
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.BooleanValueChangedCallback;
import com.bitwig.extension.callback.IntegerValueChangedCallback;

/**
 * This interface is used for navigation of device chains in Bitwig Studio. Instances are configured with a
 * fixed number of devices and provide access to a excerpt of the devices inside a device chain. Various
 * methods are provided for scrolling to different sections of the device chain. It basically acts like a
 * window moving over the devices.
 *
 * To receive an instance of DeviceBank call {@link Track#createDeviceBank}.
 *
 * @see Track#createDeviceBank(int)
 * @since API version 1
 */
public interface DeviceBank extends Bank<Device>
{
   /**
    * Returns the object that was used to instantiate this device bank. Possible device chain instances are
    * tracks, device layers, drums pads, or FX slots.
    *
    * @return the requested device chain object
    * @since API version 1
    */
   DeviceChain getDeviceChain();

   /**
    * Returns the device at the given index within the bank.
    *
    * @param indexInBank
    *           the device index within this bank, not the position within the device chain. Must be in the
    *           range [0..sizeOfBank-1].
    * @return the requested device object
    * @since API version 1
    */
   Device getDevice(int indexInBank);

   /**
    * Scrolls the device window one page up.
    *
    * @since API version 1
    */
   void scrollPageUp();

   /**
    * Scrolls the device window one page down.
    *
    * @since API version 1
    */
   void scrollPageDown();

   /**
    * Scrolls the device window one device up.
    *
    * @since API version 1
    */
   void scrollUp();

   /**
    * Scrolls the device window one device down.
    *
    * @since API version 1
    */
   void scrollDown();

   /**
    * Makes the device with the given position visible in the track bank.
    *
    * @param position
    *           the position of the device within the device chain
    * @since API version 1
    * @deprecated Use {@link #scrollIntoView(int)} instead
    */
   @Deprecated
   void scrollTo(int position);

   /**
    * Registers an observer that reports the current device scroll position.
    *
    * @param callback
    *           a callback function that takes a single integer parameter
    * @param valueWhenUnassigned
    *           the default value that gets reports when the device chain is not yet connected to a Bitwig
    *           Studio document
    * @since API version 1
    * @deprecated Use {@link #scrollPosition()} instead.
    */
   @Deprecated
   void addScrollPositionObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);

   /**
    * Registers an observer that reports if the device window can be scrolled further up.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollBackwards()} instead.
    */
   @Deprecated
   void addCanScrollUpObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports if the device window can be scrolled further down.
    *
    * @param callback
    *           a callback function that takes a single boolean parameter
    * @since API version 1
    * @deprecated Use {@link #canScrollForwards()} instead.
    */
   @Deprecated
   void addCanScrollDownObserver(BooleanValueChangedCallback callback);

   /**
    * Registers an observer that reports the total device count of the device chain (not the number of devices
    * accessible through the bank window).
    *
    * @param callback
    *           a callback function that receives a single integer parameter
    * @since API version 1
    * @deprecated Use {@link #itemCount()}.addValueObserver(callback)
    */
   @Deprecated
   void addDeviceCountObserver(IntegerValueChangedCallback callback);

   /**
    * Browses for content to insert a device at the given index inside this bank.
    *
    * @param index
    *           the index to insert the device at. Must be {@literal >= 0 and <=} {@link #getSizeOfBank()}.
    *
    * @since API version 2
    */
   void browseToInsertDevice(int index);

   /**
    * Sets a {@link DeviceMatcher} that can be used to filter devices in this bank to show only those
    * matching the supplied matcher.
    *
    * @param matcher The matcher that should filter the devices or null if all devices should be matched
    *
    * @since API version 12
    */
   void setDeviceMatcher(DeviceMatcher matcher);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Instances of this interface are special kind of channel objects that represent the pads of a drum machine
 * instrument. Drum pads are typically associated to channel objects via note keys.
 *
 * @since API version 1
 */
public interface DrumPad extends Channel
{
   /**
    * {@link InsertionPoint} that can be used to insert content in this drum pad.
    *
    * @since API version 7
    * */
   InsertionPoint insertionPoint();
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface providing detailed access to a specific scrollbar.
 * @since API version 21
 */
public interface ScrollbarModel
{
   /**
    * Does this ScrollbarModel support zoom?.
    * @since API version 21
    */
   boolean isZoomable();

   /**
    * Get the zoom level expressed as content units per pixel.
    * @since API version 21
    */
   DoubleValue getContentPerPixel();

   /**
    * Zoom in/out around a specific position (in content units). The distance is given in 2, so +1 implies 200% of the
    * current level and -1 implies 50%
    * @since API version 21
    */
   void zoomAtPosition(double position, double distance);

   /**
    * Adjusts the zoom level so it fits all content
    *
    * @since API version 21
    */
   void zoomToFit();

   /**
    * Adjusts the zoom level so it fits the selected content
    *
    * @since API version 21
    */
   void zoomToSelection();

   /**
    * Alternate the zoom level between fitting all content or the selection
    *
    * @since API version 21
    */
   void zoomToFitSelectionOrAll();

   /**
    * Alternate the zoom level between fitting the selected content or the previous zoom level
    *
    * @since API version 21
    */
   void zoomToFitSelectionOrCurrent();

   /**
    * Set the zoom level to fit a specific content range.
    *
    * @since API version 21
    */
   void zoomToContentRegion(double from, double to);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Interface that can be used to access the parameters of a specific plug-in device.
 *
 * Specific interfaces can be created by calling {@link Device#createSpecificVst2Device(int)} or
 * {@link Device#createSpecificVst3Device(String)}.
 *
 * @since API version 12
 */
public interface SpecificPluginDevice
{
   /**
    * Creates a {@link Parameter} that will refer to the parameter of the plug-in with the specified parameter
    * id.
    */
   Parameter createParameter(int parameterId);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.StringValueChangedCallback;

/**
 * Instances of this interface are used to navigate a filter column in the Bitwig Studio browser.
 *
 * @since API version 1
 */
public interface BrowserFilterColumn extends BrowserColumn
{
   /**
    * Returns the filter item that represents the top-level all/any/everything wildcard item.
    *
    * @return the requested filter item object
    * @since API version 1
    */
   BrowserFilterItem getWildcardItem();

   /**
    * Returns the cursor filter item, which can be used to navigate over the list of entries.
    *
    * @return the requested filter item object
    * @since API version 1
    */
   @Override
   BrowserFilterItem createCursorItem();

   /**
    * Returns an object that provides access to a bank of successive entries using a window configured with
    * the given size, that can be scrolled over the list of entries.
    *
    * @param size
    *           the number of simultaneously accessible items
    * @return the requested item bank object
    */
   @Override
   BrowserFilterItemBank createItemBank(int size);

   /**
    * Value that reports the name of the filter column.
    *
    * @since API version2
    */
   StringValue name();

   /**
    * Registers an observer that reports the name of the filter column.
    *
    * @param callback
    *           a callback function that receives a single string argument.
    * @since API version 1
    * @deprecated Use {@link #name()} instead.
    */
   @Deprecated
   void addNameObserver(int maxCharacters, String textWhenUnassigned, StringValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines a means of recognizing when a continuous value is input by the user (for example, when moving a
 * slider or turning a knob based on some MIDI message).
 *
 * @see MidiIn#createAbsoluteValueMatcher(String, String, int)
 * @see MidiIn#createAbsoluteCCValueMatcher(int, int)
 * @see MidiIn#createAbsolutePitchBendValueMatcher(int)
 *
 * @since API version 10
 *
 */
public interface ContinuousHardwareValueMatcher extends HardwareInputMatcher
{

}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;
import com.bitwig.extension.callback.BooleanValueChangedCallback;

/**
 * A generic interface that provides the foundation for working with selections.
 *
 * Implementations of this interface can either represent custom selection cursors that are created by
 * controller scripts, or represent the cursor of user selections as shown in Bitwig Studio editors, such as
 * the Arranger track selection cursor, the note editor event selection cursor and so on.
 *
 * @since API version 1
 */
public interface Cursor extends RelativeHardwarControlBindable
{
   /**
    * Select the previous item.
    *
    * @since API version 1
    */
   @OscMethod
   void selectPrevious();

   HardwareActionBindable selectPreviousAction();

   /**
    * Select the next item.
    *
    * @since API version 1
    */
   @OscMethod
   void selectNext();

   HardwareActionBindable selectNextAction();

   /**
    * Select the first item.
    *
    * @since API version 1
    */
   @OscMethod
   void selectFirst();

   /**
    * Select the last item.
    *
    * @since API version 1
    */
   @OscMethod
   void selectLast();

   /**
    * Boolean value that reports whether there is an item after the current cursor position.
    *
    * @since API version 2
    */
   BooleanValue hasNext();

   /**
    * Boolean value that reports whether there is an item before the current cursor position.
    *
    * @since API version 2
    */
   BooleanValue hasPrevious();

   /**
    * Registers a function with bool argument that gets called when the previous item gains or remains
    * selectable.
    *
    * @since API version 1
    * @deprecated Use {@link #hasPrevious()} instead.
    */
   @Deprecated
   void addCanSelectPreviousObserver(BooleanValueChangedCallback callback);

   /**
    * Registers a function with bool argument that gets called when the next item gains or remains
    * selectable.
    *
    * @since API version 1
    * @deprecated Use {@link #hasNext()} instead.
    */
   @Deprecated
   void addCanSelectNextObserver(BooleanValueChangedCallback callback);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Callback that is notified when an asynchronous transfer has completed.
 */
public interface AsyncTransferCompledCallback
{
   /** Called upon completion of an asynchronous read. */
   void asyncTransferCompleted(int amountTransferred);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent integer values.
 *
 * @since API version 1
 */
public interface SettableIntegerValue extends IntegerValue, RelativeHardwarControlBindable
{
   /**
    * Sets the internal value.
    *
    * @param value
    *           the new integer value.
    * @since API version 1
    */
   @OscMethod
   void set(int value);

   /**
    * Increases/decrease the internal value by the given amount.
    *
    * @param amount
    *           the integer amount to increase
    * @since API version 1
    */
   @OscMethod
   void inc(int amount);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent enumeration values. Enum values work similar to string values, but
 * are limited to a fixed set of value options.
 *
 * @since API version 1
 */
public interface SettableEnumValue extends EnumValue
{
   /**
    * Sets the value to the enumeration item with the given name.
    *
    * @param value
    *           the name of the new enum item
    * @since API version 1
    */
   @OscMethod
   void set(String value);
}
-e 


package com.bitwig.extension.controller.api;

/**
 * Defines the current state of a {@link MultiStateHardwareLight}. What this state means is entirely up to the
 * controller implementation.
 *
 * The {@link Object#equals(Object)} method <b>MUST</b> be overridden to compare light states correctly.
 *
 * @since API version 10
 */
public abstract class InternalHardwareLightState
{
   /** The visual state of this light (used by Bitwig Studio to visualize the light when needed). */
   public abstract HardwareLightVisualState getVisualState();

   @Override
   public abstract boolean equals(Object obj);
}
-e 


package com.bitwig.extension.controller.api;

import java.util.function.IntSupplier;

import com.bitwig.extension.callback.IntegerValueChangedCallback;

public interface IntegerValue extends Value<IntegerValueChangedCallback>, IntSupplier
{
   /**
    * Gets the current value.
    *
    * @since API version 2
    */
   int get();

   @Override
   default int getAsInt()
   {
      return get();
   }

   /**
    * Adds an observer that is notified when this value changes. This is intended to aid in backwards
    * compatibility for drivers written to the version 1 API.
    *
    * @param callback
    *           The callback to notify with the new value
    * @param valueWhenUnassigned
    *           The value that the callback will be notified with if this value is not currently assigned to
    *           anything.
    */
   void addValueObserver(IntegerValueChangedCallback callback, int valueWhenUnassigned);
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.callback.NoArgsCallback;

/**
 * A generic interface used to implement actions or events that are not associated with a value.
 *
 * @since API version 1
 */
public interface Signal
{
   /**
    * Registers an observer that gets notified when the signal gets fired.
    *
    * @param callback
    *           a callback function that does not receive any argument.
    * @since API version 1
    */
   public void addSignalObserver(NoArgsCallback callback);

   /**
    * Fires the action or event represented by the signal object.
    *
    * @since API version 1
    */
   void fire();
}
-e 


package com.bitwig.extension.controller.api;

import com.bitwig.extension.api.opensoundcontrol.OscMethod;

/**
 * Instances of this interface represent numeric values that have an upper and lower limit.
 *
 * @since API version 1
 */
public interface SettableRangedValue extends RangedValue, AbsoluteHardwarControlBindable, RelativeHardwarControlBindable
{
   /**
    * Sets the value in an absolute fashion as a value between 0 .. 1 where 0 represents the minimum value and
    * 1 the maximum. The value may not be set immediately if the user has configured a take over strategy for
    * the controller.
    *
    * @param value
    *           absolute value [0 .. 1]
    * @since API version 2
    */
   @OscMethod
   void set(double value);

   /**
    * Sets the value in an absolute fashion as a value between 0 .. 1 where 0 represents the minimum value and
    * 1 the maximum. The value change is applied immediately and does not care about what take over mode the
    * user has selected. This is useful if the value does not need take over (e.g. a motorized slider).
    *
    * @param value
    *           absolute value [0 .. 1]
    *
    * @since API version 4
    */
   @OscMethod
   void setImmediately(double value);

   /**
    * Sets the value in an absolute fashion. The value will be scaled according to the given resolution.
    *
    * Typically the resolution would be specified as the amount of steps the hardware control provides (for
    * example 128) and just pass the integer value as it comes from the MIDI device. The host application will
    * take care of scaling it.
    *
    * @param value
    *           integer number in the range [0 .. resolution-1]
    * @param resolution
    *           the resolution used for scaling @ if passed-in parameters are null
    * @since API version 1
    */
   void set(Number value, Number resolution);

   /**
    * Increments or decrements the value by a normalized amount assuming the whole range of the value is 0 ..
    * 1. For example to increment by 10% you would use 0.1 as the increment.
    *
    * @since API version 2
    */
   @OscMethod
   void inc(double increment);

   /**
    * Increments or decrements the value according to the given increment and resolution parameters.
    *
    * Typically the resolution would be specified as the amount of steps the hardware control provides (for
    * example 128) and just pass the integer value as it comes from the MIDI device. The host application will
    * take care of scaling it.
    *
    * @param increment
    *           the amount that the current value is increased by
    * @param resolution
    *           the resolution used for scaling
    * @since API version 1
    */
   void inc(Number increment, Number resolution);

   /**
    * Set the internal (raw) value.
    *
    * @param value
    *           the new value with double precision. Range is undefined.
    * @since API version 1
    */
   @OscMethod
   void setRaw(double value);

   /**
    * Increments / decrements the internal (raw) value.
    *
    * @param delta
    *           the amount that the current internal value get increased by.
    * @since API version 1
    */
   @OscMethod
   void incRaw(double delta);

   @Override
   default AbsoluteHardwareControlBinding addBinding(final AbsoluteHardwareControl hardwareControl)
   {
      return addBindingWithRange(hardwareControl, 0, 1);
   }

   @Override
   AbsoluteHardwareControlBinding addBindingWithRange(
      AbsoluteHardwareControl hardwareControl,
      double minNormalizedValue,
      double maxNormalizedValue);

   @Override
   default RelativeHardwareControlToRangedValueBinding addBinding(final RelativeHardwareControl hardwareControl)
   {
      return addBindingWithRangeAndSensitivity(hardwareControl, 0, 1, 1);
   }

   default RelativeHardwareControlBinding addBindingWithRange(
      final RelativeHardwareControl hardwareControl,
      final double minNormalizedValue,
      final double maxNormalizedValue)
   {
      return addBindingWithRangeAndSensitivity(hardwareControl, minNormalizedValue, maxNormalizedValue, 1);
   }

   RelativeHardwareControlToRangedValueBinding addBindingWithRangeAndSensitivity(
      RelativeHardwareControl hardwareControl,
      double minNormalizedValue,
      double maxNormalizedValue,
      double sensitivity);

   @Override
   default RelativeHardwareControlToRangedValueBinding addBindingWithSensitivity(
      final RelativeHardwareControl hardwareControl,
      final double sensitivity)
   {
      return addBindingWithRangeAndSensitivity(hardwareControl, 0, 1, sensitivity);
   }
}
-e 


package com.bitwig.extension.controller;

/**
 * Defines information needed to identify suitable USB devices for use by an extension.
 *
 * @since API version 7
 */
public class UsbDeviceMatcher extends HardwareDeviceMatcher
{
   /**
    * Creates a {@link UsbDeviceMatcher} that matches a USB device that matches the supplied expression and
    * has a configuration matching the supplied {@link UsbConfigurationMatcher}.
    *
    * @param name
    *           A human friendly name that describes the kind of devices this matcher tries to match.
    *
    * @param expression
    *           An expression that can be used on the USB device descriptor to decide if the device matches.
    *           Variables in the expression can refer to the following fields of the device descriptor:
    *
    *           - bDeviceClass - bDeviceSubClass - bDeviceProtocol - idVendor - idProduct
    *
    *           For example to match a device that has vendor id 0x10 product id 0x20 the expression would be:
    *
    *           "idVendor == 0x10 && idProduct == 0x20"
    *
    * @param configurationMatcher
    *           Object that tries to match a configuration on the device that it can use.
    *
    * @see https://beyondlogic.org/usbnutshell/usb5.shtml for more information about USB device descriptors.
    */
   public UsbDeviceMatcher(
      final String name,
      final String expression,
      final UsbConfigurationMatcher configurationMatcher)
   {
      super(name);
      mExpression = expression;
      mConfigurationMatcher = configurationMatcher;
   }

   /**
    * Creates a {@link UsbDeviceMatcher} that matches a USB device that matches the supplied expression and
    * has a configuration matching the supplied {@link UsbInterfaceMatcher}s.
    *
    * @param name
    *           A human friendly name that describes the kind of devices this matcher tries to match.
    *
    * @param expression
    *           An expression that can be used on the USB device descriptor to decide if the device matches.
    *           Variables in the expression can refer to the following fields of the device descriptor:
    *
    *           - bDeviceClass - bDeviceSubClass - bDeviceProtocol - idVendor - idProduct
    *
    *           For example to match a device that has vendor id 0x10 product id 0x20 the expression would be:
    *
    *           "idVendor == 0x10 && idProduct == 0x20"
    *
    * @param interfaceMatchers
    *           {@link UsbInterfaceMatcher}s that define the USB interface descriptors that a configuration of
    *           the device needs to have.
    *
    * @see https://beyondlogic.org/usbnutshell/usb5.shtml for more information about USB device descriptors.
    */
   public UsbDeviceMatcher(
      final String name,
      final String expression,
      final UsbInterfaceMatcher... interfaceMatchers)
   {
      this(name, expression, new UsbConfigurationMatcher(interfaceMatchers));
   }



   /** An expression that can be used on the USB device descriptor to decide if the device matches.
   *           Variables in the expression can refer to the following fields of the device descriptor:
   *
   *           - bDeviceClass - bDeviceSubClass - bDeviceProtocol - idVendor - idProduct
   *
   *           For example to match a device that has vendor id 0x10 product id 0x20 the expression would be:
   *
   *           "idVendor == 0x10 && idProduct == 0x20"
   *           */
   public String getExpression()
   {
      return mExpression;
   }

   /** Object that tries to match a configuration on the device that it can use. */
   public UsbConfigurationMatcher getConfigurationMatcher()
   {
      return mConfigurationMatcher;
   }

   private final String mExpression;

   private final UsbConfigurationMatcher mConfigurationMatcher;
}
-e 


package com.bitwig.extension.api;

import java.nio.ByteBuffer;

/**
 * Defines a block of memory. The memory can be read/written using a {@link ByteBuffer} provided by
 * {@link #createByteBuffer()}.
 *
 * @since API version 7
 */
public interface MemoryBlock
{
   /** The size in bytes of this memory block. */
   int size();

   /** Creates a {@link ByteBuffer} that can be used to read/write the data at this memory block. */
   ByteBuffer createByteBuffer();
}
-e 


package com.bitwig.extension.api.util.midi;

public class ShortMidiMessage
{
   public static final int NOTE_OFF = 0x80;

   public static final int NOTE_ON = 0x90;

   public static final int POLY_PRESSURE = 0xA0;

   public static final int CONTROL_CHANGE = 0xB0;

   public static final int PROGRAM_CHANGE = 0xC0;

   public static final int CHANNEL_PRESSURE = 0xD0;

   public static final int PITCH_BEND = 0xE0;

   public static final int MIDI_TIME_CODE = 0xF1;

   public static final int SONG_POSITION_POINTER = 0xF2;

   public static final int SONG_SELECT = 0xF3;

   public static final int TUNE_REQUEST = 0xF6;

   public static final int TIMING_CLOCK = 0xF8;

   public static final int START = 0xFA;

   public static final int CONTINUE = 0xFB;

   public static final int STOP = 0xFC;

   public static final int ACTIVE_SENSING = 0xFE;

   public static final int SYSTEM_RESET = 0xFF;

   public ShortMidiMessage(final int status, final int data1, final int data2)
   {
      mData = status | data1 << 8 | data2 << 16;
   }

   public int getStatusByte()
   {
      return mData & 0xff;
   }

   public int getData1()
   {
      return (mData >> 8) & 0xff;
   }

   public int getData2()
   {
      return (mData >> 16) & 0xff;
   }

   public int getChannel()
   {
      return mData & 0xf;
   }

   private int getStatusMessage()
   {
      return mData & 0xf0;
   }

   public boolean isNoteOff()
   {
      return getStatusMessage() == NOTE_OFF;
   }

   public boolean isNoteOn()
   {
      return getStatusMessage() == NOTE_ON;
   }

   public boolean isPitchBend()
   {
      return getStatusMessage() == PITCH_BEND;
   }

   public boolean isPolyPressure()
   {
      return getStatusMessage() == POLY_PRESSURE;
   }

   public boolean isControlChange()
   {
      return getStatusMessage() == CONTROL_CHANGE;
   }

   public boolean isProgramChange()
   {
      return getStatusMessage() == PROGRAM_CHANGE;
   }

   public boolean isChannelPressure()
   {
      return getStatusMessage() == CHANNEL_PRESSURE;
   }

   @Override
   public String toString()
   {
      return "status: " + getStatusMessage() + ", channel: " + getChannel() + ", data1: " + getData1() + ", data2: " + getData2();
   }

   private int mData;
}
-e 


package com.bitwig.extension.api.util.midi;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;

public class SysexBuilder
{
   private final static int MAX_LENGTH = 512;

   public static SysexBuilder fromHex(final String hexString)
   {
      return new SysexBuilder().addHex(hexString);
   }

   public SysexBuilder addByte(int value)
   {
      mData[mLength++] = (byte) (value & 0x7f);
      return this;
   }

   public SysexBuilder addString(final String string, final int length)
   {
      byte[] ascii = string.getBytes(StandardCharsets.US_ASCII);

      for(int i=0; i<length; i++)
      {
         if (i < ascii.length)
         {
            mData[mLength++] = ascii[i];
         }
         else
         {
            mData[mLength++] = 32;
         }
      }

      return this;
   }

   public SysexBuilder add(final byte[] bytes)
   {
      for (int i = 0; i < bytes.length; i++)
      {
         mData[mLength++] = bytes[i];
      }

      return this;
   }

   public SysexBuilder addHex(final String hex)
   {
      String sysexMessage = hex.replace(" ", "");
      sysexMessage = sysexMessage.toUpperCase();

      if ((sysexMessage.length() & 1) != 0)
      {
         throw new IllegalArgumentException("Invalid sysex string");
      }

      final int bytes = sysexMessage.length() / 2;

      for(int i=0; i<bytes; i++)
      {
         mData[mLength++] = Integer.valueOf(sysexMessage.substring(i*2, i*2+2), 16).byteValue();
      }

      return this;
   }

   public byte[] terminate()
   {
      mData[mLength++] = (byte)0xf7;
      return array();
   }

   public byte[] array()
   {
      return Arrays.copyOfRange(mData, 0, mLength);
   }

   private byte[] mData = new byte[MAX_LENGTH];
   private int mLength;
}
-e 


package com.bitwig.extension.api;

public enum PlatformType
{
   WINDOWS, LINUX, MAC
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.util.List;

/**
 * An OSC message.
 *
 * @since API version 5
 */
public interface OscMessage extends OscPacket
{
   String getAddressPattern();
   String getTypeTag();

   List<Object> getArguments();

   default String getString(int index)
   {
      return (String) getArguments().get(index);
   }

   default byte[] getBlob(int index)
   {
      return (byte[]) getArguments().get(index);
   }

   default Integer getInt(int index)
   {
      return (Integer) getArguments().get(index);
   }

   default Long getLong(int index)
   {
      return (Long) getArguments().get(index);
   }

   default Float getFloat(int index)
   {
      return (Float) getArguments().get(index);
   }

   default Double getDouble(int index)
   {
      return (Double) getArguments().get(index);
   }

   default Boolean getBoolean(int index)
   {
      return (Boolean) getArguments().get(index);
   }
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

/**
 * Base class for OscPackets.
 *
 * @since API version 5
 */
public interface OscPacket
{
   /**
    * If the message was part of a bundle, get a pointer back to it.
    * If not, this methods returns null.
    */
   OscBundle getParentBundle();
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface OscNode
{
   String prefix() default "";
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.util.List;

/**
 * An OSC Bundle.
 *
 * @since API version 5
 */
public interface OscBundle extends OscPacket
{
   long getNanoseconds();

   List<OscPacket> getPackets();
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.io.IOException;

/**
 * An OSC address space.
 *
 * It contains the root OscContainer.
 *
 * @since API version 5
 */
public interface OscAddressSpace
{
   /**
    * Register all the methods annotated with {@link OscMethod} object.
    * Also, if a method is annotated with {@link OscNode}, this method will be called and the returned object's method
    * will be registered.
    */
   void registerObjectMethods(final String addressPrefix, Object object) throws OscInvalidArgumentTypeException;

   /**
    * Low level way to register an Osc Method.
    * @param address The address to register the method at
    * @param typeTagPattern The globing pattern used to match the type tag. Pass "*" to match anything.
    * @param desc The method description.
    * @param callback The OSC Method call handler.
    */
   void registerMethod(String address, String typeTagPattern, String desc, OscMethodCallback callback);

   /**
    * This method will be called if no registered OscMethod could handle incoming OscPacket.
    */
   void registerDefaultMethod(OscMethodCallback callback);

   /**
    * Should the address spaces log the messages it dispatches?
    * Default is false.
    */
   void setShouldLogMessages(boolean shouldLogMessages);

   /**
    * This gives a display name for this address space.
    * It is useful if you have multiple address space to identify them when we generate the documentation.
    */
   void setName(String name);
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.io.IOException;

/**
 * This interface lets you send OscMessage through an connection which can be via Tcp, Udp, or whatever.
 *
 * OscPackets are sent when all the startBundle() have a matching endBundle().
 * If you call sendMessage() with startBundle() before, then the message will be sent directly.
 *
 * Our maximum packet size is 64K.
 *
 * @since API version 5
 */
public interface OscConnection
{
   /**
    * Starts an OscBundle.
    */
   void startBundle() throws IOException;

   /**
    * Supported object types:
    * - Integer for int32
    * - Long for int64
    * - Float for float
    * - Double for double
    * - null for nil
    * - Boolean for true and false
    * - String for string
    * - byte[] for blob
    */
   void sendMessage(String address, Object ...args) throws IOException, OscInvalidArgumentTypeException;

   /**
    * Finishes the previous bundle, and if it was not inside an other bundle, it will send the message
    * directly.
    */
   void endBundle() throws IOException;
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.io.IOException;

/**
 * @since API version 10
 */
public interface OscServer
{
   /**
    * Starts or restarts the server and restarts it on the given port.
    * @since API version 10
    */
   void start(int port) throws IOException;
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

public interface OscMethodCallback
{
   void handle(OscConnection source, OscMessage message);
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

public class OscPacketSizeExceededException extends OscIOException
{
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface OscMethod
{
   String address() default "";
   String typeTagPattern() default "";
   String desc() default "";

   String[] obsoleteAddresses() default {};
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.lang.reflect.Method;

public class OscInvalidArgumentTypeException extends RuntimeException
{
   public OscInvalidArgumentTypeException(final Object arg)
   {
      super(arg.getClass().getName() + " (" + arg.toString() + ") is not a supported type for OSC messages arguments");
   }

   public OscInvalidArgumentTypeException(final Class<?> type)
   {
      super(type.getName() + " is not a supported type for OSC messages arguments");
   }

   public OscInvalidArgumentTypeException(final Class<?> type, final Method method)
   {
      super("Unsupported argument type found in method " + method + ": " + type.getName());
   }
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

import java.io.IOException;

public class OscIOException extends IOException
{
}
-e 


package com.bitwig.extension.api.opensoundcontrol;

/**
 * Interface to create Osc related object.
 *
 * @since API version 5
 */
public interface OscModule
{
   /**
    * Creates a new OscAddressSpace.
    *
    * In short the OscAddressSpace dispatches the incoming messages to services.
    * An OscAddressSpace is an OscService.
    *
    * @since API version 5
    */
   OscAddressSpace createAddressSpace();

   /**
    * Creates a new OSC Server.
    *
    * @param addressSpace Use {@link #createAddressSpace()}
    * @since API version 5
    */
   void createUdpServer(int port, OscAddressSpace addressSpace);

   /**
    * Creates a new OSC Server.
    * This server is not started yet, you'll have to start it by calling server.start(port);
    * Use this method if the port is not known during the initialization (coming from a setting)
    * or if the port number can change at runtime.
    *
    * @param addressSpace Use {@link #createAddressSpace()}
    * @return a new OscServer
    * @since API version 10
    */
   OscServer createUdpServer(OscAddressSpace addressSpace);

   /**
    * Tries to connect to an OscServer.
    *
    * @param addressSpace can be null
    *
    * @return a new OscConnection
    * @since API version 5
    */
   OscConnection connectToUdpServer(String host, int port, OscAddressSpace addressSpace);
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Represents an abstract image type.
 */
public interface Image
{
   /** Returns the width */
   int getWidth();

   /** Returns the height */
   int getHeight();
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Abstract class for patterns (gradient, mesh gradient, ...)
 */
public interface Pattern
{
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Represent the size required to display some text.
 */
public interface TextExtents
{
   /**
    * Returns the horizontal distance from the origin to the leftmost part of the glyphs as drawn.
    * Positive if the glyphs lie entirely to the right of the origin.
    */
   double getBearingX();

   /**
    * Returns the vertical distance from the origin to the topmost part of the glyphs as drawn.
    * Positive only if the glyphs lie completely below the origin; will usually be negative.
    */
   double getBearingY();

   /** Returns the width of the glyphs as drawn. */
   double getWidth();

   /** Returns the height of the glyphs as drawn. */
   double getHeight();

   /** Returns the distance to advance in the X direction after drawing these glyphs. */
   double getAdvanceX();

   /**
    * Returns the distance to advance in the Y direction after drawing these glyphs. Will typically
    * be zero except for vertical text layout as found in East-Asian languages.
    */
   double getAdvanceY();
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Information about the dimensions of a font.
 */
public interface FontExtents
{
   /**
    * Returns the distance that the font extends above the baseline. Note that this is not always
    * exactly equal to the maximum of the extents of all the glyphs in the font, but rather is
    * picked to express the font designer's intent as to how the font should align with elements
    * above it.
    */
   double getAscent();

   /**
    * Returns the distance that the font extends below the baseline. This value is positive for
    * typical fonts that include portions below the baseline. Note that this is not always exactly
    * equal to the maximum of the extents of all the glyphs in the font, but rather is picked to
    * express the font designer's intent as to how the the font should align with elements below it.
    */
   double getDescent();

   /**
    * Returns the recommended vertical distance between baselines when setting consecutive lines of
    * text with the font. This is greater than ascent+descent by a quantity known as the line
    * spacing or external leading. When space is at a premium, most fonts can be set with only a
    * distance of ascent+descent between lines.
    */
   double getHeight();

   /**
    * the maximum distance in the X direction that the the origin is advanced for any glyph in the
    * font.
    */
   double getMaxAdvanceX();

   /**
    * Returns the maximum distance in the Y direction that the the origin is advanced for any glyph
    * in the font. this will be zero for normal fonts used for horizontal writing. (The scripts of
    * East Asia are sometimes written vertically.)
    */
   double getMaxAdvanceY();
}
-e 


package com.bitwig.extension.api.graphics;

import com.bitwig.extension.api.Color;

/**
 * This class represents a linear gradient.
 * Add color stops between 0 and 1.
 */
public interface GradientPattern extends Pattern
{
   void addColorStop(double offset, Color color);

   default void addColorStop(double offset, double red, double green, double blue)
   {
      addColorStop(offset, Color.fromRGB(red, green, blue));
   }

   default void addColorStop(double offset, double red, double green, double blue, double alpha)
   {
      addColorStop(offset, Color.fromRGBA(red, green, blue, alpha));
   }
}
-e 


package com.bitwig.extension.api.graphics;

public enum BitmapFormat
{
   /**
    * Each pixel is a 32-bit quantity, with alpha in the upper 8 bits, then red, then green, then
    * blue. The 32-bit quantities are stored native-endian. Pre-multiplied alpha is used. (That is,
    * 50% transparent red is 0x80800000, not 0x80ff0000.)
    */
   ARGB32(4),

   /**
    * Each pixel is a 32-bit quantity, with the upper 8 bits unused. Red, Green, and Blue are stored
    * in the remaining 24 bits in that order.
    */
   RGB24_32(4);

   private final int mBytesPerPixel;

   private BitmapFormat(final int bytesPerPixel)
   {
      mBytesPerPixel = bytesPerPixel;
   }

   public int bytesPerPixel()
   {
      return mBytesPerPixel;
   }
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Represents a Font.
 */
public interface FontFace
{
   /**
    * Get the font name.
    */
   String getName();
}
-e 


package com.bitwig.extension.api.graphics;

import com.bitwig.extension.api.Color;

/**
 * Provides 2D vector drawing API very similar to cairo graphics.
 * Please read https://www.cairographics.org/manual/ to get a better idea of how this API works.
 */
public interface GraphicsOutput
{
   enum AntialiasMode
   {
      DEFAULT, OFF, GOOD, BEST
   }

   enum SubPixelOrder
   {
      DEFAULT, RGB, BGR, VRGB, VBGR
   }

   enum HintStyle
   {
      DEFAULT, NONE, SLIGHT, MEDIUM, FULL
   }

   enum HintMetrics
   {
      DEFAULT, ON, OFF
   }

   enum FillRule
   {
      WINDING, EVEN_ODD
   }

   enum LineCap
   {
      BUTT, LINE, SQUARE
   }

   enum LineJoin
   {
      MITER, ROUND, BEVEL
   }

   enum Operator
   {
      CLEAR, SOURCE, OVER, IN, OUT, ATOP, DEST, DEST_OVER, DEST_IN, DEST_OUT, DEST_ATOP, XOR, ADD, SATURATE, MULTIPLY,
      SCREEN, OVERLAY, DARKEN, LIGHTEN, COLOR_DODGE, COLOR_BURN, HARD_LIGHT, SOFT_LIGHT, DIFFERENCE, EXCLUSION,
      HSL_HUE, HSL_SATURATION, HSL_COLOR, HSL_LUMINOSITY
   }

   ///////////
   // Stack //
   ///////////

   void save();
   void restore();

   //////////////
   // Clipping //
   //////////////

   void clip();
   void clipPreserve();
   void resetClip();

   /////////////////
   // Referencial //
   /////////////////

   void translate(double x, double y);
   void rotate(double angle);
   void scale(double factor);
   void scale(double xFactor, double yFactor);

   /////////////////////
   // Shapes & Pathes //
   /////////////////////

   void newPath();
   void newSubPath();
   Path copyPath();
   Path copyPathFlat();
   void appendPath(Path path);
   void closePath();
   void moveTo(double x, double y);
   void relMoveTo(double x, double y);
   void lineTo(double x, double y);
   void relLineTo(double x, double y);
   void rectangle(double x, double y, double width, double height);
   void arc(double xc, double yc, double radius, double angle1, double angle2);
   void arcNegative(double xc, double yc, double radius, double angle1, double angle2);
   void circle(double centerX, double centerY, double radius);
   void curveTo(double x1, double y1, double x2, double y2, double x3, double y3);
   void relCurveTo(double x1, double y1, double x2, double y2, double x3, double y3);

   ///////////////////////////
   // Painting and stroking //
   ///////////////////////////

   void paint();
   void paintWithAlpha(double alpha);
   void mask(Image image, double x, double y);
   void fill();
   void fillPreserve();
   void stroke();
   void strokePreserve();
   void setColor(double red, double green, double blue);
   void setColor(double red, double green, double blue, double alpha);
   void setColor(Color color);
   void setPattern(Pattern pattern);
   void setAntialias(AntialiasMode antialiasMode);
   void setLineWidth(double width);
   void setDash(double[] dashes, double offset);
   void setDash(double[] dashes);
   void setFillRule(FillRule rule);
   void setLineCap(LineCap lineCap);
   void setLineJoin(LineJoin lineJoin);
   void setMiterLimit(double limit);
   void setOperator(Operator operator);
   void setTolerance(double tolerance);
   void drawImage(Image image, double x, double y);

   //////////////
   // Patterns //
   //////////////

   GradientPattern createLinearGradient(double x1, double y1, double x2, double y2);
   MeshPattern createMeshGradient();

   //////////
   // Text //
   //////////

   void showText(String text);
   void setFontSize(double fontSize);
   void setFontFace(FontFace fontFace);
   void setFontOptions(FontOptions fontOptions);
   FontExtents getFontExtents();
   TextExtents getTextExtents(String text);
}
-e 


package com.bitwig.extension.api.graphics;

import com.bitwig.extension.api.graphics.GraphicsOutput;

/**
 * This class is a renderer.
 * The render method will be called by the Host with a provided GraphicsOutput context.
 */
public interface Renderer
{
   void render(GraphicsOutput gc);
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * This represents a 2D gradient.
 *
 * @see <a href="https://www.cairographics.org/manual/cairo-cairo-pattern-t.html#cairo-pattern-create-mesh">cairo mesh pattern</a>
 */
public interface MeshPattern extends Pattern
{
   void beginPatch();

   void endPatch();

   void moveTo(double x, double y);

   void lineTo(double x, double y);

   void curveTo(double x1, double y1, double x2, double y2, double x3, double y3);

   void setCornerColor(int corner, double red, double green, double blue);
   void setCornerColor(int corner, double red, double green, double blue, double alpha);
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Configure the font rendering options.
 */
public interface FontOptions
{
   GraphicsOutput.AntialiasMode getAntialiasMode();
   void setAntialiasMode(GraphicsOutput.AntialiasMode mode);

   GraphicsOutput.SubPixelOrder getSubPixelOrder();
   void setSubPixelOrder(GraphicsOutput.SubPixelOrder subPixelOrder);

   GraphicsOutput.HintStyle getHintStyle();
   void setHintStyle(GraphicsOutput.HintStyle hintStyle);

   GraphicsOutput.HintMetrics getHintMetrics();
   void setHintMetrics(GraphicsOutput.HintMetrics hintMetrics);
}
-e 


package com.bitwig.extension.api.graphics;

import com.bitwig.extension.api.MemoryBlock;

/**
 * Represents a bitmap image which can be painted via {@link #render(Renderer)}.
 *
 * @since API version 7
 */
public interface Bitmap extends Image
{
   @Override
   int getWidth();

   @Override
   int getHeight();

   BitmapFormat getFormat();

   MemoryBlock getMemoryBlock();

   /**
    * Call this method to start painting the bitmap.
    * This method will take care of disposing allocated patterns during the rendering.
    *
    * @since API version 7
    */
   void render(Renderer renderer);

   /**
    * Call this method to show a window which displays the bitmap.
    * You should see this as a debug utility rather than a Control Surface API feature.
    *
    * @since API version 7
    */
   void showDisplayWindow();

   /**
    * Updates the display window title.
    *
    * @since API version 7
    */
   void setDisplayWindowTitle(String title);

   /**
    * Saves the image as a PPM file.
    * @param path the location of the target file.
    *
    * @since API version 7
    */
   void saveToDiskAsPPM(String path);
}
-e 


package com.bitwig.extension.api.graphics;

/**
 * Represents a Path
 */
public interface Path
{
}
-e 


package com.bitwig.extension.api;

import com.bitwig.extension.api.graphics.Bitmap;
import com.bitwig.extension.api.graphics.BitmapFormat;
import com.bitwig.extension.api.graphics.FontFace;
import com.bitwig.extension.api.graphics.FontOptions;
import com.bitwig.extension.api.graphics.Image;
import com.bitwig.extension.api.opensoundcontrol.OscModule;

/**
 * Defines the interface through which an extension can talk to the host application.
 */
public interface Host
{
   /**
    * Returns the latest supported API version of the host application.
    *
    * @return the latest supported API version of the host application
    * @since API version 1
    */
   int getHostApiVersion();

   /**
    * Returns the vendor of the host application.
    *
    * @return the vendor of the host application
    * @since API version 1
    */
   String getHostVendor();

   /**
    * Returns the product name of the host application.
    *
    * @return the product name of the host application
    * @since API version 1
    */
   String getHostProduct();

   /**
    * Returns the version number of the host application.
    *
    * @return the version number of the host application
    * @since API version 1
    */
   String getHostVersion();

   /**
    * The platform type that this host is running on.
    */
   PlatformType getPlatformType();

   /**
    * Sets an email address to use for reporting errors found in this script.
    *
    * @since API version 2
    */
   void setErrorReportingEMail(String address);

   /**
    * Gets the OpenSoundControl module.
    * @since API version 5
    */
   OscModule getOscModule();

   /**
    * Allocates some memory that will be automatically freed once the extension exits.
    *
    * @since API version 7
    */
   MemoryBlock allocateMemoryBlock(int size);

   /**
    * Creates an offscreen bitmap that the extension can use to render into. The memory used by this bitmap is
    * guaranteed to be freed once this extension exits.
    *
    * @since API version 7
    */
   Bitmap createBitmap(int width, int height, BitmapFormat format);

   /**
    * Loads a font.
    * The memory used by this font is guaranteed to be freed once this extension exits.
    *
    * @since API version 7
    */
   FontFace loadFontFace(String path);

   /**
    * Creates a new FontOptions.
    * This object is used to configure how the GraphicOutput will display text.
    * The memory used by this object is guaranteed to be freed once this extension exits.
    *
    * @since API version 7
    */
   FontOptions createFontOptions();

   /**
    * Loads a PNG image.
    * The memory used by this image is guaranteed to be freed once this extension exits.
    *
    * @since API version 7
    */
   Image loadPNG(String path);

   /**
    * Loads a SVG image.
    * The memory used by this image is guaranteed to be freed once this extension exits.
    *
    * @since API version 7
    */
   Image loadSVG(String path, double scale);
}
-e 


package com.bitwig.extension.api;

/**
 * This class represents an RGBA color with each component being stored as double.
 *
 * @since API version 5
 */
public class Color
{
   private Color(final double red, final double green, final double blue, final double alpha)
   {
      mRed = red;
      mGreen = green;
      mBlue = blue;
      mAlpha = alpha;
   }

   public static Color fromRGB(double red, double green, double blue)
   {
      return new Color(red, green, blue, 1);
   }

   public static Color fromRGBA(double red, double green, double blue, double alpha)
   {
      return new Color(red, green, blue, alpha);
   }

   public static Color fromRGB255(final int red, final int green, final int blue)
   {
      return new Color(red / 255.0, green / 255.0, blue / 255.0, 1);
   }

   public static Color fromRGBA255(final int red, final int green, final int blue, final int alpha)
   {
      return new Color(red / 255.0, green / 255.0, blue / 255.0, alpha / 255.0);
   }

   public static Color fromHex(String hex)
   {
      if (hex.isEmpty())
         return nullColor();

      // Skip the initialial '#'
      if (hex.charAt(0) == '#')
         hex = hex.substring(1);

      // Check that the color is an hex value
      for (int i = 0; i < hex.length(); ++i)
      {
         char c = hex.charAt(i);
         if (('0' <= c && c <= '9') ||
            ('a' <= c && c <= 'f') ||
            ('A' <= c && c <= 'F'))
            continue;

         return nullColor();
      }

      switch (hex.length())
      {
         case 3: // RGB
         {
            int r = Integer.parseInt(hex.substring(0, 1), 16);
            int g = Integer.parseInt(hex.substring(1, 2), 16);
            int b = Integer.parseInt(hex.substring(2, 3), 16);
            return fromRGB(r / 15.0, g / 15.0, b / 15.0);
         }

         case 4: // RGBA
         {
            int r = Integer.parseInt(hex.substring(0, 1), 16);
            int g = Integer.parseInt(hex.substring(1, 2), 16);
            int b = Integer.parseInt(hex.substring(2, 3), 16);
            int a = Integer.parseInt(hex.substring(2, 3), 16);
            return fromRGBA(r / 15.0, g / 15.0, b / 15.0, a / 15.0);
         }

         case 6: // RRGGBB
         {
            int r = Integer.parseInt(hex.substring(0, 2), 16);
            int g = Integer.parseInt(hex.substring(2, 4), 16);
            int b = Integer.parseInt(hex.substring(4, 6), 16);
            return fromRGB255(r, g, b);
         }

         case 8: // RRGGBBAA
         {
            int r = Integer.parseInt(hex.substring(0, 2), 16);
            int g = Integer.parseInt(hex.substring(2, 4), 16);
            int b = Integer.parseInt(hex.substring(4, 6), 16);
            int a = Integer.parseInt(hex.substring(6, 8), 16);
            return fromRGBA255(r, g, b, a);
         }
      }

      return nullColor();
   }

   /**
    * Mixes two colors.
    * @since API version 4
    */
   public static Color mix(final Color c1, final Color c2, double blend)
   {
      final double b1 = blend;
      final double b2 = 1 - blend;

      return new Color(
         c1.getRed() * b1 + c2.getRed() * b2,
         c1.getGreen() * b1 + c2.getGreen() * b2,
         c1.getBlue() * b1 + c2.getBlue() * b2,
         c1.getAlpha() * b1 + c2.getAlpha() * b2);
   }


   public String toHex()
   {
      int red = getRed255();
      int green = getGreen255();
      int blue = getBlue255();
      int alpha = getAlpha255();


      StringBuilder sb = new StringBuilder(9);
      sb.append("#");
      addHex2Number(sb, red);
      addHex2Number(sb, green);
      addHex2Number(sb, blue);

      if (alpha != 255)
         addHex2Number(sb, alpha);

      return sb.toString();
   }

   private void addHex2Number(StringBuilder sb, int x)
   {
      String hex = Integer.toHexString(x & 0xff);
      if (hex.length() == 1) sb.append(0);
      sb.append(hex);
   }

   public static Color nullColor()
   {
      return fromRGBA(0, 0, 0, 0);
   }
   public static Color blackColor()
   {
      return fromRGBA(0, 0, 0, 1);
   }
   public static Color whiteColor()
   {
      return fromRGBA(1, 1, 1, 1);
   }

   public double getRed() { return mRed; }
   public double getGreen() { return mGreen; }
   public double getBlue() { return mBlue; }
   public double getAlpha() { return mAlpha; }

   public int getRed255() { return (int) (mRed * 255); }
   public int getGreen255() { return (int) (mGreen * 255); }
   public int getBlue255() { return (int) (mBlue * 255); }
   public int getAlpha255() { return (int) (mAlpha * 255); }

   /**
    * @param hsv array of length 3. On return, the array will be set to {h, s, v} with 0 <= h <= 360, 0 <= s <= 1 and 0 <= v <= 1.
    */
   public void toHSV(final double[] hsv)
   {
      assert mRed >= 0 && mRed <= 1;
      assert mGreen >= 0 && mGreen <= 1;
      assert mBlue >= 0 && mBlue <= 1;
      assert hsv != null;
      assert hsv.length == 3;

      double min, max, delta;
      double h, s, v;

      min = Math.min(Math.min(mRed, mGreen), mBlue);
      max = Math.max(Math.max(mRed, mGreen), mBlue);
      v = max; // v

      delta = max - min;

      if (max != 0)
      {
         s = delta / max; // s
      }
      else
      {
         // r = g = b = 0 // s = 0, v is undefined
         s = 0;
         h = 0;
         assert h >= 0 && h <= 360;
         assert s >= 0 && s <= 1;
         assert v >= 0 && v <= 1;

         hsv[0] = h;
         hsv[1] = s;
         hsv[2] = v;
         return;
      }

      if (delta == 0)
      {
         h = 0;
      }
      else
      {
         if (mRed == max)
         {
            h = (mGreen - mBlue) / delta; // between yellow & magenta
         }
         else if (mGreen == max)
         {
            h = 2 + (mBlue - mRed) / delta; // between cyan & yellow
         }
         else
         {
            h = 4 + (mRed - mGreen) / delta; // between magenta & cyan
         }
      }

      h *= 60; // degrees
      if (h < 0)
      {
         h += 360;
      }

      assert h >= 0 && h <= 360;
      assert s >= 0 && s <= 1;
      assert v >= 0 && v <= 1;

      hsv[0] = h;
      hsv[1] = s;
      hsv[2] = v;
   }

   private final double mRed;
   private final double mGreen;
   private final double mBlue;
   private final double mAlpha;
}
-e 


package com.bitwig.extension.callback;

public interface ClipLauncherSlotBankPlaybackStateChangedCallback extends Callback
{
   /**
    * Registers an observer that reports the playback state of clips / slots. The reported states include
    * `stopped`, `playing`, `recording`, but also `queued for stop`, `queued for playback`, `queued for
    * recording`.
    *
    * @param playbackState the queued or playback state: `0` when stopped, `1` when playing, or `2` when recording
    * @param isQueued indicates if the second argument is referring to the queued state (`true`) or the actual playback state (`false`)
    * @since API version 1
    */
   void playbackStateChanged(int slotIndex, int playbackState, boolean isQueued);
}
-e 


package com.bitwig.extension.callback;

public interface StepDataChangedCallback extends Callback
{
   /**
    * A callback function that receives three parameters: 1. the x (step) coordinate within the note grid
    * (integer), 2. the y (key) coordinate within the note grid (integer), and 3. an integer value that
    * indicates if the step is empty (`0`) or if a note continues playing (`1`) or starts playing (`2`).
    */
   void stepStateChanged(int x, int y, int state);
}
-e 


package com.bitwig.extension.callback;

public interface EnumValueChangedCallback extends ObjectValueChangedCallback<String>
{

}
-e 


package com.bitwig.extension.callback;

public interface ValueChangedCallback extends Callback
{

}
-e 


package com.bitwig.extension.callback;

public interface NotePlaybackCallback extends Callback
{
   void notePlaybackEventOccurred(boolean isNoteOn, int key, float velocity);
}
-e 


package com.bitwig.extension.callback;

public interface IndexedBooleanValueChangedCallback extends IndexedValueChangedCallback
{
   /**
    * @since API version 1
    */
   void valueChanged(int index, boolean newValue);
}
-e 


package com.bitwig.extension.callback;

public interface DirectParameterNameChangedCallback extends Callback
{
   void directParameterNameChanged(String id, String name);
}
-e 


package com.bitwig.extension.callback;

public interface StringValueChangedCallback extends ObjectValueChangedCallback<String>
{

}
-e 


package com.bitwig.extension.callback;

public interface DoubleValueChangedCallback extends ValueChangedCallback
{
   void valueChanged(double newValue);
}
-e 


package com.bitwig.extension.callback;

public interface IndexedValueChangedCallback extends Callback
{

}
-e 


package com.bitwig.extension.callback;

import com.bitwig.extension.api.util.midi.ShortMidiMessage;

public interface ShortMidiMessageReceivedCallback extends ShortMidiDataReceivedCallback
{
   /**
    * Callback for receiving short (normal) MIDI messages on this MIDI input port.
    *
    * @since API version 2
    */
   void midiReceived(final ShortMidiMessage msg);

   @Override
   default void midiReceived(int statusByte, int data1, int data2)
   {
      midiReceived(new ShortMidiMessage(statusByte, data1, data2));
   }
}
-e 


package com.bitwig.extension.callback;

public interface SysexMidiDataReceivedCallback extends Callback
{
   /**
    * @param data
    *           The data encoded as a hex string
    */
   void sysexDataReceived(String data);
}
-e 


package com.bitwig.extension.callback;

public interface ObjectValueChangedCallback<ValueType> extends ValueChangedCallback
{
   void valueChanged(ValueType newValue);
}
-e 


package com.bitwig.extension.callback;

public interface DirectParameterDisplayedValueChangedCallback extends Callback
{
   void directParameterDisplayedValueChanged(String id, String value);
}
-e 


package com.bitwig.extension.callback;

public interface FloatValueChangedCallback extends Callback
{
   void valueChanged(float newValue);
}
-e 


package com.bitwig.extension.callback;

import com.bitwig.extension.api.Color;

public interface ColorValueChangedCallback extends ValueChangedCallback
{
   /**
    * As alpha component was introduced after this interface was released,
    * the alpha component is not part of the parameter and would have to be
    * checked manually.
    */
   void valueChanged(float red, float green, float blue);
}
-e 


package com.bitwig.extension.callback;

public interface IndexedStringValueChangedCallback extends IndexedValueChangedCallback
{
   /**
    * Registers an observer that reports the names of the scenes and slots. The slot names reflect the names
    * of containing clips.
    *
    * @since API version 1
    */
   void valueChanged(int index, String newValue);
}
-e 


package com.bitwig.extension.callback;

public interface Callback
{

}
-e 


package com.bitwig.extension.callback;

import com.bitwig.extension.controller.api.RemoteConnection;

public interface ConnectionEstablishedCallback extends Callback
{
   void connectionEstablished(RemoteConnection connection);
}
-e 


package com.bitwig.extension.callback;

public interface NoArgsCallback extends Callback
{
   void call();
}
-e 


package com.bitwig.extension.callback;

public interface IndexedColorValueChangedCallback extends IndexedValueChangedCallback
{
   /**
    * Registers an observer that reports the names of the scenes and slots. The slot names reflect the names
    * of containing clips.
    *
    * @since API version 1
    */
   void valueChanged(int index, float red, float green, float blue);
}
-e 


package com.bitwig.extension.callback;

public interface StringArrayValueChangedCallback extends ObjectValueChangedCallback<String[]>
{
}
-e 


package com.bitwig.extension.callback;

public interface DataReceivedCallback extends Callback
{
   void dataReceived(byte[] data);
}
-e 


package com.bitwig.extension.callback;

import com.bitwig.extension.controller.api.NoteStep;

public interface NoteStepChangedCallback extends Callback
{
   void noteStepChanged(final NoteStep noteStep);
}
-e 


package com.bitwig.extension.callback;

public interface BooleanValueChangedCallback extends ValueChangedCallback
{
   void valueChanged(boolean newValue);
}
-e 


package com.bitwig.extension.callback;

public interface ShortMidiDataReceivedCallback extends Callback
{
   /**
    * Callback for receiving short (normal) MIDI messages on this MIDI input port.
    *
    * @since API version 1
    */
   void midiReceived(int statusByte, int data1, int data2);
}
-e 


package com.bitwig.extension.callback;

public interface IntegerValueChangedCallback extends ValueChangedCallback
{
   void valueChanged(int newValue);
}
-e 


package com.bitwig.extension.callback;

public interface DirectParameterNormalizedValueChangedCallback extends Callback
{
   void directParameterNormalizedValueChanged(String id, double normalizedValue);
}
-e 


